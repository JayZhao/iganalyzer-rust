// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod fp {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBTaskType {
  None = 0,
  FetchAccountInfo = 1,
  FetchMediaLikes = 2,
  FetchMediaComments = 3,
  FetchAccountFollowings = 4,
  FetchAccountFollowers = 5,
  FetchAccountMedias = 6,
  FetchAccountLikedMedias = 7,
  FetchAccountBlockings = 8,
  FetchAccountRelation = 9,
  FetchAccountActivities = 10,
  FetchAccountStories = 11,
  FetchMediaInfo = 12,
  FetchStoryViewers = 13,
  FetchUserTags = 14,

}

pub const ENUM_MIN_FBTASK_TYPE: u8 = 0;
pub const ENUM_MAX_FBTASK_TYPE: u8 = 14;

impl<'a> flatbuffers::Follow<'a> for FBTaskType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBTaskType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBTaskType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBTaskType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBTaskType {
    type Output = FBTaskType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBTaskType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBTASK_TYPE:[FBTaskType; 15] = [
  FBTaskType::None,
  FBTaskType::FetchAccountInfo,
  FBTaskType::FetchMediaLikes,
  FBTaskType::FetchMediaComments,
  FBTaskType::FetchAccountFollowings,
  FBTaskType::FetchAccountFollowers,
  FBTaskType::FetchAccountMedias,
  FBTaskType::FetchAccountLikedMedias,
  FBTaskType::FetchAccountBlockings,
  FBTaskType::FetchAccountRelation,
  FBTaskType::FetchAccountActivities,
  FBTaskType::FetchAccountStories,
  FBTaskType::FetchMediaInfo,
  FBTaskType::FetchStoryViewers,
  FBTaskType::FetchUserTags
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBTASK_TYPE:[&'static str; 15] = [
    "None",
    "FetchAccountInfo",
    "FetchMediaLikes",
    "FetchMediaComments",
    "FetchAccountFollowings",
    "FetchAccountFollowers",
    "FetchAccountMedias",
    "FetchAccountLikedMedias",
    "FetchAccountBlockings",
    "FetchAccountRelation",
    "FetchAccountActivities",
    "FetchAccountStories",
    "FetchMediaInfo",
    "FetchStoryViewers",
    "FetchUserTags"
];

pub fn enum_name_fbtask_type(e: FBTaskType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBTASK_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBTaskState {
  Pending = 0,
  Success = 1,
  Failure = 2,

}

pub const ENUM_MIN_FBTASK_STATE: u8 = 0;
pub const ENUM_MAX_FBTASK_STATE: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FBTaskState {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBTaskState {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBTaskState;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBTaskState;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBTaskState {
    type Output = FBTaskState;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBTaskState>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBTASK_STATE:[FBTaskState; 3] = [
  FBTaskState::Pending,
  FBTaskState::Success,
  FBTaskState::Failure
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBTASK_STATE:[&'static str; 3] = [
    "Pending",
    "Success",
    "Failure"
];

pub fn enum_name_fbtask_state(e: FBTaskState) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBTASK_STATE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBTaskFailureAction {
  DispatchToOther = 0,
  DispatchToSelf = 1,
  DeleteTask = 2,

}

pub const ENUM_MIN_FBTASK_FAILURE_ACTION: u8 = 0;
pub const ENUM_MAX_FBTASK_FAILURE_ACTION: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FBTaskFailureAction {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBTaskFailureAction {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBTaskFailureAction;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBTaskFailureAction;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBTaskFailureAction {
    type Output = FBTaskFailureAction;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBTaskFailureAction>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBTASK_FAILURE_ACTION:[FBTaskFailureAction; 3] = [
  FBTaskFailureAction::DispatchToOther,
  FBTaskFailureAction::DispatchToSelf,
  FBTaskFailureAction::DeleteTask
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBTASK_FAILURE_ACTION:[&'static str; 3] = [
    "DispatchToOther",
    "DispatchToSelf",
    "DeleteTask"
];

pub fn enum_name_fbtask_failure_action(e: FBTaskFailureAction) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBTASK_FAILURE_ACTION[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBMediaType {
  None = 0,
  Photo = 1,
  Video = 2,
  Carousel = 8,

}

pub const ENUM_MIN_FBMEDIA_TYPE: u8 = 0;
pub const ENUM_MAX_FBMEDIA_TYPE: u8 = 8;

impl<'a> flatbuffers::Follow<'a> for FBMediaType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBMediaType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBMediaType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBMediaType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBMediaType {
    type Output = FBMediaType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBMediaType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBMEDIA_TYPE:[FBMediaType; 4] = [
  FBMediaType::None,
  FBMediaType::Photo,
  FBMediaType::Video,
  FBMediaType::Carousel
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBMEDIA_TYPE:[&'static str; 9] = [
    "None",
    "Photo",
    "Video",
    "",
    "",
    "",
    "",
    "",
    "Carousel"
];

pub fn enum_name_fbmedia_type(e: FBMediaType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBMEDIA_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBRelationship {
  Null = 0,
  Follow = 1,
  Block = 2,
  Requested = 3,
  NoRelation = 4,

}

pub const ENUM_MIN_FBRELATIONSHIP: u8 = 0;
pub const ENUM_MAX_FBRELATIONSHIP: u8 = 4;

impl<'a> flatbuffers::Follow<'a> for FBRelationship {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBRelationship {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBRelationship;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBRelationship;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBRelationship {
    type Output = FBRelationship;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBRelationship>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBRELATIONSHIP:[FBRelationship; 5] = [
  FBRelationship::Null,
  FBRelationship::Follow,
  FBRelationship::Block,
  FBRelationship::Requested,
  FBRelationship::NoRelation
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBRELATIONSHIP:[&'static str; 5] = [
    "Null",
    "Follow",
    "Block",
    "Requested",
    "NoRelation"
];

pub fn enum_name_fbrelationship(e: FBRelationship) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBRELATIONSHIP[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBActivityType {
  Null = 0,
  Like = 1,
  Comment = 2,
  Follow = 3,

}

pub const ENUM_MIN_FBACTIVITY_TYPE: u8 = 0;
pub const ENUM_MAX_FBACTIVITY_TYPE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for FBActivityType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBActivityType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBActivityType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBActivityType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBActivityType {
    type Output = FBActivityType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBActivityType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBACTIVITY_TYPE:[FBActivityType; 4] = [
  FBActivityType::Null,
  FBActivityType::Like,
  FBActivityType::Comment,
  FBActivityType::Follow
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBACTIVITY_TYPE:[&'static str; 4] = [
    "Null",
    "Like",
    "Comment",
    "Follow"
];

pub fn enum_name_fbactivity_type(e: FBActivityType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBACTIVITY_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBTaskContent {
  NONE = 0,
  FBTaskContentFetchAccountInfo = 1,
  FBTaskContentFetchMediaLikers = 2,
  FBTaskContentFetchMediaComments = 3,
  FBTaskContentFetchAccountFollowings = 4,
  FBTaskContentFetchAccountFollowers = 5,
  FBTaskContentFetchAccountMedias = 6,
  FBTaskContentFetchAccountLikedMedias = 7,
  FBTaskContentFetchAccountBlockings = 8,
  FBTaskContentFetchAccountRelation = 9,
  FBTaskContentFetchAccountActivities = 10,
  FBTaskContentFetchAccountStories = 11,
  FBTaskContentFetchMediaInfo = 12,
  FBTaskContentFetchStoryViewers = 13,
  FBTaskContentFetchUserTags = 14,

}

pub const ENUM_MIN_FBTASK_CONTENT: u8 = 0;
pub const ENUM_MAX_FBTASK_CONTENT: u8 = 14;

impl<'a> flatbuffers::Follow<'a> for FBTaskContent {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBTaskContent {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBTaskContent;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBTaskContent;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBTaskContent {
    type Output = FBTaskContent;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBTaskContent>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBTASK_CONTENT:[FBTaskContent; 15] = [
  FBTaskContent::NONE,
  FBTaskContent::FBTaskContentFetchAccountInfo,
  FBTaskContent::FBTaskContentFetchMediaLikers,
  FBTaskContent::FBTaskContentFetchMediaComments,
  FBTaskContent::FBTaskContentFetchAccountFollowings,
  FBTaskContent::FBTaskContentFetchAccountFollowers,
  FBTaskContent::FBTaskContentFetchAccountMedias,
  FBTaskContent::FBTaskContentFetchAccountLikedMedias,
  FBTaskContent::FBTaskContentFetchAccountBlockings,
  FBTaskContent::FBTaskContentFetchAccountRelation,
  FBTaskContent::FBTaskContentFetchAccountActivities,
  FBTaskContent::FBTaskContentFetchAccountStories,
  FBTaskContent::FBTaskContentFetchMediaInfo,
  FBTaskContent::FBTaskContentFetchStoryViewers,
  FBTaskContent::FBTaskContentFetchUserTags
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBTASK_CONTENT:[&'static str; 15] = [
    "NONE",
    "FBTaskContentFetchAccountInfo",
    "FBTaskContentFetchMediaLikers",
    "FBTaskContentFetchMediaComments",
    "FBTaskContentFetchAccountFollowings",
    "FBTaskContentFetchAccountFollowers",
    "FBTaskContentFetchAccountMedias",
    "FBTaskContentFetchAccountLikedMedias",
    "FBTaskContentFetchAccountBlockings",
    "FBTaskContentFetchAccountRelation",
    "FBTaskContentFetchAccountActivities",
    "FBTaskContentFetchAccountStories",
    "FBTaskContentFetchMediaInfo",
    "FBTaskContentFetchStoryViewers",
    "FBTaskContentFetchUserTags"
];

pub fn enum_name_fbtask_content(e: FBTaskContent) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBTASK_CONTENT[index as usize]
}

pub struct FBTaskContentUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBSocialPlatformType {
  Instagram = 0,

}

pub const ENUM_MIN_FBSOCIAL_PLATFORM_TYPE: u8 = 0;
pub const ENUM_MAX_FBSOCIAL_PLATFORM_TYPE: u8 = 0;

impl<'a> flatbuffers::Follow<'a> for FBSocialPlatformType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBSocialPlatformType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBSocialPlatformType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBSocialPlatformType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBSocialPlatformType {
    type Output = FBSocialPlatformType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBSocialPlatformType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBSOCIAL_PLATFORM_TYPE:[FBSocialPlatformType; 1] = [
  FBSocialPlatformType::Instagram
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBSOCIAL_PLATFORM_TYPE:[&'static str; 1] = [
    "Instagram"
];

pub fn enum_name_fbsocial_platform_type(e: FBSocialPlatformType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBSOCIAL_PLATFORM_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBAppType {
  SanTi = 0,
  FollowersPlus = 1,
  IGtrack = 2,
  IgAnalyzerAndroid = 3,

}

pub const ENUM_MIN_FBAPP_TYPE: u8 = 0;
pub const ENUM_MAX_FBAPP_TYPE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for FBAppType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBAppType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBAppType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBAppType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBAppType {
    type Output = FBAppType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBAppType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBAPP_TYPE:[FBAppType; 4] = [
  FBAppType::SanTi,
  FBAppType::FollowersPlus,
  FBAppType::IGtrack,
  FBAppType::IgAnalyzerAndroid
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBAPP_TYPE:[&'static str; 4] = [
    "SanTi",
    "FollowersPlus",
    "IGtrack",
    "IgAnalyzerAndroid"
];

pub fn enum_name_fbapp_type(e: FBAppType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBAPP_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBAuthPBError {
  Success = 0,
  ParamError = 1,
  UserSIDMismatch = 2,
  InvalidAccessToken = 3,

}

pub const ENUM_MIN_FBAUTH_PBERROR: u8 = 0;
pub const ENUM_MAX_FBAUTH_PBERROR: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for FBAuthPBError {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBAuthPBError {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBAuthPBError;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBAuthPBError;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBAuthPBError {
    type Output = FBAuthPBError;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBAuthPBError>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBAUTH_PBERROR:[FBAuthPBError; 4] = [
  FBAuthPBError::Success,
  FBAuthPBError::ParamError,
  FBAuthPBError::UserSIDMismatch,
  FBAuthPBError::InvalidAccessToken
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBAUTH_PBERROR:[&'static str; 4] = [
    "Success",
    "ParamError",
    "UserSIDMismatch",
    "InvalidAccessToken"
];

pub fn enum_name_fbauth_pberror(e: FBAuthPBError) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBAUTH_PBERROR[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBInternalMessageContent {
  NONE = 0,
  FBAuthPBRequest = 1,
  FBAuthPBReply = 2,
  FBFetchMetaDataRequest = 3,
  FBFetchMetaDataReply = 4,
  FBFetchAccountRelationshipsRequest = 5,
  FBFetchAccountRelationshipsReply = 6,

}

pub const ENUM_MIN_FBINTERNAL_MESSAGE_CONTENT: u8 = 0;
pub const ENUM_MAX_FBINTERNAL_MESSAGE_CONTENT: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for FBInternalMessageContent {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBInternalMessageContent {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBInternalMessageContent;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBInternalMessageContent;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBInternalMessageContent {
    type Output = FBInternalMessageContent;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBInternalMessageContent>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBINTERNAL_MESSAGE_CONTENT:[FBInternalMessageContent; 7] = [
  FBInternalMessageContent::NONE,
  FBInternalMessageContent::FBAuthPBRequest,
  FBInternalMessageContent::FBAuthPBReply,
  FBInternalMessageContent::FBFetchMetaDataRequest,
  FBInternalMessageContent::FBFetchMetaDataReply,
  FBInternalMessageContent::FBFetchAccountRelationshipsRequest,
  FBInternalMessageContent::FBFetchAccountRelationshipsReply
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBINTERNAL_MESSAGE_CONTENT:[&'static str; 7] = [
    "NONE",
    "FBAuthPBRequest",
    "FBAuthPBReply",
    "FBFetchMetaDataRequest",
    "FBFetchMetaDataReply",
    "FBFetchAccountRelationshipsRequest",
    "FBFetchAccountRelationshipsReply"
];

pub fn enum_name_fbinternal_message_content(e: FBInternalMessageContent) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBINTERNAL_MESSAGE_CONTENT[index as usize]
}

pub struct FBInternalMessageContentUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBInternalMessageType {
  None = 0,
  AuthPB = 1,
  FetchMetaData = 2,
  FetchAccountRelationships = 3,

}

pub const ENUM_MIN_FBINTERNAL_MESSAGE_TYPE: u8 = 0;
pub const ENUM_MAX_FBINTERNAL_MESSAGE_TYPE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for FBInternalMessageType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBInternalMessageType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FBInternalMessageType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FBInternalMessageType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBInternalMessageType {
    type Output = FBInternalMessageType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBInternalMessageType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBINTERNAL_MESSAGE_TYPE:[FBInternalMessageType; 4] = [
  FBInternalMessageType::None,
  FBInternalMessageType::AuthPB,
  FBInternalMessageType::FetchMetaData,
  FBInternalMessageType::FetchAccountRelationships
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBINTERNAL_MESSAGE_TYPE:[&'static str; 4] = [
    "None",
    "AuthPB",
    "FetchMetaData",
    "FetchAccountRelationships"
];

pub fn enum_name_fbinternal_message_type(e: FBInternalMessageType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FBINTERNAL_MESSAGE_TYPE[index as usize]
}

// struct FBAccountRelationshipData, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct FBAccountRelationshipData {
  targetAccountID_: u64,
  incomingRelation_: FBRelationship,
  outgoingRelation_: FBRelationship,
  padding0__: u16,  padding1__: u32,
} // pub struct FBAccountRelationshipData
impl flatbuffers::SafeSliceAccess for FBAccountRelationshipData {}
impl<'a> flatbuffers::Follow<'a> for FBAccountRelationshipData {
  type Inner = &'a FBAccountRelationshipData;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a FBAccountRelationshipData>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a FBAccountRelationshipData {
  type Inner = &'a FBAccountRelationshipData;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<FBAccountRelationshipData>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for FBAccountRelationshipData {
    type Output = FBAccountRelationshipData;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const FBAccountRelationshipData as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b FBAccountRelationshipData {
    type Output = FBAccountRelationshipData;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const FBAccountRelationshipData as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl FBAccountRelationshipData {
  pub fn new<'a>(_targetAccountID: u64, _incomingRelation: FBRelationship, _outgoingRelation: FBRelationship) -> Self {
    FBAccountRelationshipData {
      targetAccountID_: _targetAccountID.to_little_endian(),
      incomingRelation_: _incomingRelation.to_little_endian(),
      outgoingRelation_: _outgoingRelation.to_little_endian(),

      padding0__: 0,padding1__: 0,
    }
  }
  pub fn targetAccountID<'a>(&'a self) -> u64 {
    self.targetAccountID_.from_little_endian()
  }
  pub fn incomingRelation<'a>(&'a self) -> FBRelationship {
    self.incomingRelation_.from_little_endian()
  }
  pub fn outgoingRelation<'a>(&'a self) -> FBRelationship {
    self.outgoingRelation_.from_little_endian()
  }
}

pub enum FBAccountOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBAccount<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBAccount<'a> {
    type Inner = FBAccount<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBAccount<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBAccount {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBAccountArgs<'args>) -> flatbuffers::WIPOffset<FBAccount<'bldr>> {
      let mut builder = FBAccountBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.add_countTime(args.countTime);
      builder.add_followerCount(args.followerCount);
      builder.add_mediaCount(args.mediaCount);
      if let Some(x) = args.avatarURLString { builder.add_avatarURLString(x); }
      if let Some(x) = args.fullName { builder.add_fullName(x); }
      if let Some(x) = args.username { builder.add_username(x); }
      builder.add_followingCount(args.followingCount);
      builder.add_isPrivate(args.isPrivate);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_USERNAME: flatbuffers::VOffsetT = 6;
    pub const VT_FULLNAME: flatbuffers::VOffsetT = 8;
    pub const VT_AVATARURLSTRING: flatbuffers::VOffsetT = 10;
    pub const VT_ISPRIVATE: flatbuffers::VOffsetT = 12;
    pub const VT_MEDIACOUNT: flatbuffers::VOffsetT = 14;
    pub const VT_FOLLOWINGCOUNT: flatbuffers::VOffsetT = 16;
    pub const VT_FOLLOWERCOUNT: flatbuffers::VOffsetT = 18;
    pub const VT_COUNTTIME: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(FBAccount::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBAccount::VT_USERNAME, None)
  }
  #[inline]
  pub fn fullName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBAccount::VT_FULLNAME, None)
  }
  #[inline]
  pub fn avatarURLString(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBAccount::VT_AVATARURLSTRING, None)
  }
  #[inline]
  pub fn isPrivate(&self) -> bool {
    self._tab.get::<bool>(FBAccount::VT_ISPRIVATE, Some(false)).unwrap()
  }
  #[inline]
  pub fn mediaCount(&self) -> u32 {
    self._tab.get::<u32>(FBAccount::VT_MEDIACOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn followingCount(&self) -> u16 {
    self._tab.get::<u16>(FBAccount::VT_FOLLOWINGCOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn followerCount(&self) -> u32 {
    self._tab.get::<u32>(FBAccount::VT_FOLLOWERCOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn countTime(&self) -> u32 {
    self._tab.get::<u32>(FBAccount::VT_COUNTTIME, Some(0)).unwrap()
  }
}

pub struct FBAccountArgs<'a> {
    pub id: u64,
    pub username: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub fullName: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub avatarURLString: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub isPrivate: bool,
    pub mediaCount: u32,
    pub followingCount: u16,
    pub followerCount: u32,
    pub countTime: u32,
}
impl<'a> Default for FBAccountArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBAccountArgs {
            id: 0,
            username: None,
            fullName: None,
            avatarURLString: None,
            isPrivate: false,
            mediaCount: 0,
            followingCount: 0,
            followerCount: 0,
            countTime: 0,
        }
    }
}
pub struct FBAccountBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBAccountBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(FBAccount::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_username(&mut self, username: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBAccount::VT_USERNAME, username);
  }
  #[inline]
  pub fn add_fullName(&mut self, fullName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBAccount::VT_FULLNAME, fullName);
  }
  #[inline]
  pub fn add_avatarURLString(&mut self, avatarURLString: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBAccount::VT_AVATARURLSTRING, avatarURLString);
  }
  #[inline]
  pub fn add_isPrivate(&mut self, isPrivate: bool) {
    self.fbb_.push_slot::<bool>(FBAccount::VT_ISPRIVATE, isPrivate, false);
  }
  #[inline]
  pub fn add_mediaCount(&mut self, mediaCount: u32) {
    self.fbb_.push_slot::<u32>(FBAccount::VT_MEDIACOUNT, mediaCount, 0);
  }
  #[inline]
  pub fn add_followingCount(&mut self, followingCount: u16) {
    self.fbb_.push_slot::<u16>(FBAccount::VT_FOLLOWINGCOUNT, followingCount, 0);
  }
  #[inline]
  pub fn add_followerCount(&mut self, followerCount: u32) {
    self.fbb_.push_slot::<u32>(FBAccount::VT_FOLLOWERCOUNT, followerCount, 0);
  }
  #[inline]
  pub fn add_countTime(&mut self, countTime: u32) {
    self.fbb_.push_slot::<u32>(FBAccount::VT_COUNTTIME, countTime, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBAccountBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBAccountBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBAccount<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBURLVersionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBURLVersion<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBURLVersion<'a> {
    type Inner = FBURLVersion<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBURLVersion<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBURLVersion {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBURLVersionArgs<'args>) -> flatbuffers::WIPOffset<FBURLVersion<'bldr>> {
      let mut builder = FBURLVersionBuilder::new(_fbb);
      if let Some(x) = args.urlString { builder.add_urlString(x); }
      builder.add_height(args.height);
      builder.add_width(args.width);
      builder.finish()
    }

    pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
    pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_URLSTRING: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn width(&self) -> u16 {
    self._tab.get::<u16>(FBURLVersion::VT_WIDTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn height(&self) -> u16 {
    self._tab.get::<u16>(FBURLVersion::VT_HEIGHT, Some(0)).unwrap()
  }
  #[inline]
  pub fn urlString(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBURLVersion::VT_URLSTRING, None)
  }
}

pub struct FBURLVersionArgs<'a> {
    pub width: u16,
    pub height: u16,
    pub urlString: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for FBURLVersionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBURLVersionArgs {
            width: 0,
            height: 0,
            urlString: None,
        }
    }
}
pub struct FBURLVersionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBURLVersionBuilder<'a, 'b> {
  #[inline]
  pub fn add_width(&mut self, width: u16) {
    self.fbb_.push_slot::<u16>(FBURLVersion::VT_WIDTH, width, 0);
  }
  #[inline]
  pub fn add_height(&mut self, height: u16) {
    self.fbb_.push_slot::<u16>(FBURLVersion::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_urlString(&mut self, urlString: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBURLVersion::VT_URLSTRING, urlString);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBURLVersionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBURLVersionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBURLVersion<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBMediaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBMedia<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBMedia<'a> {
    type Inner = FBMedia<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBMedia<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBMedia {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBMediaArgs<'args>) -> flatbuffers::WIPOffset<FBMedia<'bldr>> {
      let mut builder = FBMediaBuilder::new(_fbb);
      builder.add_createTime(args.createTime);
      builder.add_id(args.id);
      if let Some(x) = args.usertags { builder.add_usertags(x); }
      if let Some(x) = args.hashtags { builder.add_hashtags(x); }
      if let Some(x) = args.emojis { builder.add_emojis(x); }
      builder.add_filterType(args.filterType);
      if let Some(x) = args.videoURLVersions { builder.add_videoURLVersions(x); }
      if let Some(x) = args.imageURLVersions { builder.add_imageURLVersions(x); }
      if let Some(x) = args.owner { builder.add_owner(x); }
      builder.add_viewCount(args.viewCount);
      builder.add_commentCount(args.commentCount);
      builder.add_likeCount(args.likeCount);
      if let Some(x) = args.mediaCode { builder.add_mediaCode(x); }
      builder.add_isIGTV(args.isIGTV);
      builder.add_isStory(args.isStory);
      builder.add_mediaType(args.mediaType);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_MEDIATYPE: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIACODE: flatbuffers::VOffsetT = 8;
    pub const VT_CREATETIME: flatbuffers::VOffsetT = 10;
    pub const VT_LIKECOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_COMMENTCOUNT: flatbuffers::VOffsetT = 14;
    pub const VT_VIEWCOUNT: flatbuffers::VOffsetT = 16;
    pub const VT_OWNER: flatbuffers::VOffsetT = 18;
    pub const VT_IMAGEURLVERSIONS: flatbuffers::VOffsetT = 20;
    pub const VT_VIDEOURLVERSIONS: flatbuffers::VOffsetT = 22;
    pub const VT_ISSTORY: flatbuffers::VOffsetT = 24;
    pub const VT_ISIGTV: flatbuffers::VOffsetT = 26;
    pub const VT_FILTERTYPE: flatbuffers::VOffsetT = 28;
    pub const VT_EMOJIS: flatbuffers::VOffsetT = 30;
    pub const VT_HASHTAGS: flatbuffers::VOffsetT = 32;
    pub const VT_USERTAGS: flatbuffers::VOffsetT = 34;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(FBMedia::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn mediaType(&self) -> FBMediaType {
    self._tab.get::<FBMediaType>(FBMedia::VT_MEDIATYPE, Some(FBMediaType::None)).unwrap()
  }
  #[inline]
  pub fn mediaCode(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBMedia::VT_MEDIACODE, None)
  }
  #[inline]
  pub fn createTime(&self) -> u64 {
    self._tab.get::<u64>(FBMedia::VT_CREATETIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn likeCount(&self) -> u32 {
    self._tab.get::<u32>(FBMedia::VT_LIKECOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn commentCount(&self) -> u32 {
    self._tab.get::<u32>(FBMedia::VT_COMMENTCOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn viewCount(&self) -> u32 {
    self._tab.get::<u32>(FBMedia::VT_VIEWCOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn owner(&self) -> Option<FBAccount<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBAccount<'a>>>(FBMedia::VT_OWNER, None)
  }
  #[inline]
  pub fn imageURLVersions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBURLVersion<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBURLVersion<'a>>>>>(FBMedia::VT_IMAGEURLVERSIONS, None)
  }
  #[inline]
  pub fn videoURLVersions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBURLVersion<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBURLVersion<'a>>>>>(FBMedia::VT_VIDEOURLVERSIONS, None)
  }
  #[inline]
  pub fn isStory(&self) -> bool {
    self._tab.get::<bool>(FBMedia::VT_ISSTORY, Some(false)).unwrap()
  }
  #[inline]
  pub fn isIGTV(&self) -> bool {
    self._tab.get::<bool>(FBMedia::VT_ISIGTV, Some(false)).unwrap()
  }
  #[inline]
  pub fn filterType(&self) -> i32 {
    self._tab.get::<i32>(FBMedia::VT_FILTERTYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn emojis(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(FBMedia::VT_EMOJIS, None)
  }
  #[inline]
  pub fn hashtags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(FBMedia::VT_HASHTAGS, None)
  }
  #[inline]
  pub fn usertags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBMedia::VT_USERTAGS, None)
  }
}

pub struct FBMediaArgs<'a> {
    pub id: u64,
    pub mediaType: FBMediaType,
    pub mediaCode: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub createTime: u64,
    pub likeCount: u32,
    pub commentCount: u32,
    pub viewCount: u32,
    pub owner: Option<flatbuffers::WIPOffset<FBAccount<'a >>>,
    pub imageURLVersions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBURLVersion<'a >>>>>,
    pub videoURLVersions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBURLVersion<'a >>>>>,
    pub isStory: bool,
    pub isIGTV: bool,
    pub filterType: i32,
    pub emojis: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub hashtags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub usertags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
}
impl<'a> Default for FBMediaArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBMediaArgs {
            id: 0,
            mediaType: FBMediaType::None,
            mediaCode: None,
            createTime: 0,
            likeCount: 0,
            commentCount: 0,
            viewCount: 0,
            owner: None,
            imageURLVersions: None,
            videoURLVersions: None,
            isStory: false,
            isIGTV: false,
            filterType: 0,
            emojis: None,
            hashtags: None,
            usertags: None,
        }
    }
}
pub struct FBMediaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBMediaBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(FBMedia::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_mediaType(&mut self, mediaType: FBMediaType) {
    self.fbb_.push_slot::<FBMediaType>(FBMedia::VT_MEDIATYPE, mediaType, FBMediaType::None);
  }
  #[inline]
  pub fn add_mediaCode(&mut self, mediaCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBMedia::VT_MEDIACODE, mediaCode);
  }
  #[inline]
  pub fn add_createTime(&mut self, createTime: u64) {
    self.fbb_.push_slot::<u64>(FBMedia::VT_CREATETIME, createTime, 0);
  }
  #[inline]
  pub fn add_likeCount(&mut self, likeCount: u32) {
    self.fbb_.push_slot::<u32>(FBMedia::VT_LIKECOUNT, likeCount, 0);
  }
  #[inline]
  pub fn add_commentCount(&mut self, commentCount: u32) {
    self.fbb_.push_slot::<u32>(FBMedia::VT_COMMENTCOUNT, commentCount, 0);
  }
  #[inline]
  pub fn add_viewCount(&mut self, viewCount: u32) {
    self.fbb_.push_slot::<u32>(FBMedia::VT_VIEWCOUNT, viewCount, 0);
  }
  #[inline]
  pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<FBAccount<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBAccount>>(FBMedia::VT_OWNER, owner);
  }
  #[inline]
  pub fn add_imageURLVersions(&mut self, imageURLVersions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBURLVersion<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBMedia::VT_IMAGEURLVERSIONS, imageURLVersions);
  }
  #[inline]
  pub fn add_videoURLVersions(&mut self, videoURLVersions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBURLVersion<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBMedia::VT_VIDEOURLVERSIONS, videoURLVersions);
  }
  #[inline]
  pub fn add_isStory(&mut self, isStory: bool) {
    self.fbb_.push_slot::<bool>(FBMedia::VT_ISSTORY, isStory, false);
  }
  #[inline]
  pub fn add_isIGTV(&mut self, isIGTV: bool) {
    self.fbb_.push_slot::<bool>(FBMedia::VT_ISIGTV, isIGTV, false);
  }
  #[inline]
  pub fn add_filterType(&mut self, filterType: i32) {
    self.fbb_.push_slot::<i32>(FBMedia::VT_FILTERTYPE, filterType, 0);
  }
  #[inline]
  pub fn add_emojis(&mut self, emojis: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBMedia::VT_EMOJIS, emojis);
  }
  #[inline]
  pub fn add_hashtags(&mut self, hashtags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBMedia::VT_HASHTAGS, hashtags);
  }
  #[inline]
  pub fn add_usertags(&mut self, usertags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBMedia::VT_USERTAGS, usertags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBMediaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBMediaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBMedia<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBCommentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBComment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBComment<'a> {
    type Inner = FBComment<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBComment<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBComment {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBCommentArgs<'args>) -> flatbuffers::WIPOffset<FBComment<'bldr>> {
      let mut builder = FBCommentBuilder::new(_fbb);
      builder.add_commentTime(args.commentTime);
      builder.add_id(args.id);
      if let Some(x) = args.commenter { builder.add_commenter(x); }
      if let Some(x) = args.text { builder.add_text(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TEXT: flatbuffers::VOffsetT = 6;
    pub const VT_COMMENTTIME: flatbuffers::VOffsetT = 8;
    pub const VT_COMMENTER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(FBComment::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBComment::VT_TEXT, None)
  }
  #[inline]
  pub fn commentTime(&self) -> u64 {
    self._tab.get::<u64>(FBComment::VT_COMMENTTIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn commenter(&self) -> Option<FBAccount<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBAccount<'a>>>(FBComment::VT_COMMENTER, None)
  }
}

pub struct FBCommentArgs<'a> {
    pub id: u64,
    pub text: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub commentTime: u64,
    pub commenter: Option<flatbuffers::WIPOffset<FBAccount<'a >>>,
}
impl<'a> Default for FBCommentArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBCommentArgs {
            id: 0,
            text: None,
            commentTime: 0,
            commenter: None,
        }
    }
}
pub struct FBCommentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBCommentBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(FBComment::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBComment::VT_TEXT, text);
  }
  #[inline]
  pub fn add_commentTime(&mut self, commentTime: u64) {
    self.fbb_.push_slot::<u64>(FBComment::VT_COMMENTTIME, commentTime, 0);
  }
  #[inline]
  pub fn add_commenter(&mut self, commenter: flatbuffers::WIPOffset<FBAccount<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBAccount>>(FBComment::VT_COMMENTER, commenter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBCommentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBCommentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBComment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountInfo<'a> {
    type Inner = FBTaskContentFetchAccountInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountInfoArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountInfo<'bldr>> {
      let mut builder = FBTaskContentFetchAccountInfoBuilder::new(_fbb);
      if let Some(x) = args.account { builder.add_account(x); }
      builder.finish()
    }

    pub const VT_ACCOUNT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn account(&self) -> Option<FBAccount<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBAccount<'a>>>(FBTaskContentFetchAccountInfo::VT_ACCOUNT, None)
  }
}

pub struct FBTaskContentFetchAccountInfoArgs<'a> {
    pub account: Option<flatbuffers::WIPOffset<FBAccount<'a >>>,
}
impl<'a> Default for FBTaskContentFetchAccountInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountInfoArgs {
            account: None,
        }
    }
}
pub struct FBTaskContentFetchAccountInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_account(&mut self, account: flatbuffers::WIPOffset<FBAccount<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBAccount>>(FBTaskContentFetchAccountInfo::VT_ACCOUNT, account);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountMediasOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountMedias<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountMedias<'a> {
    type Inner = FBTaskContentFetchAccountMedias<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountMedias<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountMedias {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountMediasArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountMedias<'bldr>> {
      let mut builder = FBTaskContentFetchAccountMediasBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.medias { builder.add_medias(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIAS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountMedias::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchAccountMedias::VT_CURSOR, None)
  }
  #[inline]
  pub fn medias(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBMedia<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBMedia<'a>>>>>(FBTaskContentFetchAccountMedias::VT_MEDIAS, None)
  }
}

pub struct FBTaskContentFetchAccountMediasArgs<'a> {
    pub accountID: u64,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub medias: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBMedia<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountMediasArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountMediasArgs {
            accountID: 0,
            cursor: None,
            medias: None,
        }
    }
}
pub struct FBTaskContentFetchAccountMediasBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountMediasBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountMedias::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountMedias::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_medias(&mut self, medias: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBMedia<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountMedias::VT_MEDIAS, medias);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountMediasBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountMediasBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountMedias<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchMediaLikersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchMediaLikers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchMediaLikers<'a> {
    type Inner = FBTaskContentFetchMediaLikers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchMediaLikers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchMediaLikers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchMediaLikersArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchMediaLikers<'bldr>> {
      let mut builder = FBTaskContentFetchMediaLikersBuilder::new(_fbb);
      builder.add_ownerID(args.ownerID);
      builder.add_mediaID(args.mediaID);
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      if let Some(x) = args.likers { builder.add_likers(x); }
      if let Some(x) = args.mediaCode { builder.add_mediaCode(x); }
      builder.finish()
    }

    pub const VT_MEDIAID: flatbuffers::VOffsetT = 4;
    pub const VT_OWNERID: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIACODE: flatbuffers::VOffsetT = 8;
    pub const VT_LIKERS: flatbuffers::VOffsetT = 10;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn mediaID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchMediaLikers::VT_MEDIAID, Some(0)).unwrap()
  }
  #[inline]
  pub fn ownerID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchMediaLikers::VT_OWNERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn mediaCode(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchMediaLikers::VT_MEDIACODE, None)
  }
  #[inline]
  pub fn likers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBTaskContentFetchMediaLikers::VT_LIKERS, None)
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchMediaLikers::VT_CURSOR, None)
  }
}

pub struct FBTaskContentFetchMediaLikersArgs<'a> {
    pub mediaID: u64,
    pub ownerID: u64,
    pub mediaCode: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub likers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for FBTaskContentFetchMediaLikersArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchMediaLikersArgs {
            mediaID: 0,
            ownerID: 0,
            mediaCode: None,
            likers: None,
            cursor: None,
        }
    }
}
pub struct FBTaskContentFetchMediaLikersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchMediaLikersBuilder<'a, 'b> {
  #[inline]
  pub fn add_mediaID(&mut self, mediaID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchMediaLikers::VT_MEDIAID, mediaID, 0);
  }
  #[inline]
  pub fn add_ownerID(&mut self, ownerID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchMediaLikers::VT_OWNERID, ownerID, 0);
  }
  #[inline]
  pub fn add_mediaCode(&mut self, mediaCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchMediaLikers::VT_MEDIACODE, mediaCode);
  }
  #[inline]
  pub fn add_likers(&mut self, likers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchMediaLikers::VT_LIKERS, likers);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchMediaLikers::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchMediaLikersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchMediaLikersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchMediaLikers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchMediaCommentsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchMediaComments<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchMediaComments<'a> {
    type Inner = FBTaskContentFetchMediaComments<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchMediaComments<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchMediaComments {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchMediaCommentsArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchMediaComments<'bldr>> {
      let mut builder = FBTaskContentFetchMediaCommentsBuilder::new(_fbb);
      builder.add_ownerID(args.ownerID);
      builder.add_mediaID(args.mediaID);
      if let Some(x) = args.comments { builder.add_comments(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      if let Some(x) = args.mediaCode { builder.add_mediaCode(x); }
      builder.finish()
    }

    pub const VT_MEDIAID: flatbuffers::VOffsetT = 4;
    pub const VT_OWNERID: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIACODE: flatbuffers::VOffsetT = 8;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 10;
    pub const VT_COMMENTS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn mediaID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchMediaComments::VT_MEDIAID, Some(0)).unwrap()
  }
  #[inline]
  pub fn ownerID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchMediaComments::VT_OWNERID, Some(0)).unwrap()
  }
  #[inline]
  pub fn mediaCode(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchMediaComments::VT_MEDIACODE, None)
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchMediaComments::VT_CURSOR, None)
  }
  #[inline]
  pub fn comments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBComment<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBComment<'a>>>>>(FBTaskContentFetchMediaComments::VT_COMMENTS, None)
  }
}

pub struct FBTaskContentFetchMediaCommentsArgs<'a> {
    pub mediaID: u64,
    pub ownerID: u64,
    pub mediaCode: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub comments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBComment<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchMediaCommentsArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchMediaCommentsArgs {
            mediaID: 0,
            ownerID: 0,
            mediaCode: None,
            cursor: None,
            comments: None,
        }
    }
}
pub struct FBTaskContentFetchMediaCommentsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchMediaCommentsBuilder<'a, 'b> {
  #[inline]
  pub fn add_mediaID(&mut self, mediaID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchMediaComments::VT_MEDIAID, mediaID, 0);
  }
  #[inline]
  pub fn add_ownerID(&mut self, ownerID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchMediaComments::VT_OWNERID, ownerID, 0);
  }
  #[inline]
  pub fn add_mediaCode(&mut self, mediaCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchMediaComments::VT_MEDIACODE, mediaCode);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchMediaComments::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBComment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchMediaComments::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchMediaCommentsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchMediaCommentsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchMediaComments<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountFollowersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountFollowers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountFollowers<'a> {
    type Inner = FBTaskContentFetchAccountFollowers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountFollowers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountFollowers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountFollowersArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountFollowers<'bldr>> {
      let mut builder = FBTaskContentFetchAccountFollowersBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.followers { builder.add_followers(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 6;
    pub const VT_FOLLOWERS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountFollowers::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchAccountFollowers::VT_CURSOR, None)
  }
  #[inline]
  pub fn followers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBTaskContentFetchAccountFollowers::VT_FOLLOWERS, None)
  }
}

pub struct FBTaskContentFetchAccountFollowersArgs<'a> {
    pub accountID: u64,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub followers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountFollowersArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountFollowersArgs {
            accountID: 0,
            cursor: None,
            followers: None,
        }
    }
}
pub struct FBTaskContentFetchAccountFollowersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountFollowersBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountFollowers::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountFollowers::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_followers(&mut self, followers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountFollowers::VT_FOLLOWERS, followers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountFollowersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountFollowersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountFollowers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountFollowingsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountFollowings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountFollowings<'a> {
    type Inner = FBTaskContentFetchAccountFollowings<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountFollowings<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountFollowings {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountFollowingsArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountFollowings<'bldr>> {
      let mut builder = FBTaskContentFetchAccountFollowingsBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.followings { builder.add_followings(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 6;
    pub const VT_FOLLOWINGS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountFollowings::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchAccountFollowings::VT_CURSOR, None)
  }
  #[inline]
  pub fn followings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBTaskContentFetchAccountFollowings::VT_FOLLOWINGS, None)
  }
}

pub struct FBTaskContentFetchAccountFollowingsArgs<'a> {
    pub accountID: u64,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub followings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountFollowingsArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountFollowingsArgs {
            accountID: 0,
            cursor: None,
            followings: None,
        }
    }
}
pub struct FBTaskContentFetchAccountFollowingsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountFollowingsBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountFollowings::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountFollowings::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_followings(&mut self, followings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountFollowings::VT_FOLLOWINGS, followings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountFollowingsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountFollowingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountFollowings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBBlockingInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBBlockingInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBBlockingInfo<'a> {
    type Inner = FBBlockingInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBBlockingInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBBlockingInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBBlockingInfoArgs<'args>) -> flatbuffers::WIPOffset<FBBlockingInfo<'bldr>> {
      let mut builder = FBBlockingInfoBuilder::new(_fbb);
      builder.add_blockTime(args.blockTime);
      if let Some(x) = args.account { builder.add_account(x); }
      builder.finish()
    }

    pub const VT_ACCOUNT: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCKTIME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn account(&self) -> Option<FBAccount<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBAccount<'a>>>(FBBlockingInfo::VT_ACCOUNT, None)
  }
  #[inline]
  pub fn blockTime(&self) -> u64 {
    self._tab.get::<u64>(FBBlockingInfo::VT_BLOCKTIME, Some(0)).unwrap()
  }
}

pub struct FBBlockingInfoArgs<'a> {
    pub account: Option<flatbuffers::WIPOffset<FBAccount<'a >>>,
    pub blockTime: u64,
}
impl<'a> Default for FBBlockingInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBBlockingInfoArgs {
            account: None,
            blockTime: 0,
        }
    }
}
pub struct FBBlockingInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBBlockingInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_account(&mut self, account: flatbuffers::WIPOffset<FBAccount<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBAccount>>(FBBlockingInfo::VT_ACCOUNT, account);
  }
  #[inline]
  pub fn add_blockTime(&mut self, blockTime: u64) {
    self.fbb_.push_slot::<u64>(FBBlockingInfo::VT_BLOCKTIME, blockTime, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBBlockingInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBBlockingInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBBlockingInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountBlockingsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountBlockings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountBlockings<'a> {
    type Inner = FBTaskContentFetchAccountBlockings<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountBlockings<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountBlockings {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountBlockingsArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountBlockings<'bldr>> {
      let mut builder = FBTaskContentFetchAccountBlockingsBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.blockings { builder.add_blockings(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 6;
    pub const VT_BLOCKINGS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountBlockings::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchAccountBlockings::VT_CURSOR, None)
  }
  #[inline]
  pub fn blockings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBBlockingInfo<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBBlockingInfo<'a>>>>>(FBTaskContentFetchAccountBlockings::VT_BLOCKINGS, None)
  }
}

pub struct FBTaskContentFetchAccountBlockingsArgs<'a> {
    pub accountID: u64,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub blockings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBBlockingInfo<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountBlockingsArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountBlockingsArgs {
            accountID: 0,
            cursor: None,
            blockings: None,
        }
    }
}
pub struct FBTaskContentFetchAccountBlockingsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountBlockingsBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountBlockings::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountBlockings::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_blockings(&mut self, blockings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBBlockingInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountBlockings::VT_BLOCKINGS, blockings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountBlockingsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountBlockingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountBlockings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountLikedMediasOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountLikedMedias<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountLikedMedias<'a> {
    type Inner = FBTaskContentFetchAccountLikedMedias<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountLikedMedias<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountLikedMedias {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountLikedMediasArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountLikedMedias<'bldr>> {
      let mut builder = FBTaskContentFetchAccountLikedMediasBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.medias { builder.add_medias(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIAS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountLikedMedias::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchAccountLikedMedias::VT_CURSOR, None)
  }
  #[inline]
  pub fn medias(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBMedia<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBMedia<'a>>>>>(FBTaskContentFetchAccountLikedMedias::VT_MEDIAS, None)
  }
}

pub struct FBTaskContentFetchAccountLikedMediasArgs<'a> {
    pub accountID: u64,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub medias: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBMedia<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountLikedMediasArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountLikedMediasArgs {
            accountID: 0,
            cursor: None,
            medias: None,
        }
    }
}
pub struct FBTaskContentFetchAccountLikedMediasBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountLikedMediasBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountLikedMedias::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountLikedMedias::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_medias(&mut self, medias: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBMedia<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountLikedMedias::VT_MEDIAS, medias);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountLikedMediasBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountLikedMediasBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountLikedMedias<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountRelationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountRelation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountRelation<'a> {
    type Inner = FBTaskContentFetchAccountRelation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountRelation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountRelation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountRelationArgs) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountRelation<'bldr>> {
      let mut builder = FBTaskContentFetchAccountRelationBuilder::new(_fbb);
      builder.add_targetAccountID(args.targetAccountID);
      builder.add_sourceAccountID(args.sourceAccountID);
      builder.add_relation(args.relation);
      builder.finish()
    }

    pub const VT_SOURCEACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_TARGETACCOUNTID: flatbuffers::VOffsetT = 6;
    pub const VT_RELATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn sourceAccountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountRelation::VT_SOURCEACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn targetAccountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountRelation::VT_TARGETACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn relation(&self) -> FBRelationship {
    self._tab.get::<FBRelationship>(FBTaskContentFetchAccountRelation::VT_RELATION, Some(FBRelationship::Null)).unwrap()
  }
}

pub struct FBTaskContentFetchAccountRelationArgs {
    pub sourceAccountID: u64,
    pub targetAccountID: u64,
    pub relation: FBRelationship,
}
impl<'a> Default for FBTaskContentFetchAccountRelationArgs {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountRelationArgs {
            sourceAccountID: 0,
            targetAccountID: 0,
            relation: FBRelationship::Null,
        }
    }
}
pub struct FBTaskContentFetchAccountRelationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountRelationBuilder<'a, 'b> {
  #[inline]
  pub fn add_sourceAccountID(&mut self, sourceAccountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountRelation::VT_SOURCEACCOUNTID, sourceAccountID, 0);
  }
  #[inline]
  pub fn add_targetAccountID(&mut self, targetAccountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountRelation::VT_TARGETACCOUNTID, targetAccountID, 0);
  }
  #[inline]
  pub fn add_relation(&mut self, relation: FBRelationship) {
    self.fbb_.push_slot::<FBRelationship>(FBTaskContentFetchAccountRelation::VT_RELATION, relation, FBRelationship::Null);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountRelationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountRelationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountRelation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBActivityOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBActivity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBActivity<'a> {
    type Inner = FBActivity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBActivity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBActivity {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBActivityArgs<'args>) -> flatbuffers::WIPOffset<FBActivity<'bldr>> {
      let mut builder = FBActivityBuilder::new(_fbb);
      builder.add_timestamp(args.timestamp);
      if let Some(x) = args.media { builder.add_media(x); }
      if let Some(x) = args.targetAccount { builder.add_targetAccount(x); }
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_TARGETACCOUNT: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIA: flatbuffers::VOffsetT = 8;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn type_(&self) -> FBActivityType {
    self._tab.get::<FBActivityType>(FBActivity::VT_TYPE_, Some(FBActivityType::Null)).unwrap()
  }
  #[inline]
  pub fn targetAccount(&self) -> Option<FBAccount<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBAccount<'a>>>(FBActivity::VT_TARGETACCOUNT, None)
  }
  #[inline]
  pub fn media(&self) -> Option<FBMedia<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBMedia<'a>>>(FBActivity::VT_MEDIA, None)
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(FBActivity::VT_TIMESTAMP, Some(0)).unwrap()
  }
}

pub struct FBActivityArgs<'a> {
    pub type_: FBActivityType,
    pub targetAccount: Option<flatbuffers::WIPOffset<FBAccount<'a >>>,
    pub media: Option<flatbuffers::WIPOffset<FBMedia<'a >>>,
    pub timestamp: u64,
}
impl<'a> Default for FBActivityArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBActivityArgs {
            type_: FBActivityType::Null,
            targetAccount: None,
            media: None,
            timestamp: 0,
        }
    }
}
pub struct FBActivityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBActivityBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: FBActivityType) {
    self.fbb_.push_slot::<FBActivityType>(FBActivity::VT_TYPE_, type_, FBActivityType::Null);
  }
  #[inline]
  pub fn add_targetAccount(&mut self, targetAccount: flatbuffers::WIPOffset<FBAccount<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBAccount>>(FBActivity::VT_TARGETACCOUNT, targetAccount);
  }
  #[inline]
  pub fn add_media(&mut self, media: flatbuffers::WIPOffset<FBMedia<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBMedia>>(FBActivity::VT_MEDIA, media);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(FBActivity::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBActivityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBActivityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBActivity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountActivitiesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountActivities<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountActivities<'a> {
    type Inner = FBTaskContentFetchAccountActivities<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountActivities<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountActivities {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountActivitiesArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountActivities<'bldr>> {
      let mut builder = FBTaskContentFetchAccountActivitiesBuilder::new(_fbb);
      builder.add_startTimestamp(args.startTimestamp);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.activities { builder.add_activities(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIMESTAMP: flatbuffers::VOffsetT = 6;
    pub const VT_ACTIVITIES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountActivities::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn startTimestamp(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountActivities::VT_STARTTIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn activities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBActivity<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBActivity<'a>>>>>(FBTaskContentFetchAccountActivities::VT_ACTIVITIES, None)
  }
}

pub struct FBTaskContentFetchAccountActivitiesArgs<'a> {
    pub accountID: u64,
    pub startTimestamp: u64,
    pub activities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBActivity<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountActivitiesArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountActivitiesArgs {
            accountID: 0,
            startTimestamp: 0,
            activities: None,
        }
    }
}
pub struct FBTaskContentFetchAccountActivitiesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountActivitiesBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountActivities::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_startTimestamp(&mut self, startTimestamp: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountActivities::VT_STARTTIMESTAMP, startTimestamp, 0);
  }
  #[inline]
  pub fn add_activities(&mut self, activities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBActivity<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountActivities::VT_ACTIVITIES, activities);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountActivitiesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountActivitiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountActivities<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBStoryElementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBStoryElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBStoryElement<'a> {
    type Inner = FBStoryElement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBStoryElement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBStoryElement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBStoryElementArgs<'args>) -> flatbuffers::WIPOffset<FBStoryElement<'bldr>> {
      let mut builder = FBStoryElementBuilder::new(_fbb);
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      if let Some(x) = args.viewers { builder.add_viewers(x); }
      if let Some(x) = args.story { builder.add_story(x); }
      builder.finish()
    }

    pub const VT_STORY: flatbuffers::VOffsetT = 4;
    pub const VT_VIEWERS: flatbuffers::VOffsetT = 6;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn story(&self) -> Option<FBMedia<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBMedia<'a>>>(FBStoryElement::VT_STORY, None)
  }
  #[inline]
  pub fn viewers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBStoryElement::VT_VIEWERS, None)
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBStoryElement::VT_CURSOR, None)
  }
}

pub struct FBStoryElementArgs<'a> {
    pub story: Option<flatbuffers::WIPOffset<FBMedia<'a >>>,
    pub viewers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for FBStoryElementArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBStoryElementArgs {
            story: None,
            viewers: None,
            cursor: None,
        }
    }
}
pub struct FBStoryElementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBStoryElementBuilder<'a, 'b> {
  #[inline]
  pub fn add_story(&mut self, story: flatbuffers::WIPOffset<FBMedia<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBMedia>>(FBStoryElement::VT_STORY, story);
  }
  #[inline]
  pub fn add_viewers(&mut self, viewers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBStoryElement::VT_VIEWERS, viewers);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBStoryElement::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBStoryElementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBStoryElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBStoryElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchAccountStoriesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchAccountStories<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchAccountStories<'a> {
    type Inner = FBTaskContentFetchAccountStories<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchAccountStories<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchAccountStories {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchAccountStoriesArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountStories<'bldr>> {
      let mut builder = FBTaskContentFetchAccountStoriesBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.stories { builder.add_stories(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_STORIES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchAccountStories::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn stories(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBStoryElement<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBStoryElement<'a>>>>>(FBTaskContentFetchAccountStories::VT_STORIES, None)
  }
}

pub struct FBTaskContentFetchAccountStoriesArgs<'a> {
    pub accountID: u64,
    pub stories: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBStoryElement<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchAccountStoriesArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchAccountStoriesArgs {
            accountID: 0,
            stories: None,
        }
    }
}
pub struct FBTaskContentFetchAccountStoriesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchAccountStoriesBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchAccountStories::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_stories(&mut self, stories: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBStoryElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchAccountStories::VT_STORIES, stories);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchAccountStoriesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchAccountStoriesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchAccountStories<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchMediaInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchMediaInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchMediaInfo<'a> {
    type Inner = FBTaskContentFetchMediaInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchMediaInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchMediaInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchMediaInfoArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchMediaInfo<'bldr>> {
      let mut builder = FBTaskContentFetchMediaInfoBuilder::new(_fbb);
      if let Some(x) = args.media { builder.add_media(x); }
      builder.finish()
    }

    pub const VT_MEDIA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn media(&self) -> Option<FBMedia<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBMedia<'a>>>(FBTaskContentFetchMediaInfo::VT_MEDIA, None)
  }
}

pub struct FBTaskContentFetchMediaInfoArgs<'a> {
    pub media: Option<flatbuffers::WIPOffset<FBMedia<'a >>>,
}
impl<'a> Default for FBTaskContentFetchMediaInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchMediaInfoArgs {
            media: None,
        }
    }
}
pub struct FBTaskContentFetchMediaInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchMediaInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_media(&mut self, media: flatbuffers::WIPOffset<FBMedia<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBMedia>>(FBTaskContentFetchMediaInfo::VT_MEDIA, media);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchMediaInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchMediaInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchMediaInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchStoryViewersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchStoryViewers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchStoryViewers<'a> {
    type Inner = FBTaskContentFetchStoryViewers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchStoryViewers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchStoryViewers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchStoryViewersArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchStoryViewers<'bldr>> {
      let mut builder = FBTaskContentFetchStoryViewersBuilder::new(_fbb);
      builder.add_storyID(args.storyID);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.story { builder.add_story(x); }
      if let Some(x) = args.viewers { builder.add_viewers(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYID: flatbuffers::VOffsetT = 6;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 8;
    pub const VT_VIEWERS: flatbuffers::VOffsetT = 10;
    pub const VT_STORY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchStoryViewers::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn storyID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchStoryViewers::VT_STORYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchStoryViewers::VT_CURSOR, None)
  }
  #[inline]
  pub fn viewers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBTaskContentFetchStoryViewers::VT_VIEWERS, None)
  }
  #[inline]
  pub fn story(&self) -> Option<FBMedia<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBMedia<'a>>>(FBTaskContentFetchStoryViewers::VT_STORY, None)
  }
}

pub struct FBTaskContentFetchStoryViewersArgs<'a> {
    pub accountID: u64,
    pub storyID: u64,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub viewers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
    pub story: Option<flatbuffers::WIPOffset<FBMedia<'a >>>,
}
impl<'a> Default for FBTaskContentFetchStoryViewersArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchStoryViewersArgs {
            accountID: 0,
            storyID: 0,
            cursor: None,
            viewers: None,
            story: None,
        }
    }
}
pub struct FBTaskContentFetchStoryViewersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchStoryViewersBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchStoryViewers::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_storyID(&mut self, storyID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchStoryViewers::VT_STORYID, storyID, 0);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchStoryViewers::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_viewers(&mut self, viewers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchStoryViewers::VT_VIEWERS, viewers);
  }
  #[inline]
  pub fn add_story(&mut self, story: flatbuffers::WIPOffset<FBMedia<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBMedia>>(FBTaskContentFetchStoryViewers::VT_STORY, story);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchStoryViewersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchStoryViewersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchStoryViewers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskContentFetchUserTagsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTaskContentFetchUserTags<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTaskContentFetchUserTags<'a> {
    type Inner = FBTaskContentFetchUserTags<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTaskContentFetchUserTags<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTaskContentFetchUserTags {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskContentFetchUserTagsArgs<'args>) -> flatbuffers::WIPOffset<FBTaskContentFetchUserTags<'bldr>> {
      let mut builder = FBTaskContentFetchUserTagsBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      if let Some(x) = args.medias { builder.add_medias(x); }
      if let Some(x) = args.cursor { builder.add_cursor(x); }
      builder.add_pending(args.pending);
      builder.finish()
    }

    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_PENDING: flatbuffers::VOffsetT = 6;
    pub const VT_CURSOR: flatbuffers::VOffsetT = 8;
    pub const VT_MEDIAS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBTaskContentFetchUserTags::VT_ACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn pending(&self) -> bool {
    self._tab.get::<bool>(FBTaskContentFetchUserTags::VT_PENDING, Some(false)).unwrap()
  }
  #[inline]
  pub fn cursor(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTaskContentFetchUserTags::VT_CURSOR, None)
  }
  #[inline]
  pub fn medias(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBMedia<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBMedia<'a>>>>>(FBTaskContentFetchUserTags::VT_MEDIAS, None)
  }
}

pub struct FBTaskContentFetchUserTagsArgs<'a> {
    pub accountID: u64,
    pub pending: bool,
    pub cursor: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub medias: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBMedia<'a >>>>>,
}
impl<'a> Default for FBTaskContentFetchUserTagsArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTaskContentFetchUserTagsArgs {
            accountID: 0,
            pending: false,
            cursor: None,
            medias: None,
        }
    }
}
pub struct FBTaskContentFetchUserTagsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskContentFetchUserTagsBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBTaskContentFetchUserTags::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn add_pending(&mut self, pending: bool) {
    self.fbb_.push_slot::<bool>(FBTaskContentFetchUserTags::VT_PENDING, pending, false);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchUserTags::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn add_medias(&mut self, medias: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBMedia<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTaskContentFetchUserTags::VT_MEDIAS, medias);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskContentFetchUserTagsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskContentFetchUserTagsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTaskContentFetchUserTags<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTaskOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTask<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTask<'a> {
    type Inner = FBTask<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTask<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTask {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTaskArgs) -> flatbuffers::WIPOffset<FBTask<'bldr>> {
      let mut builder = FBTaskBuilder::new(_fbb);
      builder.add_executorAccountID(args.executorAccountID);
      builder.add_id(args.id);
      if let Some(x) = args.content { builder.add_content(x); }
      builder.add_content_type(args.content_type);
      builder.add_failureAction(args.failureAction);
      builder.add_state(args.state);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_STATE: flatbuffers::VOffsetT = 8;
    pub const VT_FAILUREACTION: flatbuffers::VOffsetT = 10;
    pub const VT_EXECUTORACCOUNTID: flatbuffers::VOffsetT = 12;
    pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(FBTask::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn type_(&self) -> FBTaskType {
    self._tab.get::<FBTaskType>(FBTask::VT_TYPE_, Some(FBTaskType::None)).unwrap()
  }
  #[inline]
  pub fn state(&self) -> FBTaskState {
    self._tab.get::<FBTaskState>(FBTask::VT_STATE, Some(FBTaskState::Pending)).unwrap()
  }
  #[inline]
  pub fn failureAction(&self) -> FBTaskFailureAction {
    self._tab.get::<FBTaskFailureAction>(FBTask::VT_FAILUREACTION, Some(FBTaskFailureAction::DispatchToOther)).unwrap()
  }
  #[inline]
  pub fn executorAccountID(&self) -> u64 {
    self._tab.get::<u64>(FBTask::VT_EXECUTORACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn content_type(&self) -> FBTaskContent {
    self._tab.get::<FBTaskContent>(FBTask::VT_CONTENT_TYPE, Some(FBTaskContent::NONE)).unwrap()
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FBTask::VT_CONTENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_info(&self) -> Option<FBTaskContentFetchAccountInfo<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountInfo {
      self.content().map(|u| FBTaskContentFetchAccountInfo::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_media_likers(&self) -> Option<FBTaskContentFetchMediaLikers<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchMediaLikers {
      self.content().map(|u| FBTaskContentFetchMediaLikers::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_media_comments(&self) -> Option<FBTaskContentFetchMediaComments<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchMediaComments {
      self.content().map(|u| FBTaskContentFetchMediaComments::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_followings(&self) -> Option<FBTaskContentFetchAccountFollowings<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountFollowings {
      self.content().map(|u| FBTaskContentFetchAccountFollowings::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_followers(&self) -> Option<FBTaskContentFetchAccountFollowers<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountFollowers {
      self.content().map(|u| FBTaskContentFetchAccountFollowers::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_medias(&self) -> Option<FBTaskContentFetchAccountMedias<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountMedias {
      self.content().map(|u| FBTaskContentFetchAccountMedias::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_liked_medias(&self) -> Option<FBTaskContentFetchAccountLikedMedias<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountLikedMedias {
      self.content().map(|u| FBTaskContentFetchAccountLikedMedias::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_blockings(&self) -> Option<FBTaskContentFetchAccountBlockings<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountBlockings {
      self.content().map(|u| FBTaskContentFetchAccountBlockings::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_relation(&self) -> Option<FBTaskContentFetchAccountRelation<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountRelation {
      self.content().map(|u| FBTaskContentFetchAccountRelation::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_activities(&self) -> Option<FBTaskContentFetchAccountActivities<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountActivities {
      self.content().map(|u| FBTaskContentFetchAccountActivities::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_account_stories(&self) -> Option<FBTaskContentFetchAccountStories<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchAccountStories {
      self.content().map(|u| FBTaskContentFetchAccountStories::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_media_info(&self) -> Option<FBTaskContentFetchMediaInfo<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchMediaInfo {
      self.content().map(|u| FBTaskContentFetchMediaInfo::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_story_viewers(&self) -> Option<FBTaskContentFetchStoryViewers<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchStoryViewers {
      self.content().map(|u| FBTaskContentFetchStoryViewers::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbtask_content_fetch_user_tags(&self) -> Option<FBTaskContentFetchUserTags<'a>> {
    if self.content_type() == FBTaskContent::FBTaskContentFetchUserTags {
      self.content().map(|u| FBTaskContentFetchUserTags::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct FBTaskArgs {
    pub id: u64,
    pub type_: FBTaskType,
    pub state: FBTaskState,
    pub failureAction: FBTaskFailureAction,
    pub executorAccountID: u64,
    pub content_type: FBTaskContent,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FBTaskArgs {
    #[inline]
    fn default() -> Self {
        FBTaskArgs {
            id: 0,
            type_: FBTaskType::None,
            state: FBTaskState::Pending,
            failureAction: FBTaskFailureAction::DispatchToOther,
            executorAccountID: 0,
            content_type: FBTaskContent::NONE,
            content: None,
        }
    }
}
pub struct FBTaskBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBTaskBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(FBTask::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: FBTaskType) {
    self.fbb_.push_slot::<FBTaskType>(FBTask::VT_TYPE_, type_, FBTaskType::None);
  }
  #[inline]
  pub fn add_state(&mut self, state: FBTaskState) {
    self.fbb_.push_slot::<FBTaskState>(FBTask::VT_STATE, state, FBTaskState::Pending);
  }
  #[inline]
  pub fn add_failureAction(&mut self, failureAction: FBTaskFailureAction) {
    self.fbb_.push_slot::<FBTaskFailureAction>(FBTask::VT_FAILUREACTION, failureAction, FBTaskFailureAction::DispatchToOther);
  }
  #[inline]
  pub fn add_executorAccountID(&mut self, executorAccountID: u64) {
    self.fbb_.push_slot::<u64>(FBTask::VT_EXECUTORACCOUNTID, executorAccountID, 0);
  }
  #[inline]
  pub fn add_content_type(&mut self, content_type: FBTaskContent) {
    self.fbb_.push_slot::<FBTaskContent>(FBTask::VT_CONTENT_TYPE, content_type, FBTaskContent::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTask::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTaskBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTaskBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTask<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBIdentityOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBIdentity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBIdentity<'a> {
    type Inner = FBIdentity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBIdentity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBIdentity {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBIdentityArgs) -> flatbuffers::WIPOffset<FBIdentity<'bldr>> {
      let mut builder = FBIdentityBuilder::new(_fbb);
      builder.add_accountID(args.accountID);
      builder.add_userSID(args.userSID);
      builder.add_appID(args.appID);
      builder.add_socialPlatformID(args.socialPlatformID);
      builder.finish()
    }

    pub const VT_SOCIALPLATFORMID: flatbuffers::VOffsetT = 4;
    pub const VT_APPID: flatbuffers::VOffsetT = 6;
    pub const VT_USERSID: flatbuffers::VOffsetT = 8;
    pub const VT_ACCOUNTID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn socialPlatformID(&self) -> FBSocialPlatformType {
    self._tab.get::<FBSocialPlatformType>(FBIdentity::VT_SOCIALPLATFORMID, Some(FBSocialPlatformType::Instagram)).unwrap()
  }
  #[inline]
  pub fn appID(&self) -> FBAppType {
    self._tab.get::<FBAppType>(FBIdentity::VT_APPID, Some(FBAppType::FollowersPlus)).unwrap()
  }
  #[inline]
  pub fn userSID(&self) -> i64 {
    self._tab.get::<i64>(FBIdentity::VT_USERSID, Some(0)).unwrap()
  }
  #[inline]
  pub fn accountID(&self) -> u64 {
    self._tab.get::<u64>(FBIdentity::VT_ACCOUNTID, Some(0)).unwrap()
  }
}

pub struct FBIdentityArgs {
    pub socialPlatformID: FBSocialPlatformType,
    pub appID: FBAppType,
    pub userSID: i64,
    pub accountID: u64,
}
impl<'a> Default for FBIdentityArgs {
    #[inline]
    fn default() -> Self {
        FBIdentityArgs {
            socialPlatformID: FBSocialPlatformType::Instagram,
            appID: FBAppType::FollowersPlus,
            userSID: 0,
            accountID: 0,
        }
    }
}
pub struct FBIdentityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBIdentityBuilder<'a, 'b> {
  #[inline]
  pub fn add_socialPlatformID(&mut self, socialPlatformID: FBSocialPlatformType) {
    self.fbb_.push_slot::<FBSocialPlatformType>(FBIdentity::VT_SOCIALPLATFORMID, socialPlatformID, FBSocialPlatformType::Instagram);
  }
  #[inline]
  pub fn add_appID(&mut self, appID: FBAppType) {
    self.fbb_.push_slot::<FBAppType>(FBIdentity::VT_APPID, appID, FBAppType::FollowersPlus);
  }
  #[inline]
  pub fn add_userSID(&mut self, userSID: i64) {
    self.fbb_.push_slot::<i64>(FBIdentity::VT_USERSID, userSID, 0);
  }
  #[inline]
  pub fn add_accountID(&mut self, accountID: u64) {
    self.fbb_.push_slot::<u64>(FBIdentity::VT_ACCOUNTID, accountID, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBIdentityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBIdentityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBIdentity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBAuthPBRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBAuthPBRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBAuthPBRequest<'a> {
    type Inner = FBAuthPBRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBAuthPBRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBAuthPBRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBAuthPBRequestArgs<'args>) -> flatbuffers::WIPOffset<FBAuthPBRequest<'bldr>> {
      let mut builder = FBAuthPBRequestBuilder::new(_fbb);
      if let Some(x) = args.accessToken { builder.add_accessToken(x); }
      if let Some(x) = args.identity { builder.add_identity(x); }
      builder.finish()
    }

    pub const VT_IDENTITY: flatbuffers::VOffsetT = 4;
    pub const VT_ACCESSTOKEN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn identity(&self) -> Option<FBIdentity<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBIdentity<'a>>>(FBAuthPBRequest::VT_IDENTITY, None)
  }
  #[inline]
  pub fn accessToken(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBAuthPBRequest::VT_ACCESSTOKEN, None)
  }
}

pub struct FBAuthPBRequestArgs<'a> {
    pub identity: Option<flatbuffers::WIPOffset<FBIdentity<'a >>>,
    pub accessToken: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for FBAuthPBRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBAuthPBRequestArgs {
            identity: None,
            accessToken: None,
        }
    }
}
pub struct FBAuthPBRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBAuthPBRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_identity(&mut self, identity: flatbuffers::WIPOffset<FBIdentity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBIdentity>>(FBAuthPBRequest::VT_IDENTITY, identity);
  }
  #[inline]
  pub fn add_accessToken(&mut self, accessToken: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBAuthPBRequest::VT_ACCESSTOKEN, accessToken);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBAuthPBRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBAuthPBRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBAuthPBRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBAuthPBReplyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBAuthPBReply<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBAuthPBReply<'a> {
    type Inner = FBAuthPBReply<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBAuthPBReply<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBAuthPBReply {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBAuthPBReplyArgs<'args>) -> flatbuffers::WIPOffset<FBAuthPBReply<'bldr>> {
      let mut builder = FBAuthPBReplyBuilder::new(_fbb);
      if let Some(x) = args.identity { builder.add_identity(x); }
      builder.add_result(args.result);
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;
    pub const VT_IDENTITY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn result(&self) -> FBAuthPBError {
    self._tab.get::<FBAuthPBError>(FBAuthPBReply::VT_RESULT, Some(FBAuthPBError::Success)).unwrap()
  }
  #[inline]
  pub fn identity(&self) -> Option<FBIdentity<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBIdentity<'a>>>(FBAuthPBReply::VT_IDENTITY, None)
  }
}

pub struct FBAuthPBReplyArgs<'a> {
    pub result: FBAuthPBError,
    pub identity: Option<flatbuffers::WIPOffset<FBIdentity<'a >>>,
}
impl<'a> Default for FBAuthPBReplyArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBAuthPBReplyArgs {
            result: FBAuthPBError::Success,
            identity: None,
        }
    }
}
pub struct FBAuthPBReplyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBAuthPBReplyBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: FBAuthPBError) {
    self.fbb_.push_slot::<FBAuthPBError>(FBAuthPBReply::VT_RESULT, result, FBAuthPBError::Success);
  }
  #[inline]
  pub fn add_identity(&mut self, identity: flatbuffers::WIPOffset<FBIdentity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBIdentity>>(FBAuthPBReply::VT_IDENTITY, identity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBAuthPBReplyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBAuthPBReplyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBAuthPBReply<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBFetchMetaDataRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBFetchMetaDataRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBFetchMetaDataRequest<'a> {
    type Inner = FBFetchMetaDataRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBFetchMetaDataRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBFetchMetaDataRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBFetchMetaDataRequestArgs<'args>) -> flatbuffers::WIPOffset<FBFetchMetaDataRequest<'bldr>> {
      let mut builder = FBFetchMetaDataRequestBuilder::new(_fbb);
      if let Some(x) = args.mediaIDs { builder.add_mediaIDs(x); }
      if let Some(x) = args.accountIDs { builder.add_accountIDs(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTIDS: flatbuffers::VOffsetT = 4;
    pub const VT_MEDIAIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn accountIDs(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(FBFetchMetaDataRequest::VT_ACCOUNTIDS, None)
  }
  #[inline]
  pub fn mediaIDs(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(FBFetchMetaDataRequest::VT_MEDIAIDS, None)
  }
}

pub struct FBFetchMetaDataRequestArgs<'a> {
    pub accountIDs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub mediaIDs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
}
impl<'a> Default for FBFetchMetaDataRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBFetchMetaDataRequestArgs {
            accountIDs: None,
            mediaIDs: None,
        }
    }
}
pub struct FBFetchMetaDataRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBFetchMetaDataRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_accountIDs(&mut self, accountIDs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBFetchMetaDataRequest::VT_ACCOUNTIDS, accountIDs);
  }
  #[inline]
  pub fn add_mediaIDs(&mut self, mediaIDs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBFetchMetaDataRequest::VT_MEDIAIDS, mediaIDs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBFetchMetaDataRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBFetchMetaDataRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBFetchMetaDataRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBFetchMetaDataReplyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBFetchMetaDataReply<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBFetchMetaDataReply<'a> {
    type Inner = FBFetchMetaDataReply<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBFetchMetaDataReply<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBFetchMetaDataReply {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBFetchMetaDataReplyArgs<'args>) -> flatbuffers::WIPOffset<FBFetchMetaDataReply<'bldr>> {
      let mut builder = FBFetchMetaDataReplyBuilder::new(_fbb);
      if let Some(x) = args.medias { builder.add_medias(x); }
      if let Some(x) = args.accounts { builder.add_accounts(x); }
      builder.finish()
    }

    pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 4;
    pub const VT_MEDIAS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn accounts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBAccount<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBAccount<'a>>>>>(FBFetchMetaDataReply::VT_ACCOUNTS, None)
  }
  #[inline]
  pub fn medias(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBMedia<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FBMedia<'a>>>>>(FBFetchMetaDataReply::VT_MEDIAS, None)
  }
}

pub struct FBFetchMetaDataReplyArgs<'a> {
    pub accounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBAccount<'a >>>>>,
    pub medias: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBMedia<'a >>>>>,
}
impl<'a> Default for FBFetchMetaDataReplyArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBFetchMetaDataReplyArgs {
            accounts: None,
            medias: None,
        }
    }
}
pub struct FBFetchMetaDataReplyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBFetchMetaDataReplyBuilder<'a, 'b> {
  #[inline]
  pub fn add_accounts(&mut self, accounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBAccount<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBFetchMetaDataReply::VT_ACCOUNTS, accounts);
  }
  #[inline]
  pub fn add_medias(&mut self, medias: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBMedia<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBFetchMetaDataReply::VT_MEDIAS, medias);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBFetchMetaDataReplyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBFetchMetaDataReplyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBFetchMetaDataReply<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBFetchAccountRelationshipsRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBFetchAccountRelationshipsRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBFetchAccountRelationshipsRequest<'a> {
    type Inner = FBFetchAccountRelationshipsRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBFetchAccountRelationshipsRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBFetchAccountRelationshipsRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBFetchAccountRelationshipsRequestArgs<'args>) -> flatbuffers::WIPOffset<FBFetchAccountRelationshipsRequest<'bldr>> {
      let mut builder = FBFetchAccountRelationshipsRequestBuilder::new(_fbb);
      builder.add_sourceAccountID(args.sourceAccountID);
      if let Some(x) = args.targetAccountIDs { builder.add_targetAccountIDs(x); }
      builder.finish()
    }

    pub const VT_SOURCEACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_TARGETACCOUNTIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn sourceAccountID(&self) -> u64 {
    self._tab.get::<u64>(FBFetchAccountRelationshipsRequest::VT_SOURCEACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn targetAccountIDs(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(FBFetchAccountRelationshipsRequest::VT_TARGETACCOUNTIDS, None)
  }
}

pub struct FBFetchAccountRelationshipsRequestArgs<'a> {
    pub sourceAccountID: u64,
    pub targetAccountIDs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
}
impl<'a> Default for FBFetchAccountRelationshipsRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBFetchAccountRelationshipsRequestArgs {
            sourceAccountID: 0,
            targetAccountIDs: None,
        }
    }
}
pub struct FBFetchAccountRelationshipsRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBFetchAccountRelationshipsRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_sourceAccountID(&mut self, sourceAccountID: u64) {
    self.fbb_.push_slot::<u64>(FBFetchAccountRelationshipsRequest::VT_SOURCEACCOUNTID, sourceAccountID, 0);
  }
  #[inline]
  pub fn add_targetAccountIDs(&mut self, targetAccountIDs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBFetchAccountRelationshipsRequest::VT_TARGETACCOUNTIDS, targetAccountIDs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBFetchAccountRelationshipsRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBFetchAccountRelationshipsRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBFetchAccountRelationshipsRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBFetchAccountRelationshipsReplyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBFetchAccountRelationshipsReply<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBFetchAccountRelationshipsReply<'a> {
    type Inner = FBFetchAccountRelationshipsReply<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBFetchAccountRelationshipsReply<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBFetchAccountRelationshipsReply {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBFetchAccountRelationshipsReplyArgs<'args>) -> flatbuffers::WIPOffset<FBFetchAccountRelationshipsReply<'bldr>> {
      let mut builder = FBFetchAccountRelationshipsReplyBuilder::new(_fbb);
      builder.add_sourceAccountID(args.sourceAccountID);
      if let Some(x) = args.targetRelationships { builder.add_targetRelationships(x); }
      builder.finish()
    }

    pub const VT_SOURCEACCOUNTID: flatbuffers::VOffsetT = 4;
    pub const VT_TARGETRELATIONSHIPS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn sourceAccountID(&self) -> u64 {
    self._tab.get::<u64>(FBFetchAccountRelationshipsReply::VT_SOURCEACCOUNTID, Some(0)).unwrap()
  }
  #[inline]
  pub fn targetRelationships(&self) -> Option<&'a [FBAccountRelationshipData]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<FBAccountRelationshipData>>>(FBFetchAccountRelationshipsReply::VT_TARGETRELATIONSHIPS, None).map(|v| v.safe_slice() )
  }
}

pub struct FBFetchAccountRelationshipsReplyArgs<'a> {
    pub sourceAccountID: u64,
    pub targetRelationships: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , FBAccountRelationshipData>>>,
}
impl<'a> Default for FBFetchAccountRelationshipsReplyArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBFetchAccountRelationshipsReplyArgs {
            sourceAccountID: 0,
            targetRelationships: None,
        }
    }
}
pub struct FBFetchAccountRelationshipsReplyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBFetchAccountRelationshipsReplyBuilder<'a, 'b> {
  #[inline]
  pub fn add_sourceAccountID(&mut self, sourceAccountID: u64) {
    self.fbb_.push_slot::<u64>(FBFetchAccountRelationshipsReply::VT_SOURCEACCOUNTID, sourceAccountID, 0);
  }
  #[inline]
  pub fn add_targetRelationships(&mut self, targetRelationships: flatbuffers::WIPOffset<flatbuffers::Vector<'b , FBAccountRelationshipData>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBFetchAccountRelationshipsReply::VT_TARGETRELATIONSHIPS, targetRelationships);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBFetchAccountRelationshipsReplyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBFetchAccountRelationshipsReplyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBFetchAccountRelationshipsReply<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBInternalMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBInternalMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBInternalMessage<'a> {
    type Inner = FBInternalMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBInternalMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBInternalMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBInternalMessageArgs) -> flatbuffers::WIPOffset<FBInternalMessage<'bldr>> {
      let mut builder = FBInternalMessageBuilder::new(_fbb);
      builder.add_id(args.id);
      if let Some(x) = args.content { builder.add_content(x); }
      builder.add_content_type(args.content_type);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(FBInternalMessage::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn type_(&self) -> FBInternalMessageType {
    self._tab.get::<FBInternalMessageType>(FBInternalMessage::VT_TYPE_, Some(FBInternalMessageType::None)).unwrap()
  }
  #[inline]
  pub fn content_type(&self) -> FBInternalMessageContent {
    self._tab.get::<FBInternalMessageContent>(FBInternalMessage::VT_CONTENT_TYPE, Some(FBInternalMessageContent::NONE)).unwrap()
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FBInternalMessage::VT_CONTENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbauth_pbrequest(&self) -> Option<FBAuthPBRequest<'a>> {
    if self.content_type() == FBInternalMessageContent::FBAuthPBRequest {
      self.content().map(|u| FBAuthPBRequest::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbauth_pbreply(&self) -> Option<FBAuthPBReply<'a>> {
    if self.content_type() == FBInternalMessageContent::FBAuthPBReply {
      self.content().map(|u| FBAuthPBReply::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbfetch_meta_data_request(&self) -> Option<FBFetchMetaDataRequest<'a>> {
    if self.content_type() == FBInternalMessageContent::FBFetchMetaDataRequest {
      self.content().map(|u| FBFetchMetaDataRequest::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbfetch_meta_data_reply(&self) -> Option<FBFetchMetaDataReply<'a>> {
    if self.content_type() == FBInternalMessageContent::FBFetchMetaDataReply {
      self.content().map(|u| FBFetchMetaDataReply::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbfetch_account_relationships_request(&self) -> Option<FBFetchAccountRelationshipsRequest<'a>> {
    if self.content_type() == FBInternalMessageContent::FBFetchAccountRelationshipsRequest {
      self.content().map(|u| FBFetchAccountRelationshipsRequest::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_fbfetch_account_relationships_reply(&self) -> Option<FBFetchAccountRelationshipsReply<'a>> {
    if self.content_type() == FBInternalMessageContent::FBFetchAccountRelationshipsReply {
      self.content().map(|u| FBFetchAccountRelationshipsReply::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct FBInternalMessageArgs {
    pub id: u64,
    pub type_: FBInternalMessageType,
    pub content_type: FBInternalMessageContent,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FBInternalMessageArgs {
    #[inline]
    fn default() -> Self {
        FBInternalMessageArgs {
            id: 0,
            type_: FBInternalMessageType::None,
            content_type: FBInternalMessageContent::NONE,
            content: None,
        }
    }
}
pub struct FBInternalMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FBInternalMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(FBInternalMessage::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: FBInternalMessageType) {
    self.fbb_.push_slot::<FBInternalMessageType>(FBInternalMessage::VT_TYPE_, type_, FBInternalMessageType::None);
  }
  #[inline]
  pub fn add_content_type(&mut self, content_type: FBInternalMessageContent) {
    self.fbb_.push_slot::<FBInternalMessageContent>(FBInternalMessage::VT_CONTENT_TYPE, content_type, FBInternalMessageContent::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInternalMessage::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBInternalMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBInternalMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBInternalMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_fbtask<'a>(buf: &'a [u8]) -> FBTask<'a> {
  flatbuffers::get_root::<FBTask<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_fbtask<'a>(buf: &'a [u8]) -> FBTask<'a> {
  flatbuffers::get_size_prefixed_root::<FBTask<'a>>(buf)
}

#[inline]
pub fn finish_fbtask_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<FBTask<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_fbtask_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<FBTask<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fp

