// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `followersPlus.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq,Clone,Default)]
pub struct PBMessageID {
    // message fields
    pub apiType: PBAPIType,
    pub index: i64,
    pub dialogUUID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBMessageID {
    fn default() -> &'a PBMessageID {
        <PBMessageID as ::protobuf::Message>::default_instance()
    }
}

impl PBMessageID {
    pub fn new() -> PBMessageID {
        ::std::default::Default::default()
    }

    // .PBAPIType apiType = 1;


    pub fn get_apiType(&self) -> PBAPIType {
        self.apiType
    }
    pub fn clear_apiType(&mut self) {
        self.apiType = PBAPIType::PostNotification;
    }

    // Param is passed by value, moved
    pub fn set_apiType(&mut self, v: PBAPIType) {
        self.apiType = v;
    }

    // int64 index = 2;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }

    // string dialogUUID = 3;


    pub fn get_dialogUUID(&self) -> &str {
        &self.dialogUUID
    }
    pub fn clear_dialogUUID(&mut self) {
        self.dialogUUID.clear();
    }

    // Param is passed by value, moved
    pub fn set_dialogUUID(&mut self, v: ::std::string::String) {
        self.dialogUUID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dialogUUID(&mut self) -> &mut ::std::string::String {
        &mut self.dialogUUID
    }

    // Take field
    pub fn take_dialogUUID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dialogUUID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBMessageID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.apiType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dialogUUID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.apiType != PBAPIType::PostNotification {
            my_size += ::protobuf::rt::enum_size(1, self.apiType);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.dialogUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dialogUUID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.apiType != PBAPIType::PostNotification {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.apiType))?;
        }
        if self.index != 0 {
            os.write_int64(2, self.index)?;
        }
        if !self.dialogUUID.is_empty() {
            os.write_string(3, &self.dialogUUID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBMessageID {
        PBMessageID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAPIType>>(
                "apiType",
                |m: &PBMessageID| { &m.apiType },
                |m: &mut PBMessageID| { &mut m.apiType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &PBMessageID| { &m.index },
                |m: &mut PBMessageID| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dialogUUID",
                |m: &PBMessageID| { &m.dialogUUID },
                |m: &mut PBMessageID| { &mut m.dialogUUID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBMessageID>(
                "PBMessageID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBMessageID {
        static instance: ::protobuf::rt::LazyV2<PBMessageID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBMessageID::new)
    }
}

impl ::protobuf::Clear for PBMessageID {
    fn clear(&mut self) {
        self.apiType = PBAPIType::PostNotification;
        self.index = 0;
        self.dialogUUID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBMessageID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMessageID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBIdentity {
    // message fields
    pub socialPlatformID: PBSocialPlatformType,
    pub appID: PBAppType,
    pub userSID: i64,
    pub accountID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBIdentity {
    fn default() -> &'a PBIdentity {
        <PBIdentity as ::protobuf::Message>::default_instance()
    }
}

impl PBIdentity {
    pub fn new() -> PBIdentity {
        ::std::default::Default::default()
    }

    // .PBSocialPlatformType socialPlatformID = 1;


    pub fn get_socialPlatformID(&self) -> PBSocialPlatformType {
        self.socialPlatformID
    }
    pub fn clear_socialPlatformID(&mut self) {
        self.socialPlatformID = PBSocialPlatformType::Instagram;
    }

    // Param is passed by value, moved
    pub fn set_socialPlatformID(&mut self, v: PBSocialPlatformType) {
        self.socialPlatformID = v;
    }

    // .PBAppType appID = 2;


    pub fn get_appID(&self) -> PBAppType {
        self.appID
    }
    pub fn clear_appID(&mut self) {
        self.appID = PBAppType::SanTi;
    }

    // Param is passed by value, moved
    pub fn set_appID(&mut self, v: PBAppType) {
        self.appID = v;
    }

    // int64 userSID = 3;


    pub fn get_userSID(&self) -> i64 {
        self.userSID
    }
    pub fn clear_userSID(&mut self) {
        self.userSID = 0;
    }

    // Param is passed by value, moved
    pub fn set_userSID(&mut self, v: i64) {
        self.userSID = v;
    }

    // string accountID = 4;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBIdentity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.socialPlatformID, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.appID, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.userSID = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.socialPlatformID != PBSocialPlatformType::Instagram {
            my_size += ::protobuf::rt::enum_size(1, self.socialPlatformID);
        }
        if self.appID != PBAppType::SanTi {
            my_size += ::protobuf::rt::enum_size(2, self.appID);
        }
        if self.userSID != 0 {
            my_size += ::protobuf::rt::value_size(3, self.userSID, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.accountID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.socialPlatformID != PBSocialPlatformType::Instagram {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.socialPlatformID))?;
        }
        if self.appID != PBAppType::SanTi {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.appID))?;
        }
        if self.userSID != 0 {
            os.write_int64(3, self.userSID)?;
        }
        if !self.accountID.is_empty() {
            os.write_string(4, &self.accountID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBIdentity {
        PBIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBSocialPlatformType>>(
                "socialPlatformID",
                |m: &PBIdentity| { &m.socialPlatformID },
                |m: &mut PBIdentity| { &mut m.socialPlatformID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAppType>>(
                "appID",
                |m: &PBIdentity| { &m.appID },
                |m: &mut PBIdentity| { &mut m.appID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "userSID",
                |m: &PBIdentity| { &m.userSID },
                |m: &mut PBIdentity| { &mut m.userSID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBIdentity| { &m.accountID },
                |m: &mut PBIdentity| { &mut m.accountID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBIdentity>(
                "PBIdentity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBIdentity {
        static instance: ::protobuf::rt::LazyV2<PBIdentity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBIdentity::new)
    }
}

impl ::protobuf::Clear for PBIdentity {
    fn clear(&mut self) {
        self.socialPlatformID = PBSocialPlatformType::Instagram;
        self.appID = PBAppType::SanTi;
        self.userSID = 0;
        self.accountID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBMessage {
    // message fields
    pub messageID: ::protobuf::SingularPtrField<PBMessageID>,
    pub accessToken: ::std::string::String,
    pub errorCode: PBErrorCode,
    pub payload: ::std::vec::Vec<u8>,
    pub identity: ::protobuf::SingularPtrField<PBIdentity>,
    pub errorMessage: ::std::string::String,
    pub toBeContinued: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBMessage {
    fn default() -> &'a PBMessage {
        <PBMessage as ::protobuf::Message>::default_instance()
    }
}

impl PBMessage {
    pub fn new() -> PBMessage {
        ::std::default::Default::default()
    }

    // .PBMessageID messageID = 1;


    pub fn get_messageID(&self) -> &PBMessageID {
        self.messageID.as_ref().unwrap_or_else(|| <PBMessageID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageID(&mut self) {
        self.messageID.clear();
    }

    pub fn has_messageID(&self) -> bool {
        self.messageID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageID(&mut self, v: PBMessageID) {
        self.messageID = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageID(&mut self) -> &mut PBMessageID {
        if self.messageID.is_none() {
            self.messageID.set_default();
        }
        self.messageID.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageID(&mut self) -> PBMessageID {
        self.messageID.take().unwrap_or_else(|| PBMessageID::new())
    }

    // string accessToken = 2;


    pub fn get_accessToken(&self) -> &str {
        &self.accessToken
    }
    pub fn clear_accessToken(&mut self) {
        self.accessToken.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessToken(&mut self, v: ::std::string::String) {
        self.accessToken = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessToken(&mut self) -> &mut ::std::string::String {
        &mut self.accessToken
    }

    // Take field
    pub fn take_accessToken(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accessToken, ::std::string::String::new())
    }

    // .PBErrorCode errorCode = 3;


    pub fn get_errorCode(&self) -> PBErrorCode {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = PBErrorCode::Success;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: PBErrorCode) {
        self.errorCode = v;
    }

    // bytes payload = 4;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .PBIdentity identity = 5;


    pub fn get_identity(&self) -> &PBIdentity {
        self.identity.as_ref().unwrap_or_else(|| <PBIdentity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    pub fn has_identity(&self) -> bool {
        self.identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: PBIdentity) {
        self.identity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut PBIdentity {
        if self.identity.is_none() {
            self.identity.set_default();
        }
        self.identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity(&mut self) -> PBIdentity {
        self.identity.take().unwrap_or_else(|| PBIdentity::new())
    }

    // string errorMessage = 6;


    pub fn get_errorMessage(&self) -> &str {
        &self.errorMessage
    }
    pub fn clear_errorMessage(&mut self) {
        self.errorMessage.clear();
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage(&mut self) -> &mut ::std::string::String {
        &mut self.errorMessage
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errorMessage, ::std::string::String::new())
    }

    // bool toBeContinued = 7;


    pub fn get_toBeContinued(&self) -> bool {
        self.toBeContinued
    }
    pub fn clear_toBeContinued(&mut self) {
        self.toBeContinued = false;
    }

    // Param is passed by value, moved
    pub fn set_toBeContinued(&mut self, v: bool) {
        self.toBeContinued = v;
    }
}

impl ::protobuf::Message for PBMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.messageID {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.identity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accessToken)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.errorCode, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identity)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.toBeContinued = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.messageID.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.accessToken.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.accessToken);
        }
        if self.errorCode != PBErrorCode::Success {
            my_size += ::protobuf::rt::enum_size(3, self.errorCode);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payload);
        }
        if let Some(ref v) = self.identity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.errorMessage.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.errorMessage);
        }
        if self.toBeContinued != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.messageID.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.accessToken.is_empty() {
            os.write_string(2, &self.accessToken)?;
        }
        if self.errorCode != PBErrorCode::Success {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.errorCode))?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(4, &self.payload)?;
        }
        if let Some(ref v) = self.identity.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.errorMessage.is_empty() {
            os.write_string(6, &self.errorMessage)?;
        }
        if self.toBeContinued != false {
            os.write_bool(7, self.toBeContinued)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBMessage {
        PBMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMessageID>>(
                "messageID",
                |m: &PBMessage| { &m.messageID },
                |m: &mut PBMessage| { &mut m.messageID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accessToken",
                |m: &PBMessage| { &m.accessToken },
                |m: &mut PBMessage| { &mut m.accessToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBErrorCode>>(
                "errorCode",
                |m: &PBMessage| { &m.errorCode },
                |m: &mut PBMessage| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &PBMessage| { &m.payload },
                |m: &mut PBMessage| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBIdentity>>(
                "identity",
                |m: &PBMessage| { &m.identity },
                |m: &mut PBMessage| { &mut m.identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMessage",
                |m: &PBMessage| { &m.errorMessage },
                |m: &mut PBMessage| { &mut m.errorMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "toBeContinued",
                |m: &PBMessage| { &m.toBeContinued },
                |m: &mut PBMessage| { &mut m.toBeContinued },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBMessage>(
                "PBMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBMessage {
        static instance: ::protobuf::rt::LazyV2<PBMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBMessage::new)
    }
}

impl ::protobuf::Clear for PBMessage {
    fn clear(&mut self) {
        self.messageID.clear();
        self.accessToken.clear();
        self.errorCode = PBErrorCode::Success;
        self.payload.clear();
        self.identity.clear();
        self.errorMessage.clear();
        self.toBeContinued = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBNotification {
    // message fields
    pub notificationAPI: PBAPIType,
    pub objectData: ::std::vec::Vec<u8>,
    pub broadcast: bool,
    pub mustDelivered: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBNotification {
    fn default() -> &'a PBNotification {
        <PBNotification as ::protobuf::Message>::default_instance()
    }
}

impl PBNotification {
    pub fn new() -> PBNotification {
        ::std::default::Default::default()
    }

    // .PBAPIType notificationAPI = 1;


    pub fn get_notificationAPI(&self) -> PBAPIType {
        self.notificationAPI
    }
    pub fn clear_notificationAPI(&mut self) {
        self.notificationAPI = PBAPIType::PostNotification;
    }

    // Param is passed by value, moved
    pub fn set_notificationAPI(&mut self, v: PBAPIType) {
        self.notificationAPI = v;
    }

    // bytes objectData = 2;


    pub fn get_objectData(&self) -> &[u8] {
        &self.objectData
    }
    pub fn clear_objectData(&mut self) {
        self.objectData.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectData(&mut self, v: ::std::vec::Vec<u8>) {
        self.objectData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.objectData
    }

    // Take field
    pub fn take_objectData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.objectData, ::std::vec::Vec::new())
    }

    // bool broadcast = 3;


    pub fn get_broadcast(&self) -> bool {
        self.broadcast
    }
    pub fn clear_broadcast(&mut self) {
        self.broadcast = false;
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = v;
    }

    // bool mustDelivered = 4;


    pub fn get_mustDelivered(&self) -> bool {
        self.mustDelivered
    }
    pub fn clear_mustDelivered(&mut self) {
        self.mustDelivered = false;
    }

    // Param is passed by value, moved
    pub fn set_mustDelivered(&mut self, v: bool) {
        self.mustDelivered = v;
    }
}

impl ::protobuf::Message for PBNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.notificationAPI, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.objectData)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.broadcast = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mustDelivered = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.notificationAPI != PBAPIType::PostNotification {
            my_size += ::protobuf::rt::enum_size(1, self.notificationAPI);
        }
        if !self.objectData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.objectData);
        }
        if self.broadcast != false {
            my_size += 2;
        }
        if self.mustDelivered != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.notificationAPI != PBAPIType::PostNotification {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.notificationAPI))?;
        }
        if !self.objectData.is_empty() {
            os.write_bytes(2, &self.objectData)?;
        }
        if self.broadcast != false {
            os.write_bool(3, self.broadcast)?;
        }
        if self.mustDelivered != false {
            os.write_bool(4, self.mustDelivered)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBNotification {
        PBNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAPIType>>(
                "notificationAPI",
                |m: &PBNotification| { &m.notificationAPI },
                |m: &mut PBNotification| { &mut m.notificationAPI },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "objectData",
                |m: &PBNotification| { &m.objectData },
                |m: &mut PBNotification| { &mut m.objectData },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "broadcast",
                |m: &PBNotification| { &m.broadcast },
                |m: &mut PBNotification| { &mut m.broadcast },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mustDelivered",
                |m: &PBNotification| { &m.mustDelivered },
                |m: &mut PBNotification| { &mut m.mustDelivered },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBNotification>(
                "PBNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBNotification {
        static instance: ::protobuf::rt::LazyV2<PBNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBNotification::new)
    }
}

impl ::protobuf::Clear for PBNotification {
    fn clear(&mut self) {
        self.notificationAPI = PBAPIType::PostNotification;
        self.objectData.clear();
        self.broadcast = false;
        self.mustDelivered = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchConfigRequest {
    // message fields
    pub appVersion: ::std::string::String,
    pub appBundleID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchConfigRequest {
    fn default() -> &'a PBFetchConfigRequest {
        <PBFetchConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchConfigRequest {
    pub fn new() -> PBFetchConfigRequest {
        ::std::default::Default::default()
    }

    // string appVersion = 1;


    pub fn get_appVersion(&self) -> &str {
        &self.appVersion
    }
    pub fn clear_appVersion(&mut self) {
        self.appVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_appVersion(&mut self, v: ::std::string::String) {
        self.appVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appVersion(&mut self) -> &mut ::std::string::String {
        &mut self.appVersion
    }

    // Take field
    pub fn take_appVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appVersion, ::std::string::String::new())
    }

    // string appBundleID = 2;


    pub fn get_appBundleID(&self) -> &str {
        &self.appBundleID
    }
    pub fn clear_appBundleID(&mut self) {
        self.appBundleID.clear();
    }

    // Param is passed by value, moved
    pub fn set_appBundleID(&mut self, v: ::std::string::String) {
        self.appBundleID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appBundleID(&mut self) -> &mut ::std::string::String {
        &mut self.appBundleID
    }

    // Take field
    pub fn take_appBundleID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appBundleID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBFetchConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appBundleID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appVersion);
        }
        if !self.appBundleID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.appBundleID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appVersion.is_empty() {
            os.write_string(1, &self.appVersion)?;
        }
        if !self.appBundleID.is_empty() {
            os.write_string(2, &self.appBundleID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchConfigRequest {
        PBFetchConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appVersion",
                |m: &PBFetchConfigRequest| { &m.appVersion },
                |m: &mut PBFetchConfigRequest| { &mut m.appVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appBundleID",
                |m: &PBFetchConfigRequest| { &m.appBundleID },
                |m: &mut PBFetchConfigRequest| { &mut m.appBundleID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchConfigRequest>(
                "PBFetchConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchConfigRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchConfigRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchConfigRequest {
    fn clear(&mut self) {
        self.appVersion.clear();
        self.appBundleID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureConfig {
    // message fields
    pub field_type: PBAccountListDataType,
    pub isActive: bool,
    pub isVIPOnly: bool,
    pub unlockableByWatchAd: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureConfig {
    fn default() -> &'a FeatureConfig {
        <FeatureConfig as ::protobuf::Message>::default_instance()
    }
}

impl FeatureConfig {
    pub fn new() -> FeatureConfig {
        ::std::default::Default::default()
    }

    // .PBAccountListDataType type = 1;


    pub fn get_field_type(&self) -> PBAccountListDataType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBAccountListDataType::PBAccountListDataType_None;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBAccountListDataType) {
        self.field_type = v;
    }

    // bool isActive = 2;


    pub fn get_isActive(&self) -> bool {
        self.isActive
    }
    pub fn clear_isActive(&mut self) {
        self.isActive = false;
    }

    // Param is passed by value, moved
    pub fn set_isActive(&mut self, v: bool) {
        self.isActive = v;
    }

    // bool isVIPOnly = 3;


    pub fn get_isVIPOnly(&self) -> bool {
        self.isVIPOnly
    }
    pub fn clear_isVIPOnly(&mut self) {
        self.isVIPOnly = false;
    }

    // Param is passed by value, moved
    pub fn set_isVIPOnly(&mut self, v: bool) {
        self.isVIPOnly = v;
    }

    // bool unlockableByWatchAd = 4;


    pub fn get_unlockableByWatchAd(&self) -> bool {
        self.unlockableByWatchAd
    }
    pub fn clear_unlockableByWatchAd(&mut self) {
        self.unlockableByWatchAd = false;
    }

    // Param is passed by value, moved
    pub fn set_unlockableByWatchAd(&mut self, v: bool) {
        self.unlockableByWatchAd = v;
    }
}

impl ::protobuf::Message for FeatureConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isActive = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isVIPOnly = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unlockableByWatchAd = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PBAccountListDataType::PBAccountListDataType_None {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.isActive != false {
            my_size += 2;
        }
        if self.isVIPOnly != false {
            my_size += 2;
        }
        if self.unlockableByWatchAd != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PBAccountListDataType::PBAccountListDataType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.isActive != false {
            os.write_bool(2, self.isActive)?;
        }
        if self.isVIPOnly != false {
            os.write_bool(3, self.isVIPOnly)?;
        }
        if self.unlockableByWatchAd != false {
            os.write_bool(4, self.unlockableByWatchAd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureConfig {
        FeatureConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountListDataType>>(
                "type",
                |m: &FeatureConfig| { &m.field_type },
                |m: &mut FeatureConfig| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isActive",
                |m: &FeatureConfig| { &m.isActive },
                |m: &mut FeatureConfig| { &mut m.isActive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isVIPOnly",
                |m: &FeatureConfig| { &m.isVIPOnly },
                |m: &mut FeatureConfig| { &mut m.isVIPOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unlockableByWatchAd",
                |m: &FeatureConfig| { &m.unlockableByWatchAd },
                |m: &mut FeatureConfig| { &mut m.unlockableByWatchAd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureConfig>(
                "FeatureConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureConfig {
        static instance: ::protobuf::rt::LazyV2<FeatureConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureConfig::new)
    }
}

impl ::protobuf::Clear for FeatureConfig {
    fn clear(&mut self) {
        self.field_type = PBAccountListDataType::PBAccountListDataType_None;
        self.isActive = false;
        self.isVIPOnly = false;
        self.unlockableByWatchAd = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchConfigReply {
    // message fields
    pub params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub products: ::protobuf::RepeatedField<PBProduct>,
    pub features: ::protobuf::RepeatedField<FeatureConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchConfigReply {
    fn default() -> &'a PBFetchConfigReply {
        <PBFetchConfigReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchConfigReply {
    pub fn new() -> PBFetchConfigReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchConfigReply.ParamsEntry params = 1;


    pub fn get_params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.params, ::std::collections::HashMap::new())
    }

    // repeated .PBProduct products = 2;


    pub fn get_products(&self) -> &[PBProduct] {
        &self.products
    }
    pub fn clear_products(&mut self) {
        self.products.clear();
    }

    // Param is passed by value, moved
    pub fn set_products(&mut self, v: ::protobuf::RepeatedField<PBProduct>) {
        self.products = v;
    }

    // Mutable pointer to the field.
    pub fn mut_products(&mut self) -> &mut ::protobuf::RepeatedField<PBProduct> {
        &mut self.products
    }

    // Take field
    pub fn take_products(&mut self) -> ::protobuf::RepeatedField<PBProduct> {
        ::std::mem::replace(&mut self.products, ::protobuf::RepeatedField::new())
    }

    // repeated .FeatureConfig features = 3;


    pub fn get_features(&self) -> &[FeatureConfig] {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::protobuf::RepeatedField<FeatureConfig>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::protobuf::RepeatedField<FeatureConfig> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::protobuf::RepeatedField<FeatureConfig> {
        ::std::mem::replace(&mut self.features, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchConfigReply {
    fn is_initialized(&self) -> bool {
        for v in &self.products {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.params)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.products)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.features)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.params);
        for value in &self.products {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.params, os)?;
        for v in &self.products {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.features {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchConfigReply {
        PBFetchConfigReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "params",
                |m: &PBFetchConfigReply| { &m.params },
                |m: &mut PBFetchConfigReply| { &mut m.params },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBProduct>>(
                "products",
                |m: &PBFetchConfigReply| { &m.products },
                |m: &mut PBFetchConfigReply| { &mut m.products },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureConfig>>(
                "features",
                |m: &PBFetchConfigReply| { &m.features },
                |m: &mut PBFetchConfigReply| { &mut m.features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchConfigReply>(
                "PBFetchConfigReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchConfigReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchConfigReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchConfigReply::new)
    }
}

impl ::protobuf::Clear for PBFetchConfigReply {
    fn clear(&mut self) {
        self.params.clear();
        self.products.clear();
        self.features.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchConfigReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchConfigReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAppParamsRequest {
    // message fields
    pub appVersion: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAppParamsRequest {
    fn default() -> &'a PBFetchAppParamsRequest {
        <PBFetchAppParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAppParamsRequest {
    pub fn new() -> PBFetchAppParamsRequest {
        ::std::default::Default::default()
    }

    // string appVersion = 1;


    pub fn get_appVersion(&self) -> &str {
        &self.appVersion
    }
    pub fn clear_appVersion(&mut self) {
        self.appVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_appVersion(&mut self, v: ::std::string::String) {
        self.appVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appVersion(&mut self) -> &mut ::std::string::String {
        &mut self.appVersion
    }

    // Take field
    pub fn take_appVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appVersion, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBFetchAppParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appVersion);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appVersion.is_empty() {
            os.write_string(1, &self.appVersion)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAppParamsRequest {
        PBFetchAppParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appVersion",
                |m: &PBFetchAppParamsRequest| { &m.appVersion },
                |m: &mut PBFetchAppParamsRequest| { &mut m.appVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAppParamsRequest>(
                "PBFetchAppParamsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAppParamsRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchAppParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAppParamsRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchAppParamsRequest {
    fn clear(&mut self) {
        self.appVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAppParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAppParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAppParamsReply {
    // message fields
    pub params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAppParamsReply {
    fn default() -> &'a PBFetchAppParamsReply {
        <PBFetchAppParamsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAppParamsReply {
    pub fn new() -> PBFetchAppParamsReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchAppParamsReply.ParamsEntry params = 1;


    pub fn get_params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.params, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PBFetchAppParamsReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.params);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.params, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAppParamsReply {
        PBFetchAppParamsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "params",
                |m: &PBFetchAppParamsReply| { &m.params },
                |m: &mut PBFetchAppParamsReply| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAppParamsReply>(
                "PBFetchAppParamsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAppParamsReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchAppParamsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAppParamsReply::new)
    }
}

impl ::protobuf::Clear for PBFetchAppParamsReply {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAppParamsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAppParamsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBUpdateOneSignalPlayerIDRequest {
    // message fields
    pub oneSignalPlayerID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBUpdateOneSignalPlayerIDRequest {
    fn default() -> &'a PBUpdateOneSignalPlayerIDRequest {
        <PBUpdateOneSignalPlayerIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBUpdateOneSignalPlayerIDRequest {
    pub fn new() -> PBUpdateOneSignalPlayerIDRequest {
        ::std::default::Default::default()
    }

    // string oneSignalPlayerID = 1;


    pub fn get_oneSignalPlayerID(&self) -> &str {
        &self.oneSignalPlayerID
    }
    pub fn clear_oneSignalPlayerID(&mut self) {
        self.oneSignalPlayerID.clear();
    }

    // Param is passed by value, moved
    pub fn set_oneSignalPlayerID(&mut self, v: ::std::string::String) {
        self.oneSignalPlayerID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oneSignalPlayerID(&mut self) -> &mut ::std::string::String {
        &mut self.oneSignalPlayerID
    }

    // Take field
    pub fn take_oneSignalPlayerID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oneSignalPlayerID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBUpdateOneSignalPlayerIDRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oneSignalPlayerID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.oneSignalPlayerID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.oneSignalPlayerID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.oneSignalPlayerID.is_empty() {
            os.write_string(1, &self.oneSignalPlayerID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBUpdateOneSignalPlayerIDRequest {
        PBUpdateOneSignalPlayerIDRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oneSignalPlayerID",
                |m: &PBUpdateOneSignalPlayerIDRequest| { &m.oneSignalPlayerID },
                |m: &mut PBUpdateOneSignalPlayerIDRequest| { &mut m.oneSignalPlayerID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBUpdateOneSignalPlayerIDRequest>(
                "PBUpdateOneSignalPlayerIDRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBUpdateOneSignalPlayerIDRequest {
        static instance: ::protobuf::rt::LazyV2<PBUpdateOneSignalPlayerIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBUpdateOneSignalPlayerIDRequest::new)
    }
}

impl ::protobuf::Clear for PBUpdateOneSignalPlayerIDRequest {
    fn clear(&mut self) {
        self.oneSignalPlayerID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBUpdateOneSignalPlayerIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBUpdateOneSignalPlayerIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBUpdateOneSignalPlayerIDReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBUpdateOneSignalPlayerIDReply {
    fn default() -> &'a PBUpdateOneSignalPlayerIDReply {
        <PBUpdateOneSignalPlayerIDReply as ::protobuf::Message>::default_instance()
    }
}

impl PBUpdateOneSignalPlayerIDReply {
    pub fn new() -> PBUpdateOneSignalPlayerIDReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBUpdateOneSignalPlayerIDReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBUpdateOneSignalPlayerIDReply {
        PBUpdateOneSignalPlayerIDReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBUpdateOneSignalPlayerIDReply>(
                "PBUpdateOneSignalPlayerIDReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBUpdateOneSignalPlayerIDReply {
        static instance: ::protobuf::rt::LazyV2<PBUpdateOneSignalPlayerIDReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBUpdateOneSignalPlayerIDReply::new)
    }
}

impl ::protobuf::Clear for PBUpdateOneSignalPlayerIDReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBUpdateOneSignalPlayerIDReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBUpdateOneSignalPlayerIDReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBReloadSettingsRequest {
    // message fields
    pub adminUsername: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBReloadSettingsRequest {
    fn default() -> &'a PBReloadSettingsRequest {
        <PBReloadSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBReloadSettingsRequest {
    pub fn new() -> PBReloadSettingsRequest {
        ::std::default::Default::default()
    }

    // string adminUsername = 1;


    pub fn get_adminUsername(&self) -> &str {
        &self.adminUsername
    }
    pub fn clear_adminUsername(&mut self) {
        self.adminUsername.clear();
    }

    // Param is passed by value, moved
    pub fn set_adminUsername(&mut self, v: ::std::string::String) {
        self.adminUsername = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adminUsername(&mut self) -> &mut ::std::string::String {
        &mut self.adminUsername
    }

    // Take field
    pub fn take_adminUsername(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.adminUsername, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBReloadSettingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.adminUsername)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.adminUsername.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.adminUsername);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.adminUsername.is_empty() {
            os.write_string(1, &self.adminUsername)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBReloadSettingsRequest {
        PBReloadSettingsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "adminUsername",
                |m: &PBReloadSettingsRequest| { &m.adminUsername },
                |m: &mut PBReloadSettingsRequest| { &mut m.adminUsername },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBReloadSettingsRequest>(
                "PBReloadSettingsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBReloadSettingsRequest {
        static instance: ::protobuf::rt::LazyV2<PBReloadSettingsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBReloadSettingsRequest::new)
    }
}

impl ::protobuf::Clear for PBReloadSettingsRequest {
    fn clear(&mut self) {
        self.adminUsername.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBReloadSettingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBReloadSettingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBReloadSettingsReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBReloadSettingsReply {
    fn default() -> &'a PBReloadSettingsReply {
        <PBReloadSettingsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBReloadSettingsReply {
    pub fn new() -> PBReloadSettingsReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBReloadSettingsReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBReloadSettingsReply {
        PBReloadSettingsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBReloadSettingsReply>(
                "PBReloadSettingsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBReloadSettingsReply {
        static instance: ::protobuf::rt::LazyV2<PBReloadSettingsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBReloadSettingsReply::new)
    }
}

impl ::protobuf::Clear for PBReloadSettingsReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBReloadSettingsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBReloadSettingsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBSubcription {
    // message fields
    pub productID: ::std::string::String,
    pub purchaseDate: i64,
    pub expiresDate: i64,
    pub isTrialPeriod: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBSubcription {
    fn default() -> &'a PBSubcription {
        <PBSubcription as ::protobuf::Message>::default_instance()
    }
}

impl PBSubcription {
    pub fn new() -> PBSubcription {
        ::std::default::Default::default()
    }

    // string productID = 1;


    pub fn get_productID(&self) -> &str {
        &self.productID
    }
    pub fn clear_productID(&mut self) {
        self.productID.clear();
    }

    // Param is passed by value, moved
    pub fn set_productID(&mut self, v: ::std::string::String) {
        self.productID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productID(&mut self) -> &mut ::std::string::String {
        &mut self.productID
    }

    // Take field
    pub fn take_productID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.productID, ::std::string::String::new())
    }

    // int64 purchaseDate = 2;


    pub fn get_purchaseDate(&self) -> i64 {
        self.purchaseDate
    }
    pub fn clear_purchaseDate(&mut self) {
        self.purchaseDate = 0;
    }

    // Param is passed by value, moved
    pub fn set_purchaseDate(&mut self, v: i64) {
        self.purchaseDate = v;
    }

    // int64 expiresDate = 3;


    pub fn get_expiresDate(&self) -> i64 {
        self.expiresDate
    }
    pub fn clear_expiresDate(&mut self) {
        self.expiresDate = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiresDate(&mut self, v: i64) {
        self.expiresDate = v;
    }

    // bool isTrialPeriod = 4;


    pub fn get_isTrialPeriod(&self) -> bool {
        self.isTrialPeriod
    }
    pub fn clear_isTrialPeriod(&mut self) {
        self.isTrialPeriod = false;
    }

    // Param is passed by value, moved
    pub fn set_isTrialPeriod(&mut self, v: bool) {
        self.isTrialPeriod = v;
    }
}

impl ::protobuf::Message for PBSubcription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.productID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.purchaseDate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiresDate = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isTrialPeriod = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.productID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.productID);
        }
        if self.purchaseDate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.purchaseDate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiresDate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.expiresDate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isTrialPeriod != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.productID.is_empty() {
            os.write_string(1, &self.productID)?;
        }
        if self.purchaseDate != 0 {
            os.write_int64(2, self.purchaseDate)?;
        }
        if self.expiresDate != 0 {
            os.write_int64(3, self.expiresDate)?;
        }
        if self.isTrialPeriod != false {
            os.write_bool(4, self.isTrialPeriod)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBSubcription {
        PBSubcription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productID",
                |m: &PBSubcription| { &m.productID },
                |m: &mut PBSubcription| { &mut m.productID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "purchaseDate",
                |m: &PBSubcription| { &m.purchaseDate },
                |m: &mut PBSubcription| { &mut m.purchaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiresDate",
                |m: &PBSubcription| { &m.expiresDate },
                |m: &mut PBSubcription| { &mut m.expiresDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isTrialPeriod",
                |m: &PBSubcription| { &m.isTrialPeriod },
                |m: &mut PBSubcription| { &mut m.isTrialPeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBSubcription>(
                "PBSubcription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBSubcription {
        static instance: ::protobuf::rt::LazyV2<PBSubcription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBSubcription::new)
    }
}

impl ::protobuf::Clear for PBSubcription {
    fn clear(&mut self) {
        self.productID.clear();
        self.purchaseDate = 0;
        self.expiresDate = 0;
        self.isTrialPeriod = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBSubcription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSubcription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTransaction {
    // message fields
    pub product: ::protobuf::SingularPtrField<PBProduct>,
    pub transactionID: ::std::string::String,
    pub receipt: ::std::string::String,
    pub valid: bool,
    pub alreadyProcessed: bool,
    pub jsonParams: ::std::string::String,
    pub status: i64,
    pub hasTrial: bool,
    pub activeSubscription: ::protobuf::SingularPtrField<PBSubcription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTransaction {
    fn default() -> &'a PBTransaction {
        <PBTransaction as ::protobuf::Message>::default_instance()
    }
}

impl PBTransaction {
    pub fn new() -> PBTransaction {
        ::std::default::Default::default()
    }

    // .PBProduct product = 1;


    pub fn get_product(&self) -> &PBProduct {
        self.product.as_ref().unwrap_or_else(|| <PBProduct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: PBProduct) {
        self.product = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut PBProduct {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> PBProduct {
        self.product.take().unwrap_or_else(|| PBProduct::new())
    }

    // string transactionID = 2;


    pub fn get_transactionID(&self) -> &str {
        &self.transactionID
    }
    pub fn clear_transactionID(&mut self) {
        self.transactionID.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactionID(&mut self, v: ::std::string::String) {
        self.transactionID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transactionID(&mut self) -> &mut ::std::string::String {
        &mut self.transactionID
    }

    // Take field
    pub fn take_transactionID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transactionID, ::std::string::String::new())
    }

    // string receipt = 3;


    pub fn get_receipt(&self) -> &str {
        &self.receipt
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::string::String) {
        self.receipt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::string::String {
        &mut self.receipt
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receipt, ::std::string::String::new())
    }

    // bool valid = 4;


    pub fn get_valid(&self) -> bool {
        self.valid
    }
    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    // bool alreadyProcessed = 5;


    pub fn get_alreadyProcessed(&self) -> bool {
        self.alreadyProcessed
    }
    pub fn clear_alreadyProcessed(&mut self) {
        self.alreadyProcessed = false;
    }

    // Param is passed by value, moved
    pub fn set_alreadyProcessed(&mut self, v: bool) {
        self.alreadyProcessed = v;
    }

    // string jsonParams = 6;


    pub fn get_jsonParams(&self) -> &str {
        &self.jsonParams
    }
    pub fn clear_jsonParams(&mut self) {
        self.jsonParams.clear();
    }

    // Param is passed by value, moved
    pub fn set_jsonParams(&mut self, v: ::std::string::String) {
        self.jsonParams = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsonParams(&mut self) -> &mut ::std::string::String {
        &mut self.jsonParams
    }

    // Take field
    pub fn take_jsonParams(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.jsonParams, ::std::string::String::new())
    }

    // int64 status = 7;


    pub fn get_status(&self) -> i64 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i64) {
        self.status = v;
    }

    // bool hasTrial = 8;


    pub fn get_hasTrial(&self) -> bool {
        self.hasTrial
    }
    pub fn clear_hasTrial(&mut self) {
        self.hasTrial = false;
    }

    // Param is passed by value, moved
    pub fn set_hasTrial(&mut self, v: bool) {
        self.hasTrial = v;
    }

    // .PBSubcription activeSubscription = 9;


    pub fn get_activeSubscription(&self) -> &PBSubcription {
        self.activeSubscription.as_ref().unwrap_or_else(|| <PBSubcription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_activeSubscription(&mut self) {
        self.activeSubscription.clear();
    }

    pub fn has_activeSubscription(&self) -> bool {
        self.activeSubscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeSubscription(&mut self, v: PBSubcription) {
        self.activeSubscription = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activeSubscription(&mut self) -> &mut PBSubcription {
        if self.activeSubscription.is_none() {
            self.activeSubscription.set_default();
        }
        self.activeSubscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_activeSubscription(&mut self) -> PBSubcription {
        self.activeSubscription.take().unwrap_or_else(|| PBSubcription::new())
    }
}

impl ::protobuf::Message for PBTransaction {
    fn is_initialized(&self) -> bool {
        for v in &self.product {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activeSubscription {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transactionID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receipt)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.alreadyProcessed = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.jsonParams)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.status = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasTrial = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activeSubscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.product.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.transactionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.transactionID);
        }
        if !self.receipt.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.receipt);
        }
        if self.valid != false {
            my_size += 2;
        }
        if self.alreadyProcessed != false {
            my_size += 2;
        }
        if !self.jsonParams.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.jsonParams);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(7, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hasTrial != false {
            my_size += 2;
        }
        if let Some(ref v) = self.activeSubscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.product.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.transactionID.is_empty() {
            os.write_string(2, &self.transactionID)?;
        }
        if !self.receipt.is_empty() {
            os.write_string(3, &self.receipt)?;
        }
        if self.valid != false {
            os.write_bool(4, self.valid)?;
        }
        if self.alreadyProcessed != false {
            os.write_bool(5, self.alreadyProcessed)?;
        }
        if !self.jsonParams.is_empty() {
            os.write_string(6, &self.jsonParams)?;
        }
        if self.status != 0 {
            os.write_int64(7, self.status)?;
        }
        if self.hasTrial != false {
            os.write_bool(8, self.hasTrial)?;
        }
        if let Some(ref v) = self.activeSubscription.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTransaction {
        PBTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBProduct>>(
                "product",
                |m: &PBTransaction| { &m.product },
                |m: &mut PBTransaction| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transactionID",
                |m: &PBTransaction| { &m.transactionID },
                |m: &mut PBTransaction| { &mut m.transactionID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "receipt",
                |m: &PBTransaction| { &m.receipt },
                |m: &mut PBTransaction| { &mut m.receipt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "valid",
                |m: &PBTransaction| { &m.valid },
                |m: &mut PBTransaction| { &mut m.valid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "alreadyProcessed",
                |m: &PBTransaction| { &m.alreadyProcessed },
                |m: &mut PBTransaction| { &mut m.alreadyProcessed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "jsonParams",
                |m: &PBTransaction| { &m.jsonParams },
                |m: &mut PBTransaction| { &mut m.jsonParams },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "status",
                |m: &PBTransaction| { &m.status },
                |m: &mut PBTransaction| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasTrial",
                |m: &PBTransaction| { &m.hasTrial },
                |m: &mut PBTransaction| { &mut m.hasTrial },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBSubcription>>(
                "activeSubscription",
                |m: &PBTransaction| { &m.activeSubscription },
                |m: &mut PBTransaction| { &mut m.activeSubscription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTransaction>(
                "PBTransaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTransaction {
        static instance: ::protobuf::rt::LazyV2<PBTransaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTransaction::new)
    }
}

impl ::protobuf::Clear for PBTransaction {
    fn clear(&mut self) {
        self.product.clear();
        self.transactionID.clear();
        self.receipt.clear();
        self.valid = false;
        self.alreadyProcessed = false;
        self.jsonParams.clear();
        self.status = 0;
        self.hasTrial = false;
        self.activeSubscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBValidateTransactionRequest {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<PBTransaction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBValidateTransactionRequest {
    fn default() -> &'a PBValidateTransactionRequest {
        <PBValidateTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBValidateTransactionRequest {
    pub fn new() -> PBValidateTransactionRequest {
        ::std::default::Default::default()
    }

    // .PBTransaction transaction = 1;


    pub fn get_transaction(&self) -> &PBTransaction {
        self.transaction.as_ref().unwrap_or_else(|| <PBTransaction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: PBTransaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut PBTransaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> PBTransaction {
        self.transaction.take().unwrap_or_else(|| PBTransaction::new())
    }
}

impl ::protobuf::Message for PBValidateTransactionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBValidateTransactionRequest {
        PBValidateTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBTransaction>>(
                "transaction",
                |m: &PBValidateTransactionRequest| { &m.transaction },
                |m: &mut PBValidateTransactionRequest| { &mut m.transaction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBValidateTransactionRequest>(
                "PBValidateTransactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBValidateTransactionRequest {
        static instance: ::protobuf::rt::LazyV2<PBValidateTransactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBValidateTransactionRequest::new)
    }
}

impl ::protobuf::Clear for PBValidateTransactionRequest {
    fn clear(&mut self) {
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBValidateTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBValidateTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBValidateTransactionReply {
    // message fields
    pub transactions: ::protobuf::RepeatedField<PBTransaction>,
    pub product: ::protobuf::SingularPtrField<PBProduct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBValidateTransactionReply {
    fn default() -> &'a PBValidateTransactionReply {
        <PBValidateTransactionReply as ::protobuf::Message>::default_instance()
    }
}

impl PBValidateTransactionReply {
    pub fn new() -> PBValidateTransactionReply {
        ::std::default::Default::default()
    }

    // repeated .PBTransaction transactions = 1;


    pub fn get_transactions(&self) -> &[PBTransaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<PBTransaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<PBTransaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<PBTransaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // .PBProduct product = 2;


    pub fn get_product(&self) -> &PBProduct {
        self.product.as_ref().unwrap_or_else(|| <PBProduct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: PBProduct) {
        self.product = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut PBProduct {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> PBProduct {
        self.product.take().unwrap_or_else(|| PBProduct::new())
    }
}

impl ::protobuf::Message for PBValidateTransactionReply {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.product {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.product.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.product.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBValidateTransactionReply {
        PBValidateTransactionReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBTransaction>>(
                "transactions",
                |m: &PBValidateTransactionReply| { &m.transactions },
                |m: &mut PBValidateTransactionReply| { &mut m.transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBProduct>>(
                "product",
                |m: &PBValidateTransactionReply| { &m.product },
                |m: &mut PBValidateTransactionReply| { &mut m.product },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBValidateTransactionReply>(
                "PBValidateTransactionReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBValidateTransactionReply {
        static instance: ::protobuf::rt::LazyV2<PBValidateTransactionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBValidateTransactionReply::new)
    }
}

impl ::protobuf::Clear for PBValidateTransactionReply {
    fn clear(&mut self) {
        self.transactions.clear();
        self.product.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBValidateTransactionReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBValidateTransactionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBVerifySubscriptionRequest {
    // message fields
    pub receipt: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBVerifySubscriptionRequest {
    fn default() -> &'a PBVerifySubscriptionRequest {
        <PBVerifySubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBVerifySubscriptionRequest {
    pub fn new() -> PBVerifySubscriptionRequest {
        ::std::default::Default::default()
    }

    // bytes receipt = 1;


    pub fn get_receipt(&self) -> &[u8] {
        &self.receipt
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::vec::Vec<u8>) {
        self.receipt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receipt
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receipt, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBVerifySubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receipt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.receipt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.receipt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.receipt.is_empty() {
            os.write_bytes(1, &self.receipt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBVerifySubscriptionRequest {
        PBVerifySubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "receipt",
                |m: &PBVerifySubscriptionRequest| { &m.receipt },
                |m: &mut PBVerifySubscriptionRequest| { &mut m.receipt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBVerifySubscriptionRequest>(
                "PBVerifySubscriptionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBVerifySubscriptionRequest {
        static instance: ::protobuf::rt::LazyV2<PBVerifySubscriptionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBVerifySubscriptionRequest::new)
    }
}

impl ::protobuf::Clear for PBVerifySubscriptionRequest {
    fn clear(&mut self) {
        self.receipt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBVerifySubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBVerifySubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBVerifySubscriptionReply {
    // message fields
    pub result: PBVerifySubscriptionResult,
    pub expiryTimestamp: i64,
    pub isInFreeTrial: bool,
    pub billingCycle: BillingCycle,
    pub isSandbox: bool,
    pub productID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBVerifySubscriptionReply {
    fn default() -> &'a PBVerifySubscriptionReply {
        <PBVerifySubscriptionReply as ::protobuf::Message>::default_instance()
    }
}

impl PBVerifySubscriptionReply {
    pub fn new() -> PBVerifySubscriptionReply {
        ::std::default::Default::default()
    }

    // .PBVerifySubscriptionResult result = 1;


    pub fn get_result(&self) -> PBVerifySubscriptionResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = PBVerifySubscriptionResult::notPurchased;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: PBVerifySubscriptionResult) {
        self.result = v;
    }

    // int64 expiryTimestamp = 2;


    pub fn get_expiryTimestamp(&self) -> i64 {
        self.expiryTimestamp
    }
    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: i64) {
        self.expiryTimestamp = v;
    }

    // bool isInFreeTrial = 3;


    pub fn get_isInFreeTrial(&self) -> bool {
        self.isInFreeTrial
    }
    pub fn clear_isInFreeTrial(&mut self) {
        self.isInFreeTrial = false;
    }

    // Param is passed by value, moved
    pub fn set_isInFreeTrial(&mut self, v: bool) {
        self.isInFreeTrial = v;
    }

    // .BillingCycle billingCycle = 4;


    pub fn get_billingCycle(&self) -> BillingCycle {
        self.billingCycle
    }
    pub fn clear_billingCycle(&mut self) {
        self.billingCycle = BillingCycle::weekly;
    }

    // Param is passed by value, moved
    pub fn set_billingCycle(&mut self, v: BillingCycle) {
        self.billingCycle = v;
    }

    // bool isSandbox = 5;


    pub fn get_isSandbox(&self) -> bool {
        self.isSandbox
    }
    pub fn clear_isSandbox(&mut self) {
        self.isSandbox = false;
    }

    // Param is passed by value, moved
    pub fn set_isSandbox(&mut self, v: bool) {
        self.isSandbox = v;
    }

    // string productID = 6;


    pub fn get_productID(&self) -> &str {
        &self.productID
    }
    pub fn clear_productID(&mut self) {
        self.productID.clear();
    }

    // Param is passed by value, moved
    pub fn set_productID(&mut self, v: ::std::string::String) {
        self.productID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productID(&mut self) -> &mut ::std::string::String {
        &mut self.productID
    }

    // Take field
    pub fn take_productID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.productID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBVerifySubscriptionReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiryTimestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isInFreeTrial = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.billingCycle, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isSandbox = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.productID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != PBVerifySubscriptionResult::notPurchased {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if self.expiryTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.expiryTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isInFreeTrial != false {
            my_size += 2;
        }
        if self.billingCycle != BillingCycle::weekly {
            my_size += ::protobuf::rt::enum_size(4, self.billingCycle);
        }
        if self.isSandbox != false {
            my_size += 2;
        }
        if !self.productID.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.productID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != PBVerifySubscriptionResult::notPurchased {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if self.expiryTimestamp != 0 {
            os.write_int64(2, self.expiryTimestamp)?;
        }
        if self.isInFreeTrial != false {
            os.write_bool(3, self.isInFreeTrial)?;
        }
        if self.billingCycle != BillingCycle::weekly {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.billingCycle))?;
        }
        if self.isSandbox != false {
            os.write_bool(5, self.isSandbox)?;
        }
        if !self.productID.is_empty() {
            os.write_string(6, &self.productID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBVerifySubscriptionReply {
        PBVerifySubscriptionReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBVerifySubscriptionResult>>(
                "result",
                |m: &PBVerifySubscriptionReply| { &m.result },
                |m: &mut PBVerifySubscriptionReply| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiryTimestamp",
                |m: &PBVerifySubscriptionReply| { &m.expiryTimestamp },
                |m: &mut PBVerifySubscriptionReply| { &mut m.expiryTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isInFreeTrial",
                |m: &PBVerifySubscriptionReply| { &m.isInFreeTrial },
                |m: &mut PBVerifySubscriptionReply| { &mut m.isInFreeTrial },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BillingCycle>>(
                "billingCycle",
                |m: &PBVerifySubscriptionReply| { &m.billingCycle },
                |m: &mut PBVerifySubscriptionReply| { &mut m.billingCycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isSandbox",
                |m: &PBVerifySubscriptionReply| { &m.isSandbox },
                |m: &mut PBVerifySubscriptionReply| { &mut m.isSandbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productID",
                |m: &PBVerifySubscriptionReply| { &m.productID },
                |m: &mut PBVerifySubscriptionReply| { &mut m.productID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBVerifySubscriptionReply>(
                "PBVerifySubscriptionReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBVerifySubscriptionReply {
        static instance: ::protobuf::rt::LazyV2<PBVerifySubscriptionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBVerifySubscriptionReply::new)
    }
}

impl ::protobuf::Clear for PBVerifySubscriptionReply {
    fn clear(&mut self) {
        self.result = PBVerifySubscriptionResult::notPurchased;
        self.expiryTimestamp = 0;
        self.isInFreeTrial = false;
        self.billingCycle = BillingCycle::weekly;
        self.isSandbox = false;
        self.productID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBVerifySubscriptionReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBVerifySubscriptionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBVerifySubscriptionAndroidRequest {
    // message fields
    pub purchases: ::protobuf::RepeatedField<PBVerifySubscriptionAndroidRequest_Purchase>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBVerifySubscriptionAndroidRequest {
    fn default() -> &'a PBVerifySubscriptionAndroidRequest {
        <PBVerifySubscriptionAndroidRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBVerifySubscriptionAndroidRequest {
    pub fn new() -> PBVerifySubscriptionAndroidRequest {
        ::std::default::Default::default()
    }

    // repeated .PBVerifySubscriptionAndroidRequest.Purchase purchases = 1;


    pub fn get_purchases(&self) -> &[PBVerifySubscriptionAndroidRequest_Purchase] {
        &self.purchases
    }
    pub fn clear_purchases(&mut self) {
        self.purchases.clear();
    }

    // Param is passed by value, moved
    pub fn set_purchases(&mut self, v: ::protobuf::RepeatedField<PBVerifySubscriptionAndroidRequest_Purchase>) {
        self.purchases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_purchases(&mut self) -> &mut ::protobuf::RepeatedField<PBVerifySubscriptionAndroidRequest_Purchase> {
        &mut self.purchases
    }

    // Take field
    pub fn take_purchases(&mut self) -> ::protobuf::RepeatedField<PBVerifySubscriptionAndroidRequest_Purchase> {
        ::std::mem::replace(&mut self.purchases, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBVerifySubscriptionAndroidRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.purchases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.purchases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.purchases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.purchases {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBVerifySubscriptionAndroidRequest {
        PBVerifySubscriptionAndroidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBVerifySubscriptionAndroidRequest_Purchase>>(
                "purchases",
                |m: &PBVerifySubscriptionAndroidRequest| { &m.purchases },
                |m: &mut PBVerifySubscriptionAndroidRequest| { &mut m.purchases },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBVerifySubscriptionAndroidRequest>(
                "PBVerifySubscriptionAndroidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBVerifySubscriptionAndroidRequest {
        static instance: ::protobuf::rt::LazyV2<PBVerifySubscriptionAndroidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBVerifySubscriptionAndroidRequest::new)
    }
}

impl ::protobuf::Clear for PBVerifySubscriptionAndroidRequest {
    fn clear(&mut self) {
        self.purchases.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBVerifySubscriptionAndroidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBVerifySubscriptionAndroidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBVerifySubscriptionAndroidRequest_Purchase {
    // message fields
    pub orderID: ::std::string::String,
    pub packageName: ::std::string::String,
    pub productID: ::std::string::String,
    pub purchaseTime: i64,
    pub purchaseToken: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBVerifySubscriptionAndroidRequest_Purchase {
    fn default() -> &'a PBVerifySubscriptionAndroidRequest_Purchase {
        <PBVerifySubscriptionAndroidRequest_Purchase as ::protobuf::Message>::default_instance()
    }
}

impl PBVerifySubscriptionAndroidRequest_Purchase {
    pub fn new() -> PBVerifySubscriptionAndroidRequest_Purchase {
        ::std::default::Default::default()
    }

    // string orderID = 1;


    pub fn get_orderID(&self) -> &str {
        &self.orderID
    }
    pub fn clear_orderID(&mut self) {
        self.orderID.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderID(&mut self, v: ::std::string::String) {
        self.orderID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderID(&mut self) -> &mut ::std::string::String {
        &mut self.orderID
    }

    // Take field
    pub fn take_orderID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.orderID, ::std::string::String::new())
    }

    // string packageName = 2;


    pub fn get_packageName(&self) -> &str {
        &self.packageName
    }
    pub fn clear_packageName(&mut self) {
        self.packageName.clear();
    }

    // Param is passed by value, moved
    pub fn set_packageName(&mut self, v: ::std::string::String) {
        self.packageName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packageName(&mut self) -> &mut ::std::string::String {
        &mut self.packageName
    }

    // Take field
    pub fn take_packageName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.packageName, ::std::string::String::new())
    }

    // string productID = 3;


    pub fn get_productID(&self) -> &str {
        &self.productID
    }
    pub fn clear_productID(&mut self) {
        self.productID.clear();
    }

    // Param is passed by value, moved
    pub fn set_productID(&mut self, v: ::std::string::String) {
        self.productID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productID(&mut self) -> &mut ::std::string::String {
        &mut self.productID
    }

    // Take field
    pub fn take_productID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.productID, ::std::string::String::new())
    }

    // int64 purchaseTime = 4;


    pub fn get_purchaseTime(&self) -> i64 {
        self.purchaseTime
    }
    pub fn clear_purchaseTime(&mut self) {
        self.purchaseTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_purchaseTime(&mut self, v: i64) {
        self.purchaseTime = v;
    }

    // string purchaseToken = 5;


    pub fn get_purchaseToken(&self) -> &str {
        &self.purchaseToken
    }
    pub fn clear_purchaseToken(&mut self) {
        self.purchaseToken.clear();
    }

    // Param is passed by value, moved
    pub fn set_purchaseToken(&mut self, v: ::std::string::String) {
        self.purchaseToken = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchaseToken(&mut self) -> &mut ::std::string::String {
        &mut self.purchaseToken
    }

    // Take field
    pub fn take_purchaseToken(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.purchaseToken, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBVerifySubscriptionAndroidRequest_Purchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.orderID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.packageName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.productID)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.purchaseTime = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.purchaseToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.orderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.orderID);
        }
        if !self.packageName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.packageName);
        }
        if !self.productID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.productID);
        }
        if self.purchaseTime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.purchaseTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.purchaseToken.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.purchaseToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.orderID.is_empty() {
            os.write_string(1, &self.orderID)?;
        }
        if !self.packageName.is_empty() {
            os.write_string(2, &self.packageName)?;
        }
        if !self.productID.is_empty() {
            os.write_string(3, &self.productID)?;
        }
        if self.purchaseTime != 0 {
            os.write_int64(4, self.purchaseTime)?;
        }
        if !self.purchaseToken.is_empty() {
            os.write_string(5, &self.purchaseToken)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBVerifySubscriptionAndroidRequest_Purchase {
        PBVerifySubscriptionAndroidRequest_Purchase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "orderID",
                |m: &PBVerifySubscriptionAndroidRequest_Purchase| { &m.orderID },
                |m: &mut PBVerifySubscriptionAndroidRequest_Purchase| { &mut m.orderID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &PBVerifySubscriptionAndroidRequest_Purchase| { &m.packageName },
                |m: &mut PBVerifySubscriptionAndroidRequest_Purchase| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productID",
                |m: &PBVerifySubscriptionAndroidRequest_Purchase| { &m.productID },
                |m: &mut PBVerifySubscriptionAndroidRequest_Purchase| { &mut m.productID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "purchaseTime",
                |m: &PBVerifySubscriptionAndroidRequest_Purchase| { &m.purchaseTime },
                |m: &mut PBVerifySubscriptionAndroidRequest_Purchase| { &mut m.purchaseTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseToken",
                |m: &PBVerifySubscriptionAndroidRequest_Purchase| { &m.purchaseToken },
                |m: &mut PBVerifySubscriptionAndroidRequest_Purchase| { &mut m.purchaseToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBVerifySubscriptionAndroidRequest_Purchase>(
                "PBVerifySubscriptionAndroidRequest.Purchase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBVerifySubscriptionAndroidRequest_Purchase {
        static instance: ::protobuf::rt::LazyV2<PBVerifySubscriptionAndroidRequest_Purchase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBVerifySubscriptionAndroidRequest_Purchase::new)
    }
}

impl ::protobuf::Clear for PBVerifySubscriptionAndroidRequest_Purchase {
    fn clear(&mut self) {
        self.orderID.clear();
        self.packageName.clear();
        self.productID.clear();
        self.purchaseTime = 0;
        self.purchaseToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBVerifySubscriptionAndroidRequest_Purchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBVerifySubscriptionAndroidRequest_Purchase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBVerifySubscriptionAndroidReply {
    // message fields
    pub result: PBVerifySubscriptionResult,
    pub expiryTimestamp: i64,
    pub isInFreeTrial: bool,
    pub billingCycle: BillingCycle,
    pub isSandbox: bool,
    pub productID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBVerifySubscriptionAndroidReply {
    fn default() -> &'a PBVerifySubscriptionAndroidReply {
        <PBVerifySubscriptionAndroidReply as ::protobuf::Message>::default_instance()
    }
}

impl PBVerifySubscriptionAndroidReply {
    pub fn new() -> PBVerifySubscriptionAndroidReply {
        ::std::default::Default::default()
    }

    // .PBVerifySubscriptionResult result = 1;


    pub fn get_result(&self) -> PBVerifySubscriptionResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = PBVerifySubscriptionResult::notPurchased;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: PBVerifySubscriptionResult) {
        self.result = v;
    }

    // int64 expiryTimestamp = 2;


    pub fn get_expiryTimestamp(&self) -> i64 {
        self.expiryTimestamp
    }
    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: i64) {
        self.expiryTimestamp = v;
    }

    // bool isInFreeTrial = 3;


    pub fn get_isInFreeTrial(&self) -> bool {
        self.isInFreeTrial
    }
    pub fn clear_isInFreeTrial(&mut self) {
        self.isInFreeTrial = false;
    }

    // Param is passed by value, moved
    pub fn set_isInFreeTrial(&mut self, v: bool) {
        self.isInFreeTrial = v;
    }

    // .BillingCycle billingCycle = 4;


    pub fn get_billingCycle(&self) -> BillingCycle {
        self.billingCycle
    }
    pub fn clear_billingCycle(&mut self) {
        self.billingCycle = BillingCycle::weekly;
    }

    // Param is passed by value, moved
    pub fn set_billingCycle(&mut self, v: BillingCycle) {
        self.billingCycle = v;
    }

    // bool isSandbox = 5;


    pub fn get_isSandbox(&self) -> bool {
        self.isSandbox
    }
    pub fn clear_isSandbox(&mut self) {
        self.isSandbox = false;
    }

    // Param is passed by value, moved
    pub fn set_isSandbox(&mut self, v: bool) {
        self.isSandbox = v;
    }

    // string productID = 6;


    pub fn get_productID(&self) -> &str {
        &self.productID
    }
    pub fn clear_productID(&mut self) {
        self.productID.clear();
    }

    // Param is passed by value, moved
    pub fn set_productID(&mut self, v: ::std::string::String) {
        self.productID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productID(&mut self) -> &mut ::std::string::String {
        &mut self.productID
    }

    // Take field
    pub fn take_productID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.productID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBVerifySubscriptionAndroidReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiryTimestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isInFreeTrial = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.billingCycle, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isSandbox = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.productID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != PBVerifySubscriptionResult::notPurchased {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if self.expiryTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.expiryTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isInFreeTrial != false {
            my_size += 2;
        }
        if self.billingCycle != BillingCycle::weekly {
            my_size += ::protobuf::rt::enum_size(4, self.billingCycle);
        }
        if self.isSandbox != false {
            my_size += 2;
        }
        if !self.productID.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.productID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != PBVerifySubscriptionResult::notPurchased {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if self.expiryTimestamp != 0 {
            os.write_int64(2, self.expiryTimestamp)?;
        }
        if self.isInFreeTrial != false {
            os.write_bool(3, self.isInFreeTrial)?;
        }
        if self.billingCycle != BillingCycle::weekly {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.billingCycle))?;
        }
        if self.isSandbox != false {
            os.write_bool(5, self.isSandbox)?;
        }
        if !self.productID.is_empty() {
            os.write_string(6, &self.productID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBVerifySubscriptionAndroidReply {
        PBVerifySubscriptionAndroidReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBVerifySubscriptionResult>>(
                "result",
                |m: &PBVerifySubscriptionAndroidReply| { &m.result },
                |m: &mut PBVerifySubscriptionAndroidReply| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiryTimestamp",
                |m: &PBVerifySubscriptionAndroidReply| { &m.expiryTimestamp },
                |m: &mut PBVerifySubscriptionAndroidReply| { &mut m.expiryTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isInFreeTrial",
                |m: &PBVerifySubscriptionAndroidReply| { &m.isInFreeTrial },
                |m: &mut PBVerifySubscriptionAndroidReply| { &mut m.isInFreeTrial },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BillingCycle>>(
                "billingCycle",
                |m: &PBVerifySubscriptionAndroidReply| { &m.billingCycle },
                |m: &mut PBVerifySubscriptionAndroidReply| { &mut m.billingCycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isSandbox",
                |m: &PBVerifySubscriptionAndroidReply| { &m.isSandbox },
                |m: &mut PBVerifySubscriptionAndroidReply| { &mut m.isSandbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productID",
                |m: &PBVerifySubscriptionAndroidReply| { &m.productID },
                |m: &mut PBVerifySubscriptionAndroidReply| { &mut m.productID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBVerifySubscriptionAndroidReply>(
                "PBVerifySubscriptionAndroidReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBVerifySubscriptionAndroidReply {
        static instance: ::protobuf::rt::LazyV2<PBVerifySubscriptionAndroidReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBVerifySubscriptionAndroidReply::new)
    }
}

impl ::protobuf::Clear for PBVerifySubscriptionAndroidReply {
    fn clear(&mut self) {
        self.result = PBVerifySubscriptionResult::notPurchased;
        self.expiryTimestamp = 0;
        self.isInFreeTrial = false;
        self.billingCycle = BillingCycle::weekly;
        self.isSandbox = false;
        self.productID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBVerifySubscriptionAndroidReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBVerifySubscriptionAndroidReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchUserPurchaseHistoryRequest {
    // message fields
    pub accountIDOfTargetUser: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchUserPurchaseHistoryRequest {
    fn default() -> &'a PBFetchUserPurchaseHistoryRequest {
        <PBFetchUserPurchaseHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchUserPurchaseHistoryRequest {
    pub fn new() -> PBFetchUserPurchaseHistoryRequest {
        ::std::default::Default::default()
    }

    // string accountIDOfTargetUser = 1;


    pub fn get_accountIDOfTargetUser(&self) -> &str {
        &self.accountIDOfTargetUser
    }
    pub fn clear_accountIDOfTargetUser(&mut self) {
        self.accountIDOfTargetUser.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountIDOfTargetUser(&mut self, v: ::std::string::String) {
        self.accountIDOfTargetUser = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountIDOfTargetUser(&mut self) -> &mut ::std::string::String {
        &mut self.accountIDOfTargetUser
    }

    // Take field
    pub fn take_accountIDOfTargetUser(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountIDOfTargetUser, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBFetchUserPurchaseHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountIDOfTargetUser)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountIDOfTargetUser.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountIDOfTargetUser);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountIDOfTargetUser.is_empty() {
            os.write_string(1, &self.accountIDOfTargetUser)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchUserPurchaseHistoryRequest {
        PBFetchUserPurchaseHistoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountIDOfTargetUser",
                |m: &PBFetchUserPurchaseHistoryRequest| { &m.accountIDOfTargetUser },
                |m: &mut PBFetchUserPurchaseHistoryRequest| { &mut m.accountIDOfTargetUser },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchUserPurchaseHistoryRequest>(
                "PBFetchUserPurchaseHistoryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchUserPurchaseHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchUserPurchaseHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchUserPurchaseHistoryRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchUserPurchaseHistoryRequest {
    fn clear(&mut self) {
        self.accountIDOfTargetUser.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchUserPurchaseHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchUserPurchaseHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBUserPurchaseUnit {
    // message fields
    pub productID: ::std::string::String,
    pub timestamp: i64,
    pub coins: i64,
    pub price: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBUserPurchaseUnit {
    fn default() -> &'a PBUserPurchaseUnit {
        <PBUserPurchaseUnit as ::protobuf::Message>::default_instance()
    }
}

impl PBUserPurchaseUnit {
    pub fn new() -> PBUserPurchaseUnit {
        ::std::default::Default::default()
    }

    // string productID = 1;


    pub fn get_productID(&self) -> &str {
        &self.productID
    }
    pub fn clear_productID(&mut self) {
        self.productID.clear();
    }

    // Param is passed by value, moved
    pub fn set_productID(&mut self, v: ::std::string::String) {
        self.productID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productID(&mut self) -> &mut ::std::string::String {
        &mut self.productID
    }

    // Take field
    pub fn take_productID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.productID, ::std::string::String::new())
    }

    // int64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // int64 coins = 3;


    pub fn get_coins(&self) -> i64 {
        self.coins
    }
    pub fn clear_coins(&mut self) {
        self.coins = 0;
    }

    // Param is passed by value, moved
    pub fn set_coins(&mut self, v: i64) {
        self.coins = v;
    }

    // int64 price = 4;


    pub fn get_price(&self) -> i64 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: i64) {
        self.price = v;
    }
}

impl ::protobuf::Message for PBUserPurchaseUnit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.productID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.coins = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.price = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.productID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.productID);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.coins != 0 {
            my_size += ::protobuf::rt::value_size(3, self.coins, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.price != 0 {
            my_size += ::protobuf::rt::value_size(4, self.price, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.productID.is_empty() {
            os.write_string(1, &self.productID)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        if self.coins != 0 {
            os.write_int64(3, self.coins)?;
        }
        if self.price != 0 {
            os.write_int64(4, self.price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBUserPurchaseUnit {
        PBUserPurchaseUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productID",
                |m: &PBUserPurchaseUnit| { &m.productID },
                |m: &mut PBUserPurchaseUnit| { &mut m.productID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &PBUserPurchaseUnit| { &m.timestamp },
                |m: &mut PBUserPurchaseUnit| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "coins",
                |m: &PBUserPurchaseUnit| { &m.coins },
                |m: &mut PBUserPurchaseUnit| { &mut m.coins },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "price",
                |m: &PBUserPurchaseUnit| { &m.price },
                |m: &mut PBUserPurchaseUnit| { &mut m.price },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBUserPurchaseUnit>(
                "PBUserPurchaseUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBUserPurchaseUnit {
        static instance: ::protobuf::rt::LazyV2<PBUserPurchaseUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBUserPurchaseUnit::new)
    }
}

impl ::protobuf::Clear for PBUserPurchaseUnit {
    fn clear(&mut self) {
        self.productID.clear();
        self.timestamp = 0;
        self.coins = 0;
        self.price = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBUserPurchaseUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBUserPurchaseUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchUserPurchaseHistoryReply {
    // message fields
    pub units: ::protobuf::SingularPtrField<PBUserPurchaseUnit>,
    pub coins: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchUserPurchaseHistoryReply {
    fn default() -> &'a PBFetchUserPurchaseHistoryReply {
        <PBFetchUserPurchaseHistoryReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchUserPurchaseHistoryReply {
    pub fn new() -> PBFetchUserPurchaseHistoryReply {
        ::std::default::Default::default()
    }

    // .PBUserPurchaseUnit units = 1;


    pub fn get_units(&self) -> &PBUserPurchaseUnit {
        self.units.as_ref().unwrap_or_else(|| <PBUserPurchaseUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: PBUserPurchaseUnit) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut PBUserPurchaseUnit {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> PBUserPurchaseUnit {
        self.units.take().unwrap_or_else(|| PBUserPurchaseUnit::new())
    }

    // int64 coins = 2;


    pub fn get_coins(&self) -> i64 {
        self.coins
    }
    pub fn clear_coins(&mut self) {
        self.coins = 0;
    }

    // Param is passed by value, moved
    pub fn set_coins(&mut self, v: i64) {
        self.coins = v;
    }
}

impl ::protobuf::Message for PBFetchUserPurchaseHistoryReply {
    fn is_initialized(&self) -> bool {
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.coins = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.coins != 0 {
            my_size += ::protobuf::rt::value_size(2, self.coins, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.coins != 0 {
            os.write_int64(2, self.coins)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchUserPurchaseHistoryReply {
        PBFetchUserPurchaseHistoryReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBUserPurchaseUnit>>(
                "units",
                |m: &PBFetchUserPurchaseHistoryReply| { &m.units },
                |m: &mut PBFetchUserPurchaseHistoryReply| { &mut m.units },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "coins",
                |m: &PBFetchUserPurchaseHistoryReply| { &m.coins },
                |m: &mut PBFetchUserPurchaseHistoryReply| { &mut m.coins },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchUserPurchaseHistoryReply>(
                "PBFetchUserPurchaseHistoryReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchUserPurchaseHistoryReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchUserPurchaseHistoryReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchUserPurchaseHistoryReply::new)
    }
}

impl ::protobuf::Clear for PBFetchUserPurchaseHistoryReply {
    fn clear(&mut self) {
        self.units.clear();
        self.coins = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchUserPurchaseHistoryReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchUserPurchaseHistoryReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostOneSignalNotification {
    // message fields
    pub notificationMessage: ::std::string::String,
    pub jsonParams: ::std::string::String,
    pub targetOneSignalPlayerIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostOneSignalNotification {
    fn default() -> &'a PBPostOneSignalNotification {
        <PBPostOneSignalNotification as ::protobuf::Message>::default_instance()
    }
}

impl PBPostOneSignalNotification {
    pub fn new() -> PBPostOneSignalNotification {
        ::std::default::Default::default()
    }

    // string notificationMessage = 1;


    pub fn get_notificationMessage(&self) -> &str {
        &self.notificationMessage
    }
    pub fn clear_notificationMessage(&mut self) {
        self.notificationMessage.clear();
    }

    // Param is passed by value, moved
    pub fn set_notificationMessage(&mut self, v: ::std::string::String) {
        self.notificationMessage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notificationMessage(&mut self) -> &mut ::std::string::String {
        &mut self.notificationMessage
    }

    // Take field
    pub fn take_notificationMessage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notificationMessage, ::std::string::String::new())
    }

    // string jsonParams = 2;


    pub fn get_jsonParams(&self) -> &str {
        &self.jsonParams
    }
    pub fn clear_jsonParams(&mut self) {
        self.jsonParams.clear();
    }

    // Param is passed by value, moved
    pub fn set_jsonParams(&mut self, v: ::std::string::String) {
        self.jsonParams = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsonParams(&mut self) -> &mut ::std::string::String {
        &mut self.jsonParams
    }

    // Take field
    pub fn take_jsonParams(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.jsonParams, ::std::string::String::new())
    }

    // repeated string targetOneSignalPlayerIDs = 3;


    pub fn get_targetOneSignalPlayerIDs(&self) -> &[::std::string::String] {
        &self.targetOneSignalPlayerIDs
    }
    pub fn clear_targetOneSignalPlayerIDs(&mut self) {
        self.targetOneSignalPlayerIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetOneSignalPlayerIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.targetOneSignalPlayerIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetOneSignalPlayerIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetOneSignalPlayerIDs
    }

    // Take field
    pub fn take_targetOneSignalPlayerIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.targetOneSignalPlayerIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBPostOneSignalNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notificationMessage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.jsonParams)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.targetOneSignalPlayerIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.notificationMessage.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.notificationMessage);
        }
        if !self.jsonParams.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.jsonParams);
        }
        for value in &self.targetOneSignalPlayerIDs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.notificationMessage.is_empty() {
            os.write_string(1, &self.notificationMessage)?;
        }
        if !self.jsonParams.is_empty() {
            os.write_string(2, &self.jsonParams)?;
        }
        for v in &self.targetOneSignalPlayerIDs {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostOneSignalNotification {
        PBPostOneSignalNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationMessage",
                |m: &PBPostOneSignalNotification| { &m.notificationMessage },
                |m: &mut PBPostOneSignalNotification| { &mut m.notificationMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "jsonParams",
                |m: &PBPostOneSignalNotification| { &m.jsonParams },
                |m: &mut PBPostOneSignalNotification| { &mut m.jsonParams },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetOneSignalPlayerIDs",
                |m: &PBPostOneSignalNotification| { &m.targetOneSignalPlayerIDs },
                |m: &mut PBPostOneSignalNotification| { &mut m.targetOneSignalPlayerIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostOneSignalNotification>(
                "PBPostOneSignalNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostOneSignalNotification {
        static instance: ::protobuf::rt::LazyV2<PBPostOneSignalNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostOneSignalNotification::new)
    }
}

impl ::protobuf::Clear for PBPostOneSignalNotification {
    fn clear(&mut self) {
        self.notificationMessage.clear();
        self.jsonParams.clear();
        self.targetOneSignalPlayerIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostOneSignalNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostOneSignalNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchUserSettingsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchUserSettingsRequest {
    fn default() -> &'a PBFetchUserSettingsRequest {
        <PBFetchUserSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchUserSettingsRequest {
    pub fn new() -> PBFetchUserSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBFetchUserSettingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchUserSettingsRequest {
        PBFetchUserSettingsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchUserSettingsRequest>(
                "PBFetchUserSettingsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchUserSettingsRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchUserSettingsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchUserSettingsRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchUserSettingsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchUserSettingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchUserSettingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchUserSettingsReply {
    // message fields
    pub userSettings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchUserSettingsReply {
    fn default() -> &'a PBFetchUserSettingsReply {
        <PBFetchUserSettingsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchUserSettingsReply {
    pub fn new() -> PBFetchUserSettingsReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchUserSettingsReply.UserSettingsEntry userSettings = 1;


    pub fn get_userSettings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.userSettings
    }
    pub fn clear_userSettings(&mut self) {
        self.userSettings.clear();
    }

    // Param is passed by value, moved
    pub fn set_userSettings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.userSettings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_userSettings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.userSettings
    }

    // Take field
    pub fn take_userSettings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.userSettings, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PBFetchUserSettingsReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.userSettings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.userSettings);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.userSettings, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchUserSettingsReply {
        PBFetchUserSettingsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "userSettings",
                |m: &PBFetchUserSettingsReply| { &m.userSettings },
                |m: &mut PBFetchUserSettingsReply| { &mut m.userSettings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchUserSettingsReply>(
                "PBFetchUserSettingsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchUserSettingsReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchUserSettingsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchUserSettingsReply::new)
    }
}

impl ::protobuf::Clear for PBFetchUserSettingsReply {
    fn clear(&mut self) {
        self.userSettings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchUserSettingsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchUserSettingsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostUserSettingsRequest {
    // message fields
    pub userSettings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostUserSettingsRequest {
    fn default() -> &'a PBPostUserSettingsRequest {
        <PBPostUserSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBPostUserSettingsRequest {
    pub fn new() -> PBPostUserSettingsRequest {
        ::std::default::Default::default()
    }

    // repeated .PBPostUserSettingsRequest.UserSettingsEntry userSettings = 1;


    pub fn get_userSettings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.userSettings
    }
    pub fn clear_userSettings(&mut self) {
        self.userSettings.clear();
    }

    // Param is passed by value, moved
    pub fn set_userSettings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.userSettings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_userSettings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.userSettings
    }

    // Take field
    pub fn take_userSettings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.userSettings, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PBPostUserSettingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.userSettings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.userSettings);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.userSettings, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostUserSettingsRequest {
        PBPostUserSettingsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "userSettings",
                |m: &PBPostUserSettingsRequest| { &m.userSettings },
                |m: &mut PBPostUserSettingsRequest| { &mut m.userSettings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostUserSettingsRequest>(
                "PBPostUserSettingsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostUserSettingsRequest {
        static instance: ::protobuf::rt::LazyV2<PBPostUserSettingsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostUserSettingsRequest::new)
    }
}

impl ::protobuf::Clear for PBPostUserSettingsRequest {
    fn clear(&mut self) {
        self.userSettings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostUserSettingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostUserSettingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostUserSettingsReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostUserSettingsReply {
    fn default() -> &'a PBPostUserSettingsReply {
        <PBPostUserSettingsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBPostUserSettingsReply {
    pub fn new() -> PBPostUserSettingsReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBPostUserSettingsReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostUserSettingsReply {
        PBPostUserSettingsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostUserSettingsReply>(
                "PBPostUserSettingsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostUserSettingsReply {
        static instance: ::protobuf::rt::LazyV2<PBPostUserSettingsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostUserSettingsReply::new)
    }
}

impl ::protobuf::Clear for PBPostUserSettingsReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostUserSettingsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostUserSettingsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPagination {
    // message fields
    pub pageNumber: i64,
    pub pageSize: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPagination {
    fn default() -> &'a PBPagination {
        <PBPagination as ::protobuf::Message>::default_instance()
    }
}

impl PBPagination {
    pub fn new() -> PBPagination {
        ::std::default::Default::default()
    }

    // int64 pageNumber = 1;


    pub fn get_pageNumber(&self) -> i64 {
        self.pageNumber
    }
    pub fn clear_pageNumber(&mut self) {
        self.pageNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_pageNumber(&mut self, v: i64) {
        self.pageNumber = v;
    }

    // int64 pageSize = 2;


    pub fn get_pageSize(&self) -> i64 {
        self.pageSize
    }
    pub fn clear_pageSize(&mut self) {
        self.pageSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_pageSize(&mut self, v: i64) {
        self.pageSize = v;
    }
}

impl ::protobuf::Message for PBPagination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pageNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pageSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pageNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.pageNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pageSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pageSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.pageNumber != 0 {
            os.write_int64(1, self.pageNumber)?;
        }
        if self.pageSize != 0 {
            os.write_int64(2, self.pageSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPagination {
        PBPagination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pageNumber",
                |m: &PBPagination| { &m.pageNumber },
                |m: &mut PBPagination| { &mut m.pageNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pageSize",
                |m: &PBPagination| { &m.pageSize },
                |m: &mut PBPagination| { &mut m.pageSize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPagination>(
                "PBPagination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPagination {
        static instance: ::protobuf::rt::LazyV2<PBPagination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPagination::new)
    }
}

impl ::protobuf::Clear for PBPagination {
    fn clear(&mut self) {
        self.pageNumber = 0;
        self.pageSize = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPagination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBLoginRequest {
    // message fields
    pub appVersion: ::std::string::String,
    pub countryName: ::std::string::String,
    pub countryCode: ::std::string::String,
    pub preferredLang: ::std::string::String,
    pub idfa: ::std::string::String,
    pub timezone: i64,
    pub account: ::protobuf::SingularPtrField<PBAccount>,
    pub loginType: PBLoginType,
    pub cookie: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBLoginRequest {
    fn default() -> &'a PBLoginRequest {
        <PBLoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBLoginRequest {
    pub fn new() -> PBLoginRequest {
        ::std::default::Default::default()
    }

    // string appVersion = 1;


    pub fn get_appVersion(&self) -> &str {
        &self.appVersion
    }
    pub fn clear_appVersion(&mut self) {
        self.appVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_appVersion(&mut self, v: ::std::string::String) {
        self.appVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appVersion(&mut self) -> &mut ::std::string::String {
        &mut self.appVersion
    }

    // Take field
    pub fn take_appVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appVersion, ::std::string::String::new())
    }

    // string countryName = 2;


    pub fn get_countryName(&self) -> &str {
        &self.countryName
    }
    pub fn clear_countryName(&mut self) {
        self.countryName.clear();
    }

    // Param is passed by value, moved
    pub fn set_countryName(&mut self, v: ::std::string::String) {
        self.countryName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_countryName(&mut self) -> &mut ::std::string::String {
        &mut self.countryName
    }

    // Take field
    pub fn take_countryName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.countryName, ::std::string::String::new())
    }

    // string countryCode = 3;


    pub fn get_countryCode(&self) -> &str {
        &self.countryCode
    }
    pub fn clear_countryCode(&mut self) {
        self.countryCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_countryCode(&mut self, v: ::std::string::String) {
        self.countryCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_countryCode(&mut self) -> &mut ::std::string::String {
        &mut self.countryCode
    }

    // Take field
    pub fn take_countryCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.countryCode, ::std::string::String::new())
    }

    // string preferredLang = 4;


    pub fn get_preferredLang(&self) -> &str {
        &self.preferredLang
    }
    pub fn clear_preferredLang(&mut self) {
        self.preferredLang.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredLang(&mut self, v: ::std::string::String) {
        self.preferredLang = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferredLang(&mut self) -> &mut ::std::string::String {
        &mut self.preferredLang
    }

    // Take field
    pub fn take_preferredLang(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.preferredLang, ::std::string::String::new())
    }

    // string idfa = 5;


    pub fn get_idfa(&self) -> &str {
        &self.idfa
    }
    pub fn clear_idfa(&mut self) {
        self.idfa.clear();
    }

    // Param is passed by value, moved
    pub fn set_idfa(&mut self, v: ::std::string::String) {
        self.idfa = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idfa(&mut self) -> &mut ::std::string::String {
        &mut self.idfa
    }

    // Take field
    pub fn take_idfa(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.idfa, ::std::string::String::new())
    }

    // int64 timezone = 6;


    pub fn get_timezone(&self) -> i64 {
        self.timezone
    }
    pub fn clear_timezone(&mut self) {
        self.timezone = 0;
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: i64) {
        self.timezone = v;
    }

    // .PBAccount account = 7;


    pub fn get_account(&self) -> &PBAccount {
        self.account.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: PBAccount) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut PBAccount {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> PBAccount {
        self.account.take().unwrap_or_else(|| PBAccount::new())
    }

    // .PBLoginType loginType = 8;


    pub fn get_loginType(&self) -> PBLoginType {
        self.loginType
    }
    pub fn clear_loginType(&mut self) {
        self.loginType = PBLoginType::PBLoginType_App;
    }

    // Param is passed by value, moved
    pub fn set_loginType(&mut self, v: PBLoginType) {
        self.loginType = v;
    }

    // string cookie = 9;


    pub fn get_cookie(&self) -> &str {
        &self.cookie
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        &mut self.cookie
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cookie, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBLoginRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.countryName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.countryCode)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.preferredLang)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.idfa)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timezone = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.loginType, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appVersion);
        }
        if !self.countryName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.countryName);
        }
        if !self.countryCode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.countryCode);
        }
        if !self.preferredLang.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.preferredLang);
        }
        if !self.idfa.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.idfa);
        }
        if self.timezone != 0 {
            my_size += ::protobuf::rt::value_size(6, self.timezone, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.loginType != PBLoginType::PBLoginType_App {
            my_size += ::protobuf::rt::enum_size(8, self.loginType);
        }
        if !self.cookie.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.cookie);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appVersion.is_empty() {
            os.write_string(1, &self.appVersion)?;
        }
        if !self.countryName.is_empty() {
            os.write_string(2, &self.countryName)?;
        }
        if !self.countryCode.is_empty() {
            os.write_string(3, &self.countryCode)?;
        }
        if !self.preferredLang.is_empty() {
            os.write_string(4, &self.preferredLang)?;
        }
        if !self.idfa.is_empty() {
            os.write_string(5, &self.idfa)?;
        }
        if self.timezone != 0 {
            os.write_int64(6, self.timezone)?;
        }
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.loginType != PBLoginType::PBLoginType_App {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.loginType))?;
        }
        if !self.cookie.is_empty() {
            os.write_string(9, &self.cookie)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBLoginRequest {
        PBLoginRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appVersion",
                |m: &PBLoginRequest| { &m.appVersion },
                |m: &mut PBLoginRequest| { &mut m.appVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "countryName",
                |m: &PBLoginRequest| { &m.countryName },
                |m: &mut PBLoginRequest| { &mut m.countryName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "countryCode",
                |m: &PBLoginRequest| { &m.countryCode },
                |m: &mut PBLoginRequest| { &mut m.countryCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preferredLang",
                |m: &PBLoginRequest| { &m.preferredLang },
                |m: &mut PBLoginRequest| { &mut m.preferredLang },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "idfa",
                |m: &PBLoginRequest| { &m.idfa },
                |m: &mut PBLoginRequest| { &mut m.idfa },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timezone",
                |m: &PBLoginRequest| { &m.timezone },
                |m: &mut PBLoginRequest| { &mut m.timezone },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "account",
                |m: &PBLoginRequest| { &m.account },
                |m: &mut PBLoginRequest| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBLoginType>>(
                "loginType",
                |m: &PBLoginRequest| { &m.loginType },
                |m: &mut PBLoginRequest| { &mut m.loginType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cookie",
                |m: &PBLoginRequest| { &m.cookie },
                |m: &mut PBLoginRequest| { &mut m.cookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBLoginRequest>(
                "PBLoginRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBLoginRequest {
        static instance: ::protobuf::rt::LazyV2<PBLoginRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBLoginRequest::new)
    }
}

impl ::protobuf::Clear for PBLoginRequest {
    fn clear(&mut self) {
        self.appVersion.clear();
        self.countryName.clear();
        self.countryCode.clear();
        self.preferredLang.clear();
        self.idfa.clear();
        self.timezone = 0;
        self.account.clear();
        self.loginType = PBLoginType::PBLoginType_App;
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBLoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLoginRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBLoginReply {
    // message fields
    pub createTs: i64,
    pub isOldVIP: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBLoginReply {
    fn default() -> &'a PBLoginReply {
        <PBLoginReply as ::protobuf::Message>::default_instance()
    }
}

impl PBLoginReply {
    pub fn new() -> PBLoginReply {
        ::std::default::Default::default()
    }

    // int64 createTs = 1;


    pub fn get_createTs(&self) -> i64 {
        self.createTs
    }
    pub fn clear_createTs(&mut self) {
        self.createTs = 0;
    }

    // Param is passed by value, moved
    pub fn set_createTs(&mut self, v: i64) {
        self.createTs = v;
    }

    // bool isOldVIP = 2;


    pub fn get_isOldVIP(&self) -> bool {
        self.isOldVIP
    }
    pub fn clear_isOldVIP(&mut self) {
        self.isOldVIP = false;
    }

    // Param is passed by value, moved
    pub fn set_isOldVIP(&mut self, v: bool) {
        self.isOldVIP = v;
    }
}

impl ::protobuf::Message for PBLoginReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createTs = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isOldVIP = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.createTs != 0 {
            my_size += ::protobuf::rt::value_size(1, self.createTs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isOldVIP != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.createTs != 0 {
            os.write_int64(1, self.createTs)?;
        }
        if self.isOldVIP != false {
            os.write_bool(2, self.isOldVIP)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBLoginReply {
        PBLoginReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createTs",
                |m: &PBLoginReply| { &m.createTs },
                |m: &mut PBLoginReply| { &mut m.createTs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isOldVIP",
                |m: &PBLoginReply| { &m.isOldVIP },
                |m: &mut PBLoginReply| { &mut m.isOldVIP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBLoginReply>(
                "PBLoginReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBLoginReply {
        static instance: ::protobuf::rt::LazyV2<PBLoginReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBLoginReply::new)
    }
}

impl ::protobuf::Clear for PBLoginReply {
    fn clear(&mut self) {
        self.createTs = 0;
        self.isOldVIP = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBLoginReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLoginReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBLogoutRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBLogoutRequest {
    fn default() -> &'a PBLogoutRequest {
        <PBLogoutRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBLogoutRequest {
    pub fn new() -> PBLogoutRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBLogoutRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBLogoutRequest {
        PBLogoutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBLogoutRequest>(
                "PBLogoutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBLogoutRequest {
        static instance: ::protobuf::rt::LazyV2<PBLogoutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBLogoutRequest::new)
    }
}

impl ::protobuf::Clear for PBLogoutRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBLogoutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLogoutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBLogoutReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBLogoutReply {
    fn default() -> &'a PBLogoutReply {
        <PBLogoutReply as ::protobuf::Message>::default_instance()
    }
}

impl PBLogoutReply {
    pub fn new() -> PBLogoutReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBLogoutReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBLogoutReply {
        PBLogoutReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBLogoutReply>(
                "PBLogoutReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBLogoutReply {
        static instance: ::protobuf::rt::LazyV2<PBLogoutReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBLogoutReply::new)
    }
}

impl ::protobuf::Clear for PBLogoutReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBLogoutReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLogoutReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBRefreshConnectionRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<PBAccount>,
    pub loginType: PBLoginType,
    pub appVersion: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBRefreshConnectionRequest {
    fn default() -> &'a PBRefreshConnectionRequest {
        <PBRefreshConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBRefreshConnectionRequest {
    pub fn new() -> PBRefreshConnectionRequest {
        ::std::default::Default::default()
    }

    // .PBAccount account = 1;


    pub fn get_account(&self) -> &PBAccount {
        self.account.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: PBAccount) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut PBAccount {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> PBAccount {
        self.account.take().unwrap_or_else(|| PBAccount::new())
    }

    // .PBLoginType loginType = 2;


    pub fn get_loginType(&self) -> PBLoginType {
        self.loginType
    }
    pub fn clear_loginType(&mut self) {
        self.loginType = PBLoginType::PBLoginType_App;
    }

    // Param is passed by value, moved
    pub fn set_loginType(&mut self, v: PBLoginType) {
        self.loginType = v;
    }

    // string appVersion = 3;


    pub fn get_appVersion(&self) -> &str {
        &self.appVersion
    }
    pub fn clear_appVersion(&mut self) {
        self.appVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_appVersion(&mut self, v: ::std::string::String) {
        self.appVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appVersion(&mut self) -> &mut ::std::string::String {
        &mut self.appVersion
    }

    // Take field
    pub fn take_appVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appVersion, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBRefreshConnectionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.loginType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.loginType != PBLoginType::PBLoginType_App {
            my_size += ::protobuf::rt::enum_size(2, self.loginType);
        }
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.appVersion);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.loginType != PBLoginType::PBLoginType_App {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.loginType))?;
        }
        if !self.appVersion.is_empty() {
            os.write_string(3, &self.appVersion)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBRefreshConnectionRequest {
        PBRefreshConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "account",
                |m: &PBRefreshConnectionRequest| { &m.account },
                |m: &mut PBRefreshConnectionRequest| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBLoginType>>(
                "loginType",
                |m: &PBRefreshConnectionRequest| { &m.loginType },
                |m: &mut PBRefreshConnectionRequest| { &mut m.loginType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appVersion",
                |m: &PBRefreshConnectionRequest| { &m.appVersion },
                |m: &mut PBRefreshConnectionRequest| { &mut m.appVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBRefreshConnectionRequest>(
                "PBRefreshConnectionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBRefreshConnectionRequest {
        static instance: ::protobuf::rt::LazyV2<PBRefreshConnectionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBRefreshConnectionRequest::new)
    }
}

impl ::protobuf::Clear for PBRefreshConnectionRequest {
    fn clear(&mut self) {
        self.account.clear();
        self.loginType = PBLoginType::PBLoginType_App;
        self.appVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBRefreshConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBRefreshConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBRefreshConnectionReply {
    // message fields
    pub createTs: i64,
    pub isOldVIP: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBRefreshConnectionReply {
    fn default() -> &'a PBRefreshConnectionReply {
        <PBRefreshConnectionReply as ::protobuf::Message>::default_instance()
    }
}

impl PBRefreshConnectionReply {
    pub fn new() -> PBRefreshConnectionReply {
        ::std::default::Default::default()
    }

    // int64 createTs = 1;


    pub fn get_createTs(&self) -> i64 {
        self.createTs
    }
    pub fn clear_createTs(&mut self) {
        self.createTs = 0;
    }

    // Param is passed by value, moved
    pub fn set_createTs(&mut self, v: i64) {
        self.createTs = v;
    }

    // bool isOldVIP = 2;


    pub fn get_isOldVIP(&self) -> bool {
        self.isOldVIP
    }
    pub fn clear_isOldVIP(&mut self) {
        self.isOldVIP = false;
    }

    // Param is passed by value, moved
    pub fn set_isOldVIP(&mut self, v: bool) {
        self.isOldVIP = v;
    }
}

impl ::protobuf::Message for PBRefreshConnectionReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createTs = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isOldVIP = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.createTs != 0 {
            my_size += ::protobuf::rt::value_size(1, self.createTs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isOldVIP != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.createTs != 0 {
            os.write_int64(1, self.createTs)?;
        }
        if self.isOldVIP != false {
            os.write_bool(2, self.isOldVIP)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBRefreshConnectionReply {
        PBRefreshConnectionReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createTs",
                |m: &PBRefreshConnectionReply| { &m.createTs },
                |m: &mut PBRefreshConnectionReply| { &mut m.createTs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isOldVIP",
                |m: &PBRefreshConnectionReply| { &m.isOldVIP },
                |m: &mut PBRefreshConnectionReply| { &mut m.isOldVIP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBRefreshConnectionReply>(
                "PBRefreshConnectionReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBRefreshConnectionReply {
        static instance: ::protobuf::rt::LazyV2<PBRefreshConnectionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBRefreshConnectionReply::new)
    }
}

impl ::protobuf::Clear for PBRefreshConnectionReply {
    fn clear(&mut self) {
        self.createTs = 0;
        self.isOldVIP = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBRefreshConnectionReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBRefreshConnectionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntroductoryOffer {
    // message fields
    pub paymentOption: IntroductoryOfferPaymentOption,
    pub durationInDays: i64,
    pub priceInUSD: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntroductoryOffer {
    fn default() -> &'a IntroductoryOffer {
        <IntroductoryOffer as ::protobuf::Message>::default_instance()
    }
}

impl IntroductoryOffer {
    pub fn new() -> IntroductoryOffer {
        ::std::default::Default::default()
    }

    // .IntroductoryOfferPaymentOption paymentOption = 1;


    pub fn get_paymentOption(&self) -> IntroductoryOfferPaymentOption {
        self.paymentOption
    }
    pub fn clear_paymentOption(&mut self) {
        self.paymentOption = IntroductoryOfferPaymentOption::freeTrial;
    }

    // Param is passed by value, moved
    pub fn set_paymentOption(&mut self, v: IntroductoryOfferPaymentOption) {
        self.paymentOption = v;
    }

    // int64 durationInDays = 2;


    pub fn get_durationInDays(&self) -> i64 {
        self.durationInDays
    }
    pub fn clear_durationInDays(&mut self) {
        self.durationInDays = 0;
    }

    // Param is passed by value, moved
    pub fn set_durationInDays(&mut self, v: i64) {
        self.durationInDays = v;
    }

    // double priceInUSD = 3;


    pub fn get_priceInUSD(&self) -> f64 {
        self.priceInUSD
    }
    pub fn clear_priceInUSD(&mut self) {
        self.priceInUSD = 0.;
    }

    // Param is passed by value, moved
    pub fn set_priceInUSD(&mut self, v: f64) {
        self.priceInUSD = v;
    }
}

impl ::protobuf::Message for IntroductoryOffer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.paymentOption, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.durationInDays = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.priceInUSD = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.paymentOption != IntroductoryOfferPaymentOption::freeTrial {
            my_size += ::protobuf::rt::enum_size(1, self.paymentOption);
        }
        if self.durationInDays != 0 {
            my_size += ::protobuf::rt::value_size(2, self.durationInDays, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.priceInUSD != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.paymentOption != IntroductoryOfferPaymentOption::freeTrial {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.paymentOption))?;
        }
        if self.durationInDays != 0 {
            os.write_int64(2, self.durationInDays)?;
        }
        if self.priceInUSD != 0. {
            os.write_double(3, self.priceInUSD)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntroductoryOffer {
        IntroductoryOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IntroductoryOfferPaymentOption>>(
                "paymentOption",
                |m: &IntroductoryOffer| { &m.paymentOption },
                |m: &mut IntroductoryOffer| { &mut m.paymentOption },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "durationInDays",
                |m: &IntroductoryOffer| { &m.durationInDays },
                |m: &mut IntroductoryOffer| { &mut m.durationInDays },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "priceInUSD",
                |m: &IntroductoryOffer| { &m.priceInUSD },
                |m: &mut IntroductoryOffer| { &mut m.priceInUSD },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntroductoryOffer>(
                "IntroductoryOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IntroductoryOffer {
        static instance: ::protobuf::rt::LazyV2<IntroductoryOffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IntroductoryOffer::new)
    }
}

impl ::protobuf::Clear for IntroductoryOffer {
    fn clear(&mut self) {
        self.paymentOption = IntroductoryOfferPaymentOption::freeTrial;
        self.durationInDays = 0;
        self.priceInUSD = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntroductoryOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntroductoryOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PromotionalOffer {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PromotionalOffer {
    fn default() -> &'a PromotionalOffer {
        <PromotionalOffer as ::protobuf::Message>::default_instance()
    }
}

impl PromotionalOffer {
    pub fn new() -> PromotionalOffer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PromotionalOffer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PromotionalOffer {
        PromotionalOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PromotionalOffer>(
                "PromotionalOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PromotionalOffer {
        static instance: ::protobuf::rt::LazyV2<PromotionalOffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PromotionalOffer::new)
    }
}

impl ::protobuf::Clear for PromotionalOffer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PromotionalOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromotionalOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBProduct {
    // message fields
    pub productID: ::std::string::String,
    pub price: i64,
    pub months: i64,
    pub billingCycle: BillingCycle,
    pub standardPriceInUSD: f64,
    pub discountDescription: i64,
    pub introductoryOffer: ::protobuf::SingularPtrField<IntroductoryOffer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBProduct {
    fn default() -> &'a PBProduct {
        <PBProduct as ::protobuf::Message>::default_instance()
    }
}

impl PBProduct {
    pub fn new() -> PBProduct {
        ::std::default::Default::default()
    }

    // string productID = 1;


    pub fn get_productID(&self) -> &str {
        &self.productID
    }
    pub fn clear_productID(&mut self) {
        self.productID.clear();
    }

    // Param is passed by value, moved
    pub fn set_productID(&mut self, v: ::std::string::String) {
        self.productID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productID(&mut self) -> &mut ::std::string::String {
        &mut self.productID
    }

    // Take field
    pub fn take_productID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.productID, ::std::string::String::new())
    }

    // int64 price = 2;


    pub fn get_price(&self) -> i64 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: i64) {
        self.price = v;
    }

    // int64 months = 3;


    pub fn get_months(&self) -> i64 {
        self.months
    }
    pub fn clear_months(&mut self) {
        self.months = 0;
    }

    // Param is passed by value, moved
    pub fn set_months(&mut self, v: i64) {
        self.months = v;
    }

    // .BillingCycle billingCycle = 4;


    pub fn get_billingCycle(&self) -> BillingCycle {
        self.billingCycle
    }
    pub fn clear_billingCycle(&mut self) {
        self.billingCycle = BillingCycle::weekly;
    }

    // Param is passed by value, moved
    pub fn set_billingCycle(&mut self, v: BillingCycle) {
        self.billingCycle = v;
    }

    // double standardPriceInUSD = 5;


    pub fn get_standardPriceInUSD(&self) -> f64 {
        self.standardPriceInUSD
    }
    pub fn clear_standardPriceInUSD(&mut self) {
        self.standardPriceInUSD = 0.;
    }

    // Param is passed by value, moved
    pub fn set_standardPriceInUSD(&mut self, v: f64) {
        self.standardPriceInUSD = v;
    }

    // int64 discountDescription = 6;


    pub fn get_discountDescription(&self) -> i64 {
        self.discountDescription
    }
    pub fn clear_discountDescription(&mut self) {
        self.discountDescription = 0;
    }

    // Param is passed by value, moved
    pub fn set_discountDescription(&mut self, v: i64) {
        self.discountDescription = v;
    }

    // .IntroductoryOffer introductoryOffer = 7;


    pub fn get_introductoryOffer(&self) -> &IntroductoryOffer {
        self.introductoryOffer.as_ref().unwrap_or_else(|| <IntroductoryOffer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_introductoryOffer(&mut self) {
        self.introductoryOffer.clear();
    }

    pub fn has_introductoryOffer(&self) -> bool {
        self.introductoryOffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_introductoryOffer(&mut self, v: IntroductoryOffer) {
        self.introductoryOffer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_introductoryOffer(&mut self) -> &mut IntroductoryOffer {
        if self.introductoryOffer.is_none() {
            self.introductoryOffer.set_default();
        }
        self.introductoryOffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_introductoryOffer(&mut self) -> IntroductoryOffer {
        self.introductoryOffer.take().unwrap_or_else(|| IntroductoryOffer::new())
    }
}

impl ::protobuf::Message for PBProduct {
    fn is_initialized(&self) -> bool {
        for v in &self.introductoryOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.productID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.price = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.months = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.billingCycle, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.standardPriceInUSD = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.discountDescription = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.introductoryOffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.productID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.productID);
        }
        if self.price != 0 {
            my_size += ::protobuf::rt::value_size(2, self.price, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.months != 0 {
            my_size += ::protobuf::rt::value_size(3, self.months, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.billingCycle != BillingCycle::weekly {
            my_size += ::protobuf::rt::enum_size(4, self.billingCycle);
        }
        if self.standardPriceInUSD != 0. {
            my_size += 9;
        }
        if self.discountDescription != 0 {
            my_size += ::protobuf::rt::value_size(6, self.discountDescription, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.introductoryOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.productID.is_empty() {
            os.write_string(1, &self.productID)?;
        }
        if self.price != 0 {
            os.write_int64(2, self.price)?;
        }
        if self.months != 0 {
            os.write_int64(3, self.months)?;
        }
        if self.billingCycle != BillingCycle::weekly {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.billingCycle))?;
        }
        if self.standardPriceInUSD != 0. {
            os.write_double(5, self.standardPriceInUSD)?;
        }
        if self.discountDescription != 0 {
            os.write_int64(6, self.discountDescription)?;
        }
        if let Some(ref v) = self.introductoryOffer.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBProduct {
        PBProduct::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productID",
                |m: &PBProduct| { &m.productID },
                |m: &mut PBProduct| { &mut m.productID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "price",
                |m: &PBProduct| { &m.price },
                |m: &mut PBProduct| { &mut m.price },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "months",
                |m: &PBProduct| { &m.months },
                |m: &mut PBProduct| { &mut m.months },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BillingCycle>>(
                "billingCycle",
                |m: &PBProduct| { &m.billingCycle },
                |m: &mut PBProduct| { &mut m.billingCycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "standardPriceInUSD",
                |m: &PBProduct| { &m.standardPriceInUSD },
                |m: &mut PBProduct| { &mut m.standardPriceInUSD },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "discountDescription",
                |m: &PBProduct| { &m.discountDescription },
                |m: &mut PBProduct| { &mut m.discountDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntroductoryOffer>>(
                "introductoryOffer",
                |m: &PBProduct| { &m.introductoryOffer },
                |m: &mut PBProduct| { &mut m.introductoryOffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBProduct>(
                "PBProduct",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBProduct {
        static instance: ::protobuf::rt::LazyV2<PBProduct> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBProduct::new)
    }
}

impl ::protobuf::Clear for PBProduct {
    fn clear(&mut self) {
        self.productID.clear();
        self.price = 0;
        self.months = 0;
        self.billingCycle = BillingCycle::weekly;
        self.standardPriceInUSD = 0.;
        self.discountDescription = 0;
        self.introductoryOffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBProduct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBProduct {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchProductsRequest {
    // message fields
    pub appVersion: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchProductsRequest {
    fn default() -> &'a PBFetchProductsRequest {
        <PBFetchProductsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchProductsRequest {
    pub fn new() -> PBFetchProductsRequest {
        ::std::default::Default::default()
    }

    // string appVersion = 1;


    pub fn get_appVersion(&self) -> &str {
        &self.appVersion
    }
    pub fn clear_appVersion(&mut self) {
        self.appVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_appVersion(&mut self, v: ::std::string::String) {
        self.appVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appVersion(&mut self) -> &mut ::std::string::String {
        &mut self.appVersion
    }

    // Take field
    pub fn take_appVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appVersion, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBFetchProductsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appVersion);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appVersion.is_empty() {
            os.write_string(1, &self.appVersion)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchProductsRequest {
        PBFetchProductsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appVersion",
                |m: &PBFetchProductsRequest| { &m.appVersion },
                |m: &mut PBFetchProductsRequest| { &mut m.appVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchProductsRequest>(
                "PBFetchProductsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchProductsRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchProductsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchProductsRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchProductsRequest {
    fn clear(&mut self) {
        self.appVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchProductsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchProductsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchProductsReply {
    // message fields
    pub products: ::protobuf::RepeatedField<PBProduct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchProductsReply {
    fn default() -> &'a PBFetchProductsReply {
        <PBFetchProductsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchProductsReply {
    pub fn new() -> PBFetchProductsReply {
        ::std::default::Default::default()
    }

    // repeated .PBProduct products = 1;


    pub fn get_products(&self) -> &[PBProduct] {
        &self.products
    }
    pub fn clear_products(&mut self) {
        self.products.clear();
    }

    // Param is passed by value, moved
    pub fn set_products(&mut self, v: ::protobuf::RepeatedField<PBProduct>) {
        self.products = v;
    }

    // Mutable pointer to the field.
    pub fn mut_products(&mut self) -> &mut ::protobuf::RepeatedField<PBProduct> {
        &mut self.products
    }

    // Take field
    pub fn take_products(&mut self) -> ::protobuf::RepeatedField<PBProduct> {
        ::std::mem::replace(&mut self.products, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchProductsReply {
    fn is_initialized(&self) -> bool {
        for v in &self.products {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.products)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.products {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.products {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchProductsReply {
        PBFetchProductsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBProduct>>(
                "products",
                |m: &PBFetchProductsReply| { &m.products },
                |m: &mut PBFetchProductsReply| { &mut m.products },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchProductsReply>(
                "PBFetchProductsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchProductsReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchProductsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchProductsReply::new)
    }
}

impl ::protobuf::Clear for PBFetchProductsReply {
    fn clear(&mut self) {
        self.products.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchProductsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchProductsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBAccount {
    // message fields
    pub accountID: ::std::string::String,
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub isPrivateAccount: bool,
    pub mediaCount: i64,
    pub followingCount: i64,
    pub followerCount: i64,
    pub fullName: ::std::string::String,
    pub avatarURLString: ::std::string::String,
    pub gender: i64,
    pub emailAddress: ::std::string::String,
    pub biography: ::std::string::String,
    pub websiteURLString: ::std::string::String,
    pub countryCode: ::std::string::String,
    pub location: ::protobuf::SingularPtrField<PBLocation>,
    pub relationshipToThisAccount: PBRelationship,
    pub recentMedias: ::protobuf::RepeatedField<PBMedia>,
    pub relationshipFromThisAccount: PBRelationship,
    pub phoneNumber: ::std::string::String,
    pub needToUpdateBasicInfo: bool,
    pub needToUpdateMedias: bool,
    pub charmValue: f64,
    pub hasAnonymousProfilePicture: bool,
    pub accountLoginType: PBAccountLoginType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBAccount {
    fn default() -> &'a PBAccount {
        <PBAccount as ::protobuf::Message>::default_instance()
    }
}

impl PBAccount {
    pub fn new() -> PBAccount {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string username = 2;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // bool isPrivateAccount = 4;


    pub fn get_isPrivateAccount(&self) -> bool {
        self.isPrivateAccount
    }
    pub fn clear_isPrivateAccount(&mut self) {
        self.isPrivateAccount = false;
    }

    // Param is passed by value, moved
    pub fn set_isPrivateAccount(&mut self, v: bool) {
        self.isPrivateAccount = v;
    }

    // int64 mediaCount = 5;


    pub fn get_mediaCount(&self) -> i64 {
        self.mediaCount
    }
    pub fn clear_mediaCount(&mut self) {
        self.mediaCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_mediaCount(&mut self, v: i64) {
        self.mediaCount = v;
    }

    // int64 followingCount = 6;


    pub fn get_followingCount(&self) -> i64 {
        self.followingCount
    }
    pub fn clear_followingCount(&mut self) {
        self.followingCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_followingCount(&mut self, v: i64) {
        self.followingCount = v;
    }

    // int64 followerCount = 7;


    pub fn get_followerCount(&self) -> i64 {
        self.followerCount
    }
    pub fn clear_followerCount(&mut self) {
        self.followerCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_followerCount(&mut self, v: i64) {
        self.followerCount = v;
    }

    // string fullName = 8;


    pub fn get_fullName(&self) -> &str {
        &self.fullName
    }
    pub fn clear_fullName(&mut self) {
        self.fullName.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullName(&mut self, v: ::std::string::String) {
        self.fullName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullName(&mut self) -> &mut ::std::string::String {
        &mut self.fullName
    }

    // Take field
    pub fn take_fullName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullName, ::std::string::String::new())
    }

    // string avatarURLString = 9;


    pub fn get_avatarURLString(&self) -> &str {
        &self.avatarURLString
    }
    pub fn clear_avatarURLString(&mut self) {
        self.avatarURLString.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatarURLString(&mut self, v: ::std::string::String) {
        self.avatarURLString = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatarURLString(&mut self) -> &mut ::std::string::String {
        &mut self.avatarURLString
    }

    // Take field
    pub fn take_avatarURLString(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatarURLString, ::std::string::String::new())
    }

    // int64 gender = 10;


    pub fn get_gender(&self) -> i64 {
        self.gender
    }
    pub fn clear_gender(&mut self) {
        self.gender = 0;
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: i64) {
        self.gender = v;
    }

    // string emailAddress = 11;


    pub fn get_emailAddress(&self) -> &str {
        &self.emailAddress
    }
    pub fn clear_emailAddress(&mut self) {
        self.emailAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_emailAddress(&mut self, v: ::std::string::String) {
        self.emailAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emailAddress(&mut self) -> &mut ::std::string::String {
        &mut self.emailAddress
    }

    // Take field
    pub fn take_emailAddress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.emailAddress, ::std::string::String::new())
    }

    // string biography = 12;


    pub fn get_biography(&self) -> &str {
        &self.biography
    }
    pub fn clear_biography(&mut self) {
        self.biography.clear();
    }

    // Param is passed by value, moved
    pub fn set_biography(&mut self, v: ::std::string::String) {
        self.biography = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_biography(&mut self) -> &mut ::std::string::String {
        &mut self.biography
    }

    // Take field
    pub fn take_biography(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.biography, ::std::string::String::new())
    }

    // string websiteURLString = 13;


    pub fn get_websiteURLString(&self) -> &str {
        &self.websiteURLString
    }
    pub fn clear_websiteURLString(&mut self) {
        self.websiteURLString.clear();
    }

    // Param is passed by value, moved
    pub fn set_websiteURLString(&mut self, v: ::std::string::String) {
        self.websiteURLString = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_websiteURLString(&mut self) -> &mut ::std::string::String {
        &mut self.websiteURLString
    }

    // Take field
    pub fn take_websiteURLString(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.websiteURLString, ::std::string::String::new())
    }

    // string countryCode = 14;


    pub fn get_countryCode(&self) -> &str {
        &self.countryCode
    }
    pub fn clear_countryCode(&mut self) {
        self.countryCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_countryCode(&mut self, v: ::std::string::String) {
        self.countryCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_countryCode(&mut self) -> &mut ::std::string::String {
        &mut self.countryCode
    }

    // Take field
    pub fn take_countryCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.countryCode, ::std::string::String::new())
    }

    // .PBLocation location = 15;


    pub fn get_location(&self) -> &PBLocation {
        self.location.as_ref().unwrap_or_else(|| <PBLocation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: PBLocation) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut PBLocation {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> PBLocation {
        self.location.take().unwrap_or_else(|| PBLocation::new())
    }

    // .PBRelationship relationshipToThisAccount = 16;


    pub fn get_relationshipToThisAccount(&self) -> PBRelationship {
        self.relationshipToThisAccount
    }
    pub fn clear_relationshipToThisAccount(&mut self) {
        self.relationshipToThisAccount = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_relationshipToThisAccount(&mut self, v: PBRelationship) {
        self.relationshipToThisAccount = v;
    }

    // repeated .PBMedia recentMedias = 17;


    pub fn get_recentMedias(&self) -> &[PBMedia] {
        &self.recentMedias
    }
    pub fn clear_recentMedias(&mut self) {
        self.recentMedias.clear();
    }

    // Param is passed by value, moved
    pub fn set_recentMedias(&mut self, v: ::protobuf::RepeatedField<PBMedia>) {
        self.recentMedias = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recentMedias(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia> {
        &mut self.recentMedias
    }

    // Take field
    pub fn take_recentMedias(&mut self) -> ::protobuf::RepeatedField<PBMedia> {
        ::std::mem::replace(&mut self.recentMedias, ::protobuf::RepeatedField::new())
    }

    // .PBRelationship relationshipFromThisAccount = 18;


    pub fn get_relationshipFromThisAccount(&self) -> PBRelationship {
        self.relationshipFromThisAccount
    }
    pub fn clear_relationshipFromThisAccount(&mut self) {
        self.relationshipFromThisAccount = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_relationshipFromThisAccount(&mut self, v: PBRelationship) {
        self.relationshipFromThisAccount = v;
    }

    // string phoneNumber = 19;


    pub fn get_phoneNumber(&self) -> &str {
        &self.phoneNumber
    }
    pub fn clear_phoneNumber(&mut self) {
        self.phoneNumber.clear();
    }

    // Param is passed by value, moved
    pub fn set_phoneNumber(&mut self, v: ::std::string::String) {
        self.phoneNumber = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phoneNumber(&mut self) -> &mut ::std::string::String {
        &mut self.phoneNumber
    }

    // Take field
    pub fn take_phoneNumber(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.phoneNumber, ::std::string::String::new())
    }

    // bool needToUpdateBasicInfo = 20;


    pub fn get_needToUpdateBasicInfo(&self) -> bool {
        self.needToUpdateBasicInfo
    }
    pub fn clear_needToUpdateBasicInfo(&mut self) {
        self.needToUpdateBasicInfo = false;
    }

    // Param is passed by value, moved
    pub fn set_needToUpdateBasicInfo(&mut self, v: bool) {
        self.needToUpdateBasicInfo = v;
    }

    // bool needToUpdateMedias = 21;


    pub fn get_needToUpdateMedias(&self) -> bool {
        self.needToUpdateMedias
    }
    pub fn clear_needToUpdateMedias(&mut self) {
        self.needToUpdateMedias = false;
    }

    // Param is passed by value, moved
    pub fn set_needToUpdateMedias(&mut self, v: bool) {
        self.needToUpdateMedias = v;
    }

    // double charmValue = 22;


    pub fn get_charmValue(&self) -> f64 {
        self.charmValue
    }
    pub fn clear_charmValue(&mut self) {
        self.charmValue = 0.;
    }

    // Param is passed by value, moved
    pub fn set_charmValue(&mut self, v: f64) {
        self.charmValue = v;
    }

    // bool hasAnonymousProfilePicture = 23;


    pub fn get_hasAnonymousProfilePicture(&self) -> bool {
        self.hasAnonymousProfilePicture
    }
    pub fn clear_hasAnonymousProfilePicture(&mut self) {
        self.hasAnonymousProfilePicture = false;
    }

    // Param is passed by value, moved
    pub fn set_hasAnonymousProfilePicture(&mut self, v: bool) {
        self.hasAnonymousProfilePicture = v;
    }

    // .PBAccountLoginType accountLoginType = 24;


    pub fn get_accountLoginType(&self) -> PBAccountLoginType {
        self.accountLoginType
    }
    pub fn clear_accountLoginType(&mut self) {
        self.accountLoginType = PBAccountLoginType::InstagramLogin;
    }

    // Param is passed by value, moved
    pub fn set_accountLoginType(&mut self, v: PBAccountLoginType) {
        self.accountLoginType = v;
    }
}

impl ::protobuf::Message for PBAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recentMedias {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isPrivateAccount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.mediaCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.followingCount = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.followerCount = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatarURLString)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gender = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.emailAddress)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.biography)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.websiteURLString)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.countryCode)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                16 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.relationshipToThisAccount, 16, &mut self.unknown_fields)?
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.recentMedias)?;
                },
                18 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.relationshipFromThisAccount, 18, &mut self.unknown_fields)?
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.phoneNumber)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needToUpdateBasicInfo = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needToUpdateMedias = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.charmValue = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasAnonymousProfilePicture = tmp;
                },
                24 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.accountLoginType, 24, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        if self.isPrivateAccount != false {
            my_size += 2;
        }
        if self.mediaCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.mediaCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.followingCount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.followingCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.followerCount != 0 {
            my_size += ::protobuf::rt::value_size(7, self.followerCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fullName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fullName);
        }
        if !self.avatarURLString.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.avatarURLString);
        }
        if self.gender != 0 {
            my_size += ::protobuf::rt::value_size(10, self.gender, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.emailAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.emailAddress);
        }
        if !self.biography.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.biography);
        }
        if !self.websiteURLString.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.websiteURLString);
        }
        if !self.countryCode.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.countryCode);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.relationshipToThisAccount != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(16, self.relationshipToThisAccount);
        }
        for value in &self.recentMedias {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.relationshipFromThisAccount != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(18, self.relationshipFromThisAccount);
        }
        if !self.phoneNumber.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.phoneNumber);
        }
        if self.needToUpdateBasicInfo != false {
            my_size += 3;
        }
        if self.needToUpdateMedias != false {
            my_size += 3;
        }
        if self.charmValue != 0. {
            my_size += 10;
        }
        if self.hasAnonymousProfilePicture != false {
            my_size += 3;
        }
        if self.accountLoginType != PBAccountLoginType::InstagramLogin {
            my_size += ::protobuf::rt::enum_size(24, self.accountLoginType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        if self.isPrivateAccount != false {
            os.write_bool(4, self.isPrivateAccount)?;
        }
        if self.mediaCount != 0 {
            os.write_int64(5, self.mediaCount)?;
        }
        if self.followingCount != 0 {
            os.write_int64(6, self.followingCount)?;
        }
        if self.followerCount != 0 {
            os.write_int64(7, self.followerCount)?;
        }
        if !self.fullName.is_empty() {
            os.write_string(8, &self.fullName)?;
        }
        if !self.avatarURLString.is_empty() {
            os.write_string(9, &self.avatarURLString)?;
        }
        if self.gender != 0 {
            os.write_int64(10, self.gender)?;
        }
        if !self.emailAddress.is_empty() {
            os.write_string(11, &self.emailAddress)?;
        }
        if !self.biography.is_empty() {
            os.write_string(12, &self.biography)?;
        }
        if !self.websiteURLString.is_empty() {
            os.write_string(13, &self.websiteURLString)?;
        }
        if !self.countryCode.is_empty() {
            os.write_string(14, &self.countryCode)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.relationshipToThisAccount != PBRelationship::PBRelationship_Null {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(&self.relationshipToThisAccount))?;
        }
        for v in &self.recentMedias {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.relationshipFromThisAccount != PBRelationship::PBRelationship_Null {
            os.write_enum(18, ::protobuf::ProtobufEnum::value(&self.relationshipFromThisAccount))?;
        }
        if !self.phoneNumber.is_empty() {
            os.write_string(19, &self.phoneNumber)?;
        }
        if self.needToUpdateBasicInfo != false {
            os.write_bool(20, self.needToUpdateBasicInfo)?;
        }
        if self.needToUpdateMedias != false {
            os.write_bool(21, self.needToUpdateMedias)?;
        }
        if self.charmValue != 0. {
            os.write_double(22, self.charmValue)?;
        }
        if self.hasAnonymousProfilePicture != false {
            os.write_bool(23, self.hasAnonymousProfilePicture)?;
        }
        if self.accountLoginType != PBAccountLoginType::InstagramLogin {
            os.write_enum(24, ::protobuf::ProtobufEnum::value(&self.accountLoginType))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBAccount {
        PBAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBAccount| { &m.accountID },
                |m: &mut PBAccount| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &PBAccount| { &m.username },
                |m: &mut PBAccount| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &PBAccount| { &m.password },
                |m: &mut PBAccount| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isPrivateAccount",
                |m: &PBAccount| { &m.isPrivateAccount },
                |m: &mut PBAccount| { &mut m.isPrivateAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "mediaCount",
                |m: &PBAccount| { &m.mediaCount },
                |m: &mut PBAccount| { &mut m.mediaCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "followingCount",
                |m: &PBAccount| { &m.followingCount },
                |m: &mut PBAccount| { &mut m.followingCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "followerCount",
                |m: &PBAccount| { &m.followerCount },
                |m: &mut PBAccount| { &mut m.followerCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullName",
                |m: &PBAccount| { &m.fullName },
                |m: &mut PBAccount| { &mut m.fullName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatarURLString",
                |m: &PBAccount| { &m.avatarURLString },
                |m: &mut PBAccount| { &mut m.avatarURLString },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "gender",
                |m: &PBAccount| { &m.gender },
                |m: &mut PBAccount| { &mut m.gender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emailAddress",
                |m: &PBAccount| { &m.emailAddress },
                |m: &mut PBAccount| { &mut m.emailAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "biography",
                |m: &PBAccount| { &m.biography },
                |m: &mut PBAccount| { &mut m.biography },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "websiteURLString",
                |m: &PBAccount| { &m.websiteURLString },
                |m: &mut PBAccount| { &mut m.websiteURLString },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "countryCode",
                |m: &PBAccount| { &m.countryCode },
                |m: &mut PBAccount| { &mut m.countryCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBLocation>>(
                "location",
                |m: &PBAccount| { &m.location },
                |m: &mut PBAccount| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "relationshipToThisAccount",
                |m: &PBAccount| { &m.relationshipToThisAccount },
                |m: &mut PBAccount| { &mut m.relationshipToThisAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "recentMedias",
                |m: &PBAccount| { &m.recentMedias },
                |m: &mut PBAccount| { &mut m.recentMedias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "relationshipFromThisAccount",
                |m: &PBAccount| { &m.relationshipFromThisAccount },
                |m: &mut PBAccount| { &mut m.relationshipFromThisAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phoneNumber",
                |m: &PBAccount| { &m.phoneNumber },
                |m: &mut PBAccount| { &mut m.phoneNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needToUpdateBasicInfo",
                |m: &PBAccount| { &m.needToUpdateBasicInfo },
                |m: &mut PBAccount| { &mut m.needToUpdateBasicInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needToUpdateMedias",
                |m: &PBAccount| { &m.needToUpdateMedias },
                |m: &mut PBAccount| { &mut m.needToUpdateMedias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "charmValue",
                |m: &PBAccount| { &m.charmValue },
                |m: &mut PBAccount| { &mut m.charmValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasAnonymousProfilePicture",
                |m: &PBAccount| { &m.hasAnonymousProfilePicture },
                |m: &mut PBAccount| { &mut m.hasAnonymousProfilePicture },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountLoginType>>(
                "accountLoginType",
                |m: &PBAccount| { &m.accountLoginType },
                |m: &mut PBAccount| { &mut m.accountLoginType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBAccount>(
                "PBAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBAccount {
        static instance: ::protobuf::rt::LazyV2<PBAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBAccount::new)
    }
}

impl ::protobuf::Clear for PBAccount {
    fn clear(&mut self) {
        self.accountID.clear();
        self.username.clear();
        self.password.clear();
        self.isPrivateAccount = false;
        self.mediaCount = 0;
        self.followingCount = 0;
        self.followerCount = 0;
        self.fullName.clear();
        self.avatarURLString.clear();
        self.gender = 0;
        self.emailAddress.clear();
        self.biography.clear();
        self.websiteURLString.clear();
        self.countryCode.clear();
        self.location.clear();
        self.relationshipToThisAccount = PBRelationship::PBRelationship_Null;
        self.recentMedias.clear();
        self.relationshipFromThisAccount = PBRelationship::PBRelationship_Null;
        self.phoneNumber.clear();
        self.needToUpdateBasicInfo = false;
        self.needToUpdateMedias = false;
        self.charmValue = 0.;
        self.hasAnonymousProfilePicture = false;
        self.accountLoginType = PBAccountLoginType::InstagramLogin;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBLocation {
    // message fields
    pub latitude: f64,
    pub longitude: f64,
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBLocation {
    fn default() -> &'a PBLocation {
        <PBLocation as ::protobuf::Message>::default_instance()
    }
}

impl PBLocation {
    pub fn new() -> PBLocation {
        ::std::default::Default::default()
    }

    // double latitude = 1;


    pub fn get_latitude(&self) -> f64 {
        self.latitude
    }
    pub fn clear_latitude(&mut self) {
        self.latitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f64) {
        self.latitude = v;
    }

    // double longitude = 2;


    pub fn get_longitude(&self) -> f64 {
        self.longitude
    }
    pub fn clear_longitude(&mut self) {
        self.longitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f64) {
        self.longitude = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string address = 4;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBLocation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latitude = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.longitude = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latitude != 0. {
            my_size += 9;
        }
        if self.longitude != 0. {
            my_size += 9;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.latitude != 0. {
            os.write_double(1, self.latitude)?;
        }
        if self.longitude != 0. {
            os.write_double(2, self.longitude)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(4, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBLocation {
        PBLocation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "latitude",
                |m: &PBLocation| { &m.latitude },
                |m: &mut PBLocation| { &mut m.latitude },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "longitude",
                |m: &PBLocation| { &m.longitude },
                |m: &mut PBLocation| { &mut m.longitude },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PBLocation| { &m.name },
                |m: &mut PBLocation| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &PBLocation| { &m.address },
                |m: &mut PBLocation| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBLocation>(
                "PBLocation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBLocation {
        static instance: ::protobuf::rt::LazyV2<PBLocation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBLocation::new)
    }
}

impl ::protobuf::Clear for PBLocation {
    fn clear(&mut self) {
        self.latitude = 0.;
        self.longitude = 0.;
        self.name.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBLocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBMedia {
    // message fields
    pub mediaID: ::std::string::String,
    pub mediaType: PBMediaType,
    pub location: ::protobuf::SingularPtrField<PBLocation>,
    pub likeCount: i64,
    pub commentCount: i64,
    pub createTime: i64,
    pub owner: ::protobuf::SingularPtrField<PBAccount>,
    pub relationshipToOwner: PBRelationship,
    pub accountsInMedia: ::protobuf::RepeatedField<PBAccount>,
    pub text: ::std::string::String,
    pub filter: ::std::string::String,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub imageURLVersions: ::protobuf::RepeatedField<PBMedia_PBURLVersion>,
    pub videoURLVersions: ::protobuf::RepeatedField<PBMedia_PBURLVersion>,
    pub previewComments: ::protobuf::RepeatedField<PBComment>,
    pub mediaCode: ::std::string::String,
    pub viewCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBMedia {
    fn default() -> &'a PBMedia {
        <PBMedia as ::protobuf::Message>::default_instance()
    }
}

impl PBMedia {
    pub fn new() -> PBMedia {
        ::std::default::Default::default()
    }

    // string mediaID = 1;


    pub fn get_mediaID(&self) -> &str {
        &self.mediaID
    }
    pub fn clear_mediaID(&mut self) {
        self.mediaID.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediaID(&mut self, v: ::std::string::String) {
        self.mediaID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaID(&mut self) -> &mut ::std::string::String {
        &mut self.mediaID
    }

    // Take field
    pub fn take_mediaID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mediaID, ::std::string::String::new())
    }

    // .PBMediaType mediaType = 2;


    pub fn get_mediaType(&self) -> PBMediaType {
        self.mediaType
    }
    pub fn clear_mediaType(&mut self) {
        self.mediaType = PBMediaType::PBMediaType_None;
    }

    // Param is passed by value, moved
    pub fn set_mediaType(&mut self, v: PBMediaType) {
        self.mediaType = v;
    }

    // .PBLocation location = 3;


    pub fn get_location(&self) -> &PBLocation {
        self.location.as_ref().unwrap_or_else(|| <PBLocation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: PBLocation) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut PBLocation {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> PBLocation {
        self.location.take().unwrap_or_else(|| PBLocation::new())
    }

    // int64 likeCount = 4;


    pub fn get_likeCount(&self) -> i64 {
        self.likeCount
    }
    pub fn clear_likeCount(&mut self) {
        self.likeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_likeCount(&mut self, v: i64) {
        self.likeCount = v;
    }

    // int64 commentCount = 5;


    pub fn get_commentCount(&self) -> i64 {
        self.commentCount
    }
    pub fn clear_commentCount(&mut self) {
        self.commentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_commentCount(&mut self, v: i64) {
        self.commentCount = v;
    }

    // int64 createTime = 6;


    pub fn get_createTime(&self) -> i64 {
        self.createTime
    }
    pub fn clear_createTime(&mut self) {
        self.createTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_createTime(&mut self, v: i64) {
        self.createTime = v;
    }

    // .PBAccount owner = 7;


    pub fn get_owner(&self) -> &PBAccount {
        self.owner.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: PBAccount) {
        self.owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut PBAccount {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> PBAccount {
        self.owner.take().unwrap_or_else(|| PBAccount::new())
    }

    // .PBRelationship relationshipToOwner = 8;


    pub fn get_relationshipToOwner(&self) -> PBRelationship {
        self.relationshipToOwner
    }
    pub fn clear_relationshipToOwner(&mut self) {
        self.relationshipToOwner = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_relationshipToOwner(&mut self, v: PBRelationship) {
        self.relationshipToOwner = v;
    }

    // repeated .PBAccount accountsInMedia = 9;


    pub fn get_accountsInMedia(&self) -> &[PBAccount] {
        &self.accountsInMedia
    }
    pub fn clear_accountsInMedia(&mut self) {
        self.accountsInMedia.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountsInMedia(&mut self, v: ::protobuf::RepeatedField<PBAccount>) {
        self.accountsInMedia = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountsInMedia(&mut self) -> &mut ::protobuf::RepeatedField<PBAccount> {
        &mut self.accountsInMedia
    }

    // Take field
    pub fn take_accountsInMedia(&mut self) -> ::protobuf::RepeatedField<PBAccount> {
        ::std::mem::replace(&mut self.accountsInMedia, ::protobuf::RepeatedField::new())
    }

    // string text = 10;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // string filter = 11;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // repeated string tags = 12;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // repeated .PBMedia.PBURLVersion imageURLVersions = 13;


    pub fn get_imageURLVersions(&self) -> &[PBMedia_PBURLVersion] {
        &self.imageURLVersions
    }
    pub fn clear_imageURLVersions(&mut self) {
        self.imageURLVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_imageURLVersions(&mut self, v: ::protobuf::RepeatedField<PBMedia_PBURLVersion>) {
        self.imageURLVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imageURLVersions(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia_PBURLVersion> {
        &mut self.imageURLVersions
    }

    // Take field
    pub fn take_imageURLVersions(&mut self) -> ::protobuf::RepeatedField<PBMedia_PBURLVersion> {
        ::std::mem::replace(&mut self.imageURLVersions, ::protobuf::RepeatedField::new())
    }

    // repeated .PBMedia.PBURLVersion videoURLVersions = 14;


    pub fn get_videoURLVersions(&self) -> &[PBMedia_PBURLVersion] {
        &self.videoURLVersions
    }
    pub fn clear_videoURLVersions(&mut self) {
        self.videoURLVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_videoURLVersions(&mut self, v: ::protobuf::RepeatedField<PBMedia_PBURLVersion>) {
        self.videoURLVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_videoURLVersions(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia_PBURLVersion> {
        &mut self.videoURLVersions
    }

    // Take field
    pub fn take_videoURLVersions(&mut self) -> ::protobuf::RepeatedField<PBMedia_PBURLVersion> {
        ::std::mem::replace(&mut self.videoURLVersions, ::protobuf::RepeatedField::new())
    }

    // repeated .PBComment previewComments = 15;


    pub fn get_previewComments(&self) -> &[PBComment] {
        &self.previewComments
    }
    pub fn clear_previewComments(&mut self) {
        self.previewComments.clear();
    }

    // Param is passed by value, moved
    pub fn set_previewComments(&mut self, v: ::protobuf::RepeatedField<PBComment>) {
        self.previewComments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previewComments(&mut self) -> &mut ::protobuf::RepeatedField<PBComment> {
        &mut self.previewComments
    }

    // Take field
    pub fn take_previewComments(&mut self) -> ::protobuf::RepeatedField<PBComment> {
        ::std::mem::replace(&mut self.previewComments, ::protobuf::RepeatedField::new())
    }

    // string mediaCode = 16;


    pub fn get_mediaCode(&self) -> &str {
        &self.mediaCode
    }
    pub fn clear_mediaCode(&mut self) {
        self.mediaCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediaCode(&mut self, v: ::std::string::String) {
        self.mediaCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaCode(&mut self) -> &mut ::std::string::String {
        &mut self.mediaCode
    }

    // Take field
    pub fn take_mediaCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mediaCode, ::std::string::String::new())
    }

    // int64 viewCount = 17;


    pub fn get_viewCount(&self) -> i64 {
        self.viewCount
    }
    pub fn clear_viewCount(&mut self) {
        self.viewCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_viewCount(&mut self, v: i64) {
        self.viewCount = v;
    }
}

impl ::protobuf::Message for PBMedia {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accountsInMedia {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.imageURLVersions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.videoURLVersions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.previewComments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mediaID)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mediaType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.likeCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commentCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createTime = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.relationshipToOwner, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accountsInMedia)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.imageURLVersions)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.videoURLVersions)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.previewComments)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mediaCode)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.viewCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mediaID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mediaID);
        }
        if self.mediaType != PBMediaType::PBMediaType_None {
            my_size += ::protobuf::rt::enum_size(2, self.mediaType);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.likeCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.likeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commentCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.commentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.createTime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.createTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.relationshipToOwner != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(8, self.relationshipToOwner);
        }
        for value in &self.accountsInMedia {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.text);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.filter);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.imageURLVersions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.videoURLVersions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.previewComments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.mediaCode.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.mediaCode);
        }
        if self.viewCount != 0 {
            my_size += ::protobuf::rt::value_size(17, self.viewCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mediaID.is_empty() {
            os.write_string(1, &self.mediaID)?;
        }
        if self.mediaType != PBMediaType::PBMediaType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.mediaType))?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.likeCount != 0 {
            os.write_int64(4, self.likeCount)?;
        }
        if self.commentCount != 0 {
            os.write_int64(5, self.commentCount)?;
        }
        if self.createTime != 0 {
            os.write_int64(6, self.createTime)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.relationshipToOwner != PBRelationship::PBRelationship_Null {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.relationshipToOwner))?;
        }
        for v in &self.accountsInMedia {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.text.is_empty() {
            os.write_string(10, &self.text)?;
        }
        if !self.filter.is_empty() {
            os.write_string(11, &self.filter)?;
        }
        for v in &self.tags {
            os.write_string(12, &v)?;
        };
        for v in &self.imageURLVersions {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.videoURLVersions {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.previewComments {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.mediaCode.is_empty() {
            os.write_string(16, &self.mediaCode)?;
        }
        if self.viewCount != 0 {
            os.write_int64(17, self.viewCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBMedia {
        PBMedia::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mediaID",
                |m: &PBMedia| { &m.mediaID },
                |m: &mut PBMedia| { &mut m.mediaID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBMediaType>>(
                "mediaType",
                |m: &PBMedia| { &m.mediaType },
                |m: &mut PBMedia| { &mut m.mediaType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBLocation>>(
                "location",
                |m: &PBMedia| { &m.location },
                |m: &mut PBMedia| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "likeCount",
                |m: &PBMedia| { &m.likeCount },
                |m: &mut PBMedia| { &mut m.likeCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commentCount",
                |m: &PBMedia| { &m.commentCount },
                |m: &mut PBMedia| { &mut m.commentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createTime",
                |m: &PBMedia| { &m.createTime },
                |m: &mut PBMedia| { &mut m.createTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "owner",
                |m: &PBMedia| { &m.owner },
                |m: &mut PBMedia| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "relationshipToOwner",
                |m: &PBMedia| { &m.relationshipToOwner },
                |m: &mut PBMedia| { &mut m.relationshipToOwner },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "accountsInMedia",
                |m: &PBMedia| { &m.accountsInMedia },
                |m: &mut PBMedia| { &mut m.accountsInMedia },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &PBMedia| { &m.text },
                |m: &mut PBMedia| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &PBMedia| { &m.filter },
                |m: &mut PBMedia| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &PBMedia| { &m.tags },
                |m: &mut PBMedia| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia_PBURLVersion>>(
                "imageURLVersions",
                |m: &PBMedia| { &m.imageURLVersions },
                |m: &mut PBMedia| { &mut m.imageURLVersions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia_PBURLVersion>>(
                "videoURLVersions",
                |m: &PBMedia| { &m.videoURLVersions },
                |m: &mut PBMedia| { &mut m.videoURLVersions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBComment>>(
                "previewComments",
                |m: &PBMedia| { &m.previewComments },
                |m: &mut PBMedia| { &mut m.previewComments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mediaCode",
                |m: &PBMedia| { &m.mediaCode },
                |m: &mut PBMedia| { &mut m.mediaCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "viewCount",
                |m: &PBMedia| { &m.viewCount },
                |m: &mut PBMedia| { &mut m.viewCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBMedia>(
                "PBMedia",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBMedia {
        static instance: ::protobuf::rt::LazyV2<PBMedia> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBMedia::new)
    }
}

impl ::protobuf::Clear for PBMedia {
    fn clear(&mut self) {
        self.mediaID.clear();
        self.mediaType = PBMediaType::PBMediaType_None;
        self.location.clear();
        self.likeCount = 0;
        self.commentCount = 0;
        self.createTime = 0;
        self.owner.clear();
        self.relationshipToOwner = PBRelationship::PBRelationship_Null;
        self.accountsInMedia.clear();
        self.text.clear();
        self.filter.clear();
        self.tags.clear();
        self.imageURLVersions.clear();
        self.videoURLVersions.clear();
        self.previewComments.clear();
        self.mediaCode.clear();
        self.viewCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBMedia {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMedia {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBMedia_PBURLVersion {
    // message fields
    pub width: i64,
    pub height: i64,
    pub urlString: ::std::string::String,
    pub videoType: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBMedia_PBURLVersion {
    fn default() -> &'a PBMedia_PBURLVersion {
        <PBMedia_PBURLVersion as ::protobuf::Message>::default_instance()
    }
}

impl PBMedia_PBURLVersion {
    pub fn new() -> PBMedia_PBURLVersion {
        ::std::default::Default::default()
    }

    // int64 width = 1;


    pub fn get_width(&self) -> i64 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i64) {
        self.width = v;
    }

    // int64 height = 2;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }

    // string urlString = 3;


    pub fn get_urlString(&self) -> &str {
        &self.urlString
    }
    pub fn clear_urlString(&mut self) {
        self.urlString.clear();
    }

    // Param is passed by value, moved
    pub fn set_urlString(&mut self, v: ::std::string::String) {
        self.urlString = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_urlString(&mut self) -> &mut ::std::string::String {
        &mut self.urlString
    }

    // Take field
    pub fn take_urlString(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.urlString, ::std::string::String::new())
    }

    // int64 videoType = 4;


    pub fn get_videoType(&self) -> i64 {
        self.videoType
    }
    pub fn clear_videoType(&mut self) {
        self.videoType = 0;
    }

    // Param is passed by value, moved
    pub fn set_videoType(&mut self, v: i64) {
        self.videoType = v;
    }
}

impl ::protobuf::Message for PBMedia_PBURLVersion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.width = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.urlString)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.videoType = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(1, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.urlString.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.urlString);
        }
        if self.videoType != 0 {
            my_size += ::protobuf::rt::value_size(4, self.videoType, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.width != 0 {
            os.write_int64(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int64(2, self.height)?;
        }
        if !self.urlString.is_empty() {
            os.write_string(3, &self.urlString)?;
        }
        if self.videoType != 0 {
            os.write_int64(4, self.videoType)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBMedia_PBURLVersion {
        PBMedia_PBURLVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "width",
                |m: &PBMedia_PBURLVersion| { &m.width },
                |m: &mut PBMedia_PBURLVersion| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "height",
                |m: &PBMedia_PBURLVersion| { &m.height },
                |m: &mut PBMedia_PBURLVersion| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "urlString",
                |m: &PBMedia_PBURLVersion| { &m.urlString },
                |m: &mut PBMedia_PBURLVersion| { &mut m.urlString },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "videoType",
                |m: &PBMedia_PBURLVersion| { &m.videoType },
                |m: &mut PBMedia_PBURLVersion| { &mut m.videoType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBMedia_PBURLVersion>(
                "PBMedia.PBURLVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBMedia_PBURLVersion {
        static instance: ::protobuf::rt::LazyV2<PBMedia_PBURLVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBMedia_PBURLVersion::new)
    }
}

impl ::protobuf::Clear for PBMedia_PBURLVersion {
    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.urlString.clear();
        self.videoType = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBMedia_PBURLVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMedia_PBURLVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBComment {
    // message fields
    pub commentID: ::std::string::String,
    pub commentTime: i64,
    pub text: ::std::string::String,
    pub commenter: ::protobuf::SingularPtrField<PBAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBComment {
    fn default() -> &'a PBComment {
        <PBComment as ::protobuf::Message>::default_instance()
    }
}

impl PBComment {
    pub fn new() -> PBComment {
        ::std::default::Default::default()
    }

    // string commentID = 1;


    pub fn get_commentID(&self) -> &str {
        &self.commentID
    }
    pub fn clear_commentID(&mut self) {
        self.commentID.clear();
    }

    // Param is passed by value, moved
    pub fn set_commentID(&mut self, v: ::std::string::String) {
        self.commentID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commentID(&mut self) -> &mut ::std::string::String {
        &mut self.commentID
    }

    // Take field
    pub fn take_commentID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.commentID, ::std::string::String::new())
    }

    // int64 commentTime = 2;


    pub fn get_commentTime(&self) -> i64 {
        self.commentTime
    }
    pub fn clear_commentTime(&mut self) {
        self.commentTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_commentTime(&mut self, v: i64) {
        self.commentTime = v;
    }

    // string text = 3;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // .PBAccount commenter = 4;


    pub fn get_commenter(&self) -> &PBAccount {
        self.commenter.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commenter(&mut self) {
        self.commenter.clear();
    }

    pub fn has_commenter(&self) -> bool {
        self.commenter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commenter(&mut self, v: PBAccount) {
        self.commenter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commenter(&mut self) -> &mut PBAccount {
        if self.commenter.is_none() {
            self.commenter.set_default();
        }
        self.commenter.as_mut().unwrap()
    }

    // Take field
    pub fn take_commenter(&mut self) -> PBAccount {
        self.commenter.take().unwrap_or_else(|| PBAccount::new())
    }
}

impl ::protobuf::Message for PBComment {
    fn is_initialized(&self) -> bool {
        for v in &self.commenter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.commentID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commentTime = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commenter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.commentID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.commentID);
        }
        if self.commentTime != 0 {
            my_size += ::protobuf::rt::value_size(2, self.commentTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.text);
        }
        if let Some(ref v) = self.commenter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.commentID.is_empty() {
            os.write_string(1, &self.commentID)?;
        }
        if self.commentTime != 0 {
            os.write_int64(2, self.commentTime)?;
        }
        if !self.text.is_empty() {
            os.write_string(3, &self.text)?;
        }
        if let Some(ref v) = self.commenter.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBComment {
        PBComment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "commentID",
                |m: &PBComment| { &m.commentID },
                |m: &mut PBComment| { &mut m.commentID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commentTime",
                |m: &PBComment| { &m.commentTime },
                |m: &mut PBComment| { &mut m.commentTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &PBComment| { &m.text },
                |m: &mut PBComment| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "commenter",
                |m: &PBComment| { &m.commenter },
                |m: &mut PBComment| { &mut m.commenter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBComment>(
                "PBComment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBComment {
        static instance: ::protobuf::rt::LazyV2<PBComment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBComment::new)
    }
}

impl ::protobuf::Clear for PBComment {
    fn clear(&mut self) {
        self.commentID.clear();
        self.commentTime = 0;
        self.text.clear();
        self.commenter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBComment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBComment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountInfo {
    // message fields
    pub accountID: ::std::string::String,
    pub account: ::protobuf::SingularPtrField<PBAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountInfo {
    fn default() -> &'a PBTaskContentFetchAccountInfo {
        <PBTaskContentFetchAccountInfo as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountInfo {
    pub fn new() -> PBTaskContentFetchAccountInfo {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // .PBAccount account = 2;


    pub fn get_account(&self) -> &PBAccount {
        self.account.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: PBAccount) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut PBAccount {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> PBAccount {
        self.account.take().unwrap_or_else(|| PBAccount::new())
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountInfo {
        PBTaskContentFetchAccountInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountInfo| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountInfo| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "account",
                |m: &PBTaskContentFetchAccountInfo| { &m.account },
                |m: &mut PBTaskContentFetchAccountInfo| { &mut m.account },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountInfo>(
                "PBTaskContentFetchAccountInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountInfo {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountInfo::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountInfo {
    fn clear(&mut self) {
        self.accountID.clear();
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountMedias {
    // message fields
    pub accountID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub medias: ::protobuf::RepeatedField<PBMedia>,
    pub currentCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountMedias {
    fn default() -> &'a PBTaskContentFetchAccountMedias {
        <PBTaskContentFetchAccountMedias as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountMedias {
    pub fn new() -> PBTaskContentFetchAccountMedias {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBMedia medias = 3;


    pub fn get_medias(&self) -> &[PBMedia] {
        &self.medias
    }
    pub fn clear_medias(&mut self) {
        self.medias.clear();
    }

    // Param is passed by value, moved
    pub fn set_medias(&mut self, v: ::protobuf::RepeatedField<PBMedia>) {
        self.medias = v;
    }

    // Mutable pointer to the field.
    pub fn mut_medias(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia> {
        &mut self.medias
    }

    // Take field
    pub fn take_medias(&mut self) -> ::protobuf::RepeatedField<PBMedia> {
        ::std::mem::replace(&mut self.medias, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountMedias {
    fn is_initialized(&self) -> bool {
        for v in &self.medias {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.medias)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.medias {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.medias {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountMedias {
        PBTaskContentFetchAccountMedias::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountMedias| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountMedias| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchAccountMedias| { &m.cursor },
                |m: &mut PBTaskContentFetchAccountMedias| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "medias",
                |m: &PBTaskContentFetchAccountMedias| { &m.medias },
                |m: &mut PBTaskContentFetchAccountMedias| { &mut m.medias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchAccountMedias| { &m.currentCount },
                |m: &mut PBTaskContentFetchAccountMedias| { &mut m.currentCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountMedias>(
                "PBTaskContentFetchAccountMedias",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountMedias {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountMedias> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountMedias::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountMedias {
    fn clear(&mut self) {
        self.accountID.clear();
        self.cursor.clear();
        self.medias.clear();
        self.currentCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountMedias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountMedias {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchMediaLikers {
    // message fields
    pub mediaID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub likers: ::protobuf::RepeatedField<PBAccount>,
    pub currentCount: i64,
    pub totalCount: i64,
    pub mediaCode: ::std::string::String,
    pub ownerID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchMediaLikers {
    fn default() -> &'a PBTaskContentFetchMediaLikers {
        <PBTaskContentFetchMediaLikers as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchMediaLikers {
    pub fn new() -> PBTaskContentFetchMediaLikers {
        ::std::default::Default::default()
    }

    // string mediaID = 1;


    pub fn get_mediaID(&self) -> &str {
        &self.mediaID
    }
    pub fn clear_mediaID(&mut self) {
        self.mediaID.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediaID(&mut self, v: ::std::string::String) {
        self.mediaID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaID(&mut self) -> &mut ::std::string::String {
        &mut self.mediaID
    }

    // Take field
    pub fn take_mediaID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mediaID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBAccount likers = 3;


    pub fn get_likers(&self) -> &[PBAccount] {
        &self.likers
    }
    pub fn clear_likers(&mut self) {
        self.likers.clear();
    }

    // Param is passed by value, moved
    pub fn set_likers(&mut self, v: ::protobuf::RepeatedField<PBAccount>) {
        self.likers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_likers(&mut self) -> &mut ::protobuf::RepeatedField<PBAccount> {
        &mut self.likers
    }

    // Take field
    pub fn take_likers(&mut self) -> ::protobuf::RepeatedField<PBAccount> {
        ::std::mem::replace(&mut self.likers, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }

    // int64 totalCount = 5;


    pub fn get_totalCount(&self) -> i64 {
        self.totalCount
    }
    pub fn clear_totalCount(&mut self) {
        self.totalCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalCount(&mut self, v: i64) {
        self.totalCount = v;
    }

    // string mediaCode = 6;


    pub fn get_mediaCode(&self) -> &str {
        &self.mediaCode
    }
    pub fn clear_mediaCode(&mut self) {
        self.mediaCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediaCode(&mut self, v: ::std::string::String) {
        self.mediaCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaCode(&mut self) -> &mut ::std::string::String {
        &mut self.mediaCode
    }

    // Take field
    pub fn take_mediaCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mediaCode, ::std::string::String::new())
    }

    // string ownerID = 7;


    pub fn get_ownerID(&self) -> &str {
        &self.ownerID
    }
    pub fn clear_ownerID(&mut self) {
        self.ownerID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ownerID(&mut self, v: ::std::string::String) {
        self.ownerID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerID(&mut self) -> &mut ::std::string::String {
        &mut self.ownerID
    }

    // Take field
    pub fn take_ownerID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ownerID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBTaskContentFetchMediaLikers {
    fn is_initialized(&self) -> bool {
        for v in &self.likers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mediaID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.likers)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalCount = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mediaCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ownerID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mediaID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mediaID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.likers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.totalCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mediaCode.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mediaCode);
        }
        if !self.ownerID.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.ownerID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mediaID.is_empty() {
            os.write_string(1, &self.mediaID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.likers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        if self.totalCount != 0 {
            os.write_int64(5, self.totalCount)?;
        }
        if !self.mediaCode.is_empty() {
            os.write_string(6, &self.mediaCode)?;
        }
        if !self.ownerID.is_empty() {
            os.write_string(7, &self.ownerID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchMediaLikers {
        PBTaskContentFetchMediaLikers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mediaID",
                |m: &PBTaskContentFetchMediaLikers| { &m.mediaID },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.mediaID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchMediaLikers| { &m.cursor },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "likers",
                |m: &PBTaskContentFetchMediaLikers| { &m.likers },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.likers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchMediaLikers| { &m.currentCount },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.currentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalCount",
                |m: &PBTaskContentFetchMediaLikers| { &m.totalCount },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.totalCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mediaCode",
                |m: &PBTaskContentFetchMediaLikers| { &m.mediaCode },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.mediaCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ownerID",
                |m: &PBTaskContentFetchMediaLikers| { &m.ownerID },
                |m: &mut PBTaskContentFetchMediaLikers| { &mut m.ownerID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchMediaLikers>(
                "PBTaskContentFetchMediaLikers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchMediaLikers {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchMediaLikers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchMediaLikers::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchMediaLikers {
    fn clear(&mut self) {
        self.mediaID.clear();
        self.cursor.clear();
        self.likers.clear();
        self.currentCount = 0;
        self.totalCount = 0;
        self.mediaCode.clear();
        self.ownerID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchMediaLikers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchMediaLikers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchMediaComments {
    // message fields
    pub mediaID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub comments: ::protobuf::RepeatedField<PBComment>,
    pub currentCount: i64,
    pub totalCount: i64,
    pub mediaCode: ::std::string::String,
    pub ownerID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchMediaComments {
    fn default() -> &'a PBTaskContentFetchMediaComments {
        <PBTaskContentFetchMediaComments as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchMediaComments {
    pub fn new() -> PBTaskContentFetchMediaComments {
        ::std::default::Default::default()
    }

    // string mediaID = 1;


    pub fn get_mediaID(&self) -> &str {
        &self.mediaID
    }
    pub fn clear_mediaID(&mut self) {
        self.mediaID.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediaID(&mut self, v: ::std::string::String) {
        self.mediaID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaID(&mut self) -> &mut ::std::string::String {
        &mut self.mediaID
    }

    // Take field
    pub fn take_mediaID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mediaID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBComment comments = 3;


    pub fn get_comments(&self) -> &[PBComment] {
        &self.comments
    }
    pub fn clear_comments(&mut self) {
        self.comments.clear();
    }

    // Param is passed by value, moved
    pub fn set_comments(&mut self, v: ::protobuf::RepeatedField<PBComment>) {
        self.comments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_comments(&mut self) -> &mut ::protobuf::RepeatedField<PBComment> {
        &mut self.comments
    }

    // Take field
    pub fn take_comments(&mut self) -> ::protobuf::RepeatedField<PBComment> {
        ::std::mem::replace(&mut self.comments, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }

    // int64 totalCount = 5;


    pub fn get_totalCount(&self) -> i64 {
        self.totalCount
    }
    pub fn clear_totalCount(&mut self) {
        self.totalCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalCount(&mut self, v: i64) {
        self.totalCount = v;
    }

    // string mediaCode = 6;


    pub fn get_mediaCode(&self) -> &str {
        &self.mediaCode
    }
    pub fn clear_mediaCode(&mut self) {
        self.mediaCode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mediaCode(&mut self, v: ::std::string::String) {
        self.mediaCode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaCode(&mut self) -> &mut ::std::string::String {
        &mut self.mediaCode
    }

    // Take field
    pub fn take_mediaCode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mediaCode, ::std::string::String::new())
    }

    // string ownerID = 7;


    pub fn get_ownerID(&self) -> &str {
        &self.ownerID
    }
    pub fn clear_ownerID(&mut self) {
        self.ownerID.clear();
    }

    // Param is passed by value, moved
    pub fn set_ownerID(&mut self, v: ::std::string::String) {
        self.ownerID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerID(&mut self) -> &mut ::std::string::String {
        &mut self.ownerID
    }

    // Take field
    pub fn take_ownerID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ownerID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBTaskContentFetchMediaComments {
    fn is_initialized(&self) -> bool {
        for v in &self.comments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mediaID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.comments)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalCount = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mediaCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ownerID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mediaID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mediaID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.comments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.totalCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mediaCode.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mediaCode);
        }
        if !self.ownerID.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.ownerID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mediaID.is_empty() {
            os.write_string(1, &self.mediaID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.comments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        if self.totalCount != 0 {
            os.write_int64(5, self.totalCount)?;
        }
        if !self.mediaCode.is_empty() {
            os.write_string(6, &self.mediaCode)?;
        }
        if !self.ownerID.is_empty() {
            os.write_string(7, &self.ownerID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchMediaComments {
        PBTaskContentFetchMediaComments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mediaID",
                |m: &PBTaskContentFetchMediaComments| { &m.mediaID },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.mediaID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchMediaComments| { &m.cursor },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBComment>>(
                "comments",
                |m: &PBTaskContentFetchMediaComments| { &m.comments },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.comments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchMediaComments| { &m.currentCount },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.currentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalCount",
                |m: &PBTaskContentFetchMediaComments| { &m.totalCount },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.totalCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mediaCode",
                |m: &PBTaskContentFetchMediaComments| { &m.mediaCode },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.mediaCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ownerID",
                |m: &PBTaskContentFetchMediaComments| { &m.ownerID },
                |m: &mut PBTaskContentFetchMediaComments| { &mut m.ownerID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchMediaComments>(
                "PBTaskContentFetchMediaComments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchMediaComments {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchMediaComments> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchMediaComments::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchMediaComments {
    fn clear(&mut self) {
        self.mediaID.clear();
        self.cursor.clear();
        self.comments.clear();
        self.currentCount = 0;
        self.totalCount = 0;
        self.mediaCode.clear();
        self.ownerID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchMediaComments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchMediaComments {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountFollowers {
    // message fields
    pub accountID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub followers: ::protobuf::RepeatedField<PBAccount>,
    pub currentCount: i64,
    pub withExtendedInfo: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountFollowers {
    fn default() -> &'a PBTaskContentFetchAccountFollowers {
        <PBTaskContentFetchAccountFollowers as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountFollowers {
    pub fn new() -> PBTaskContentFetchAccountFollowers {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBAccount followers = 3;


    pub fn get_followers(&self) -> &[PBAccount] {
        &self.followers
    }
    pub fn clear_followers(&mut self) {
        self.followers.clear();
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: ::protobuf::RepeatedField<PBAccount>) {
        self.followers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_followers(&mut self) -> &mut ::protobuf::RepeatedField<PBAccount> {
        &mut self.followers
    }

    // Take field
    pub fn take_followers(&mut self) -> ::protobuf::RepeatedField<PBAccount> {
        ::std::mem::replace(&mut self.followers, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }

    // bool withExtendedInfo = 5;


    pub fn get_withExtendedInfo(&self) -> bool {
        self.withExtendedInfo
    }
    pub fn clear_withExtendedInfo(&mut self) {
        self.withExtendedInfo = false;
    }

    // Param is passed by value, moved
    pub fn set_withExtendedInfo(&mut self, v: bool) {
        self.withExtendedInfo = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountFollowers {
    fn is_initialized(&self) -> bool {
        for v in &self.followers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.followers)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.withExtendedInfo = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.followers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.withExtendedInfo != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.followers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        if self.withExtendedInfo != false {
            os.write_bool(5, self.withExtendedInfo)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountFollowers {
        PBTaskContentFetchAccountFollowers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountFollowers| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountFollowers| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchAccountFollowers| { &m.cursor },
                |m: &mut PBTaskContentFetchAccountFollowers| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "followers",
                |m: &PBTaskContentFetchAccountFollowers| { &m.followers },
                |m: &mut PBTaskContentFetchAccountFollowers| { &mut m.followers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchAccountFollowers| { &m.currentCount },
                |m: &mut PBTaskContentFetchAccountFollowers| { &mut m.currentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "withExtendedInfo",
                |m: &PBTaskContentFetchAccountFollowers| { &m.withExtendedInfo },
                |m: &mut PBTaskContentFetchAccountFollowers| { &mut m.withExtendedInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountFollowers>(
                "PBTaskContentFetchAccountFollowers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountFollowers {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountFollowers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountFollowers::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountFollowers {
    fn clear(&mut self) {
        self.accountID.clear();
        self.cursor.clear();
        self.followers.clear();
        self.currentCount = 0;
        self.withExtendedInfo = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountFollowers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountFollowers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountLikedMedias {
    // message fields
    pub accountID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub medias: ::protobuf::RepeatedField<PBMedia>,
    pub currentCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountLikedMedias {
    fn default() -> &'a PBTaskContentFetchAccountLikedMedias {
        <PBTaskContentFetchAccountLikedMedias as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountLikedMedias {
    pub fn new() -> PBTaskContentFetchAccountLikedMedias {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBMedia medias = 3;


    pub fn get_medias(&self) -> &[PBMedia] {
        &self.medias
    }
    pub fn clear_medias(&mut self) {
        self.medias.clear();
    }

    // Param is passed by value, moved
    pub fn set_medias(&mut self, v: ::protobuf::RepeatedField<PBMedia>) {
        self.medias = v;
    }

    // Mutable pointer to the field.
    pub fn mut_medias(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia> {
        &mut self.medias
    }

    // Take field
    pub fn take_medias(&mut self) -> ::protobuf::RepeatedField<PBMedia> {
        ::std::mem::replace(&mut self.medias, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountLikedMedias {
    fn is_initialized(&self) -> bool {
        for v in &self.medias {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.medias)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.medias {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.medias {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountLikedMedias {
        PBTaskContentFetchAccountLikedMedias::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountLikedMedias| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountLikedMedias| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchAccountLikedMedias| { &m.cursor },
                |m: &mut PBTaskContentFetchAccountLikedMedias| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "medias",
                |m: &PBTaskContentFetchAccountLikedMedias| { &m.medias },
                |m: &mut PBTaskContentFetchAccountLikedMedias| { &mut m.medias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchAccountLikedMedias| { &m.currentCount },
                |m: &mut PBTaskContentFetchAccountLikedMedias| { &mut m.currentCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountLikedMedias>(
                "PBTaskContentFetchAccountLikedMedias",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountLikedMedias {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountLikedMedias> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountLikedMedias::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountLikedMedias {
    fn clear(&mut self) {
        self.accountID.clear();
        self.cursor.clear();
        self.medias.clear();
        self.currentCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountLikedMedias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountLikedMedias {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountFollowings {
    // message fields
    pub accountID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub followings: ::protobuf::RepeatedField<PBAccount>,
    pub currentCount: i64,
    pub withExtendedInfo: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountFollowings {
    fn default() -> &'a PBTaskContentFetchAccountFollowings {
        <PBTaskContentFetchAccountFollowings as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountFollowings {
    pub fn new() -> PBTaskContentFetchAccountFollowings {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBAccount followings = 3;


    pub fn get_followings(&self) -> &[PBAccount] {
        &self.followings
    }
    pub fn clear_followings(&mut self) {
        self.followings.clear();
    }

    // Param is passed by value, moved
    pub fn set_followings(&mut self, v: ::protobuf::RepeatedField<PBAccount>) {
        self.followings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_followings(&mut self) -> &mut ::protobuf::RepeatedField<PBAccount> {
        &mut self.followings
    }

    // Take field
    pub fn take_followings(&mut self) -> ::protobuf::RepeatedField<PBAccount> {
        ::std::mem::replace(&mut self.followings, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }

    // bool withExtendedInfo = 5;


    pub fn get_withExtendedInfo(&self) -> bool {
        self.withExtendedInfo
    }
    pub fn clear_withExtendedInfo(&mut self) {
        self.withExtendedInfo = false;
    }

    // Param is passed by value, moved
    pub fn set_withExtendedInfo(&mut self, v: bool) {
        self.withExtendedInfo = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountFollowings {
    fn is_initialized(&self) -> bool {
        for v in &self.followings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.followings)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.withExtendedInfo = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.followings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.withExtendedInfo != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.followings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        if self.withExtendedInfo != false {
            os.write_bool(5, self.withExtendedInfo)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountFollowings {
        PBTaskContentFetchAccountFollowings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountFollowings| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountFollowings| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchAccountFollowings| { &m.cursor },
                |m: &mut PBTaskContentFetchAccountFollowings| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "followings",
                |m: &PBTaskContentFetchAccountFollowings| { &m.followings },
                |m: &mut PBTaskContentFetchAccountFollowings| { &mut m.followings },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchAccountFollowings| { &m.currentCount },
                |m: &mut PBTaskContentFetchAccountFollowings| { &mut m.currentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "withExtendedInfo",
                |m: &PBTaskContentFetchAccountFollowings| { &m.withExtendedInfo },
                |m: &mut PBTaskContentFetchAccountFollowings| { &mut m.withExtendedInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountFollowings>(
                "PBTaskContentFetchAccountFollowings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountFollowings {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountFollowings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountFollowings::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountFollowings {
    fn clear(&mut self) {
        self.accountID.clear();
        self.cursor.clear();
        self.followings.clear();
        self.currentCount = 0;
        self.withExtendedInfo = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountFollowings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountFollowings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountBlockings {
    // message fields
    pub accountID: ::std::string::String,
    pub cursor: ::std::string::String,
    pub blockings: ::protobuf::RepeatedField<PBTaskContentFetchAccountBlockings_BlockingInfo>,
    pub currentCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountBlockings {
    fn default() -> &'a PBTaskContentFetchAccountBlockings {
        <PBTaskContentFetchAccountBlockings as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountBlockings {
    pub fn new() -> PBTaskContentFetchAccountBlockings {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string cursor = 2;


    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    // repeated .PBTaskContentFetchAccountBlockings.BlockingInfo blockings = 3;


    pub fn get_blockings(&self) -> &[PBTaskContentFetchAccountBlockings_BlockingInfo] {
        &self.blockings
    }
    pub fn clear_blockings(&mut self) {
        self.blockings.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockings(&mut self, v: ::protobuf::RepeatedField<PBTaskContentFetchAccountBlockings_BlockingInfo>) {
        self.blockings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockings(&mut self) -> &mut ::protobuf::RepeatedField<PBTaskContentFetchAccountBlockings_BlockingInfo> {
        &mut self.blockings
    }

    // Take field
    pub fn take_blockings(&mut self) -> ::protobuf::RepeatedField<PBTaskContentFetchAccountBlockings_BlockingInfo> {
        ::std::mem::replace(&mut self.blockings, ::protobuf::RepeatedField::new())
    }

    // int64 currentCount = 4;


    pub fn get_currentCount(&self) -> i64 {
        self.currentCount
    }
    pub fn clear_currentCount(&mut self) {
        self.currentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentCount(&mut self, v: i64) {
        self.currentCount = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountBlockings {
    fn is_initialized(&self) -> bool {
        for v in &self.blockings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blockings)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        for value in &self.blockings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.currentCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        for v in &self.blockings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.currentCount != 0 {
            os.write_int64(4, self.currentCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountBlockings {
        PBTaskContentFetchAccountBlockings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountBlockings| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountBlockings| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cursor",
                |m: &PBTaskContentFetchAccountBlockings| { &m.cursor },
                |m: &mut PBTaskContentFetchAccountBlockings| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBTaskContentFetchAccountBlockings_BlockingInfo>>(
                "blockings",
                |m: &PBTaskContentFetchAccountBlockings| { &m.blockings },
                |m: &mut PBTaskContentFetchAccountBlockings| { &mut m.blockings },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentCount",
                |m: &PBTaskContentFetchAccountBlockings| { &m.currentCount },
                |m: &mut PBTaskContentFetchAccountBlockings| { &mut m.currentCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountBlockings>(
                "PBTaskContentFetchAccountBlockings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountBlockings {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountBlockings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountBlockings::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountBlockings {
    fn clear(&mut self) {
        self.accountID.clear();
        self.cursor.clear();
        self.blockings.clear();
        self.currentCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountBlockings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountBlockings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountBlockings_BlockingInfo {
    // message fields
    pub account: ::protobuf::SingularPtrField<PBAccount>,
    pub blockTime: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountBlockings_BlockingInfo {
    fn default() -> &'a PBTaskContentFetchAccountBlockings_BlockingInfo {
        <PBTaskContentFetchAccountBlockings_BlockingInfo as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountBlockings_BlockingInfo {
    pub fn new() -> PBTaskContentFetchAccountBlockings_BlockingInfo {
        ::std::default::Default::default()
    }

    // .PBAccount account = 1;


    pub fn get_account(&self) -> &PBAccount {
        self.account.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: PBAccount) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut PBAccount {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> PBAccount {
        self.account.take().unwrap_or_else(|| PBAccount::new())
    }

    // int64 blockTime = 2;


    pub fn get_blockTime(&self) -> i64 {
        self.blockTime
    }
    pub fn clear_blockTime(&mut self) {
        self.blockTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTime(&mut self, v: i64) {
        self.blockTime = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountBlockings_BlockingInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.blockTime != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.blockTime != 0 {
            os.write_int64(2, self.blockTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountBlockings_BlockingInfo {
        PBTaskContentFetchAccountBlockings_BlockingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "account",
                |m: &PBTaskContentFetchAccountBlockings_BlockingInfo| { &m.account },
                |m: &mut PBTaskContentFetchAccountBlockings_BlockingInfo| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockTime",
                |m: &PBTaskContentFetchAccountBlockings_BlockingInfo| { &m.blockTime },
                |m: &mut PBTaskContentFetchAccountBlockings_BlockingInfo| { &mut m.blockTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountBlockings_BlockingInfo>(
                "PBTaskContentFetchAccountBlockings.BlockingInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountBlockings_BlockingInfo {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountBlockings_BlockingInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountBlockings_BlockingInfo::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountBlockings_BlockingInfo {
    fn clear(&mut self) {
        self.account.clear();
        self.blockTime = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountBlockings_BlockingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountBlockings_BlockingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaksContentFetchAccountRelation {
    // message fields
    pub sourceAccountID: ::std::string::String,
    pub targetAccountID: ::std::string::String,
    pub relation: PBRelationship,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaksContentFetchAccountRelation {
    fn default() -> &'a PBTaksContentFetchAccountRelation {
        <PBTaksContentFetchAccountRelation as ::protobuf::Message>::default_instance()
    }
}

impl PBTaksContentFetchAccountRelation {
    pub fn new() -> PBTaksContentFetchAccountRelation {
        ::std::default::Default::default()
    }

    // string sourceAccountID = 1;


    pub fn get_sourceAccountID(&self) -> &str {
        &self.sourceAccountID
    }
    pub fn clear_sourceAccountID(&mut self) {
        self.sourceAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_sourceAccountID(&mut self, v: ::std::string::String) {
        self.sourceAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.sourceAccountID
    }

    // Take field
    pub fn take_sourceAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sourceAccountID, ::std::string::String::new())
    }

    // string targetAccountID = 2;


    pub fn get_targetAccountID(&self) -> &str {
        &self.targetAccountID
    }
    pub fn clear_targetAccountID(&mut self) {
        self.targetAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAccountID(&mut self, v: ::std::string::String) {
        self.targetAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.targetAccountID
    }

    // Take field
    pub fn take_targetAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAccountID, ::std::string::String::new())
    }

    // .PBRelationship relation = 3;


    pub fn get_relation(&self) -> PBRelationship {
        self.relation
    }
    pub fn clear_relation(&mut self) {
        self.relation = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_relation(&mut self, v: PBRelationship) {
        self.relation = v;
    }
}

impl ::protobuf::Message for PBTaksContentFetchAccountRelation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sourceAccountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.relation, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sourceAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sourceAccountID);
        }
        if !self.targetAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.targetAccountID);
        }
        if self.relation != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(3, self.relation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sourceAccountID.is_empty() {
            os.write_string(1, &self.sourceAccountID)?;
        }
        if !self.targetAccountID.is_empty() {
            os.write_string(2, &self.targetAccountID)?;
        }
        if self.relation != PBRelationship::PBRelationship_Null {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.relation))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaksContentFetchAccountRelation {
        PBTaksContentFetchAccountRelation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceAccountID",
                |m: &PBTaksContentFetchAccountRelation| { &m.sourceAccountID },
                |m: &mut PBTaksContentFetchAccountRelation| { &mut m.sourceAccountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAccountID",
                |m: &PBTaksContentFetchAccountRelation| { &m.targetAccountID },
                |m: &mut PBTaksContentFetchAccountRelation| { &mut m.targetAccountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "relation",
                |m: &PBTaksContentFetchAccountRelation| { &m.relation },
                |m: &mut PBTaksContentFetchAccountRelation| { &mut m.relation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaksContentFetchAccountRelation>(
                "PBTaksContentFetchAccountRelation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaksContentFetchAccountRelation {
        static instance: ::protobuf::rt::LazyV2<PBTaksContentFetchAccountRelation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaksContentFetchAccountRelation::new)
    }
}

impl ::protobuf::Clear for PBTaksContentFetchAccountRelation {
    fn clear(&mut self) {
        self.sourceAccountID.clear();
        self.targetAccountID.clear();
        self.relation = PBRelationship::PBRelationship_Null;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaksContentFetchAccountRelation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaksContentFetchAccountRelation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountActivities {
    // message fields
    pub accountID: ::std::string::String,
    pub startTimestamp: i64,
    pub activities: ::protobuf::RepeatedField<PBTaskContentFetchAccountActivities_Activity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountActivities {
    fn default() -> &'a PBTaskContentFetchAccountActivities {
        <PBTaskContentFetchAccountActivities as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountActivities {
    pub fn new() -> PBTaskContentFetchAccountActivities {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // int64 startTimestamp = 2;


    pub fn get_startTimestamp(&self) -> i64 {
        self.startTimestamp
    }
    pub fn clear_startTimestamp(&mut self) {
        self.startTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_startTimestamp(&mut self, v: i64) {
        self.startTimestamp = v;
    }

    // repeated .PBTaskContentFetchAccountActivities.Activity activities = 3;


    pub fn get_activities(&self) -> &[PBTaskContentFetchAccountActivities_Activity] {
        &self.activities
    }
    pub fn clear_activities(&mut self) {
        self.activities.clear();
    }

    // Param is passed by value, moved
    pub fn set_activities(&mut self, v: ::protobuf::RepeatedField<PBTaskContentFetchAccountActivities_Activity>) {
        self.activities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_activities(&mut self) -> &mut ::protobuf::RepeatedField<PBTaskContentFetchAccountActivities_Activity> {
        &mut self.activities
    }

    // Take field
    pub fn take_activities(&mut self) -> ::protobuf::RepeatedField<PBTaskContentFetchAccountActivities_Activity> {
        ::std::mem::replace(&mut self.activities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountActivities {
    fn is_initialized(&self) -> bool {
        for v in &self.activities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTimestamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.activities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.startTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.startTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.activities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.startTimestamp != 0 {
            os.write_int64(2, self.startTimestamp)?;
        }
        for v in &self.activities {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountActivities {
        PBTaskContentFetchAccountActivities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaskContentFetchAccountActivities| { &m.accountID },
                |m: &mut PBTaskContentFetchAccountActivities| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTimestamp",
                |m: &PBTaskContentFetchAccountActivities| { &m.startTimestamp },
                |m: &mut PBTaskContentFetchAccountActivities| { &mut m.startTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBTaskContentFetchAccountActivities_Activity>>(
                "activities",
                |m: &PBTaskContentFetchAccountActivities| { &m.activities },
                |m: &mut PBTaskContentFetchAccountActivities| { &mut m.activities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountActivities>(
                "PBTaskContentFetchAccountActivities",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountActivities {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountActivities> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountActivities::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountActivities {
    fn clear(&mut self) {
        self.accountID.clear();
        self.startTimestamp = 0;
        self.activities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountActivities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountActivities {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchAccountActivities_Activity {
    // message fields
    pub field_type: PBActivityType,
    pub targetAccount: ::protobuf::SingularPtrField<PBAccount>,
    pub media: ::protobuf::SingularPtrField<PBMedia>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchAccountActivities_Activity {
    fn default() -> &'a PBTaskContentFetchAccountActivities_Activity {
        <PBTaskContentFetchAccountActivities_Activity as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchAccountActivities_Activity {
    pub fn new() -> PBTaskContentFetchAccountActivities_Activity {
        ::std::default::Default::default()
    }

    // .PBActivityType type = 1;


    pub fn get_field_type(&self) -> PBActivityType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBActivityType::PBActivityType_Null;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBActivityType) {
        self.field_type = v;
    }

    // .PBAccount targetAccount = 2;


    pub fn get_targetAccount(&self) -> &PBAccount {
        self.targetAccount.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_targetAccount(&mut self) {
        self.targetAccount.clear();
    }

    pub fn has_targetAccount(&self) -> bool {
        self.targetAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetAccount(&mut self, v: PBAccount) {
        self.targetAccount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAccount(&mut self) -> &mut PBAccount {
        if self.targetAccount.is_none() {
            self.targetAccount.set_default();
        }
        self.targetAccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetAccount(&mut self) -> PBAccount {
        self.targetAccount.take().unwrap_or_else(|| PBAccount::new())
    }

    // .PBMedia media = 3;


    pub fn get_media(&self) -> &PBMedia {
        self.media.as_ref().unwrap_or_else(|| <PBMedia as ::protobuf::Message>::default_instance())
    }
    pub fn clear_media(&mut self) {
        self.media.clear();
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: PBMedia) {
        self.media = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media(&mut self) -> &mut PBMedia {
        if self.media.is_none() {
            self.media.set_default();
        }
        self.media.as_mut().unwrap()
    }

    // Take field
    pub fn take_media(&mut self) -> PBMedia {
        self.media.take().unwrap_or_else(|| PBMedia::new())
    }

    // int64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for PBTaskContentFetchAccountActivities_Activity {
    fn is_initialized(&self) -> bool {
        for v in &self.targetAccount {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetAccount)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.media)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PBActivityType::PBActivityType_Null {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.targetAccount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.media.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PBActivityType::PBActivityType_Null {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.targetAccount.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.media.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchAccountActivities_Activity {
        PBTaskContentFetchAccountActivities_Activity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBActivityType>>(
                "type",
                |m: &PBTaskContentFetchAccountActivities_Activity| { &m.field_type },
                |m: &mut PBTaskContentFetchAccountActivities_Activity| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "targetAccount",
                |m: &PBTaskContentFetchAccountActivities_Activity| { &m.targetAccount },
                |m: &mut PBTaskContentFetchAccountActivities_Activity| { &mut m.targetAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "media",
                |m: &PBTaskContentFetchAccountActivities_Activity| { &m.media },
                |m: &mut PBTaskContentFetchAccountActivities_Activity| { &mut m.media },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &PBTaskContentFetchAccountActivities_Activity| { &m.timestamp },
                |m: &mut PBTaskContentFetchAccountActivities_Activity| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchAccountActivities_Activity>(
                "PBTaskContentFetchAccountActivities.Activity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchAccountActivities_Activity {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchAccountActivities_Activity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchAccountActivities_Activity::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchAccountActivities_Activity {
    fn clear(&mut self) {
        self.field_type = PBActivityType::PBActivityType_Null;
        self.targetAccount.clear();
        self.media.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchAccountActivities_Activity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchAccountActivities_Activity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaksContentFetchAccountStories {
    // message fields
    pub accountID: ::std::string::String,
    pub stories: ::protobuf::RepeatedField<PBTaksContentFetchAccountStories_StoryElement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaksContentFetchAccountStories {
    fn default() -> &'a PBTaksContentFetchAccountStories {
        <PBTaksContentFetchAccountStories as ::protobuf::Message>::default_instance()
    }
}

impl PBTaksContentFetchAccountStories {
    pub fn new() -> PBTaksContentFetchAccountStories {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // repeated .PBTaksContentFetchAccountStories.StoryElement stories = 2;


    pub fn get_stories(&self) -> &[PBTaksContentFetchAccountStories_StoryElement] {
        &self.stories
    }
    pub fn clear_stories(&mut self) {
        self.stories.clear();
    }

    // Param is passed by value, moved
    pub fn set_stories(&mut self, v: ::protobuf::RepeatedField<PBTaksContentFetchAccountStories_StoryElement>) {
        self.stories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stories(&mut self) -> &mut ::protobuf::RepeatedField<PBTaksContentFetchAccountStories_StoryElement> {
        &mut self.stories
    }

    // Take field
    pub fn take_stories(&mut self) -> ::protobuf::RepeatedField<PBTaksContentFetchAccountStories_StoryElement> {
        ::std::mem::replace(&mut self.stories, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBTaksContentFetchAccountStories {
    fn is_initialized(&self) -> bool {
        for v in &self.stories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        for value in &self.stories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        for v in &self.stories {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaksContentFetchAccountStories {
        PBTaksContentFetchAccountStories::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBTaksContentFetchAccountStories| { &m.accountID },
                |m: &mut PBTaksContentFetchAccountStories| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBTaksContentFetchAccountStories_StoryElement>>(
                "stories",
                |m: &PBTaksContentFetchAccountStories| { &m.stories },
                |m: &mut PBTaksContentFetchAccountStories| { &mut m.stories },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaksContentFetchAccountStories>(
                "PBTaksContentFetchAccountStories",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaksContentFetchAccountStories {
        static instance: ::protobuf::rt::LazyV2<PBTaksContentFetchAccountStories> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaksContentFetchAccountStories::new)
    }
}

impl ::protobuf::Clear for PBTaksContentFetchAccountStories {
    fn clear(&mut self) {
        self.accountID.clear();
        self.stories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaksContentFetchAccountStories {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaksContentFetchAccountStories {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaksContentFetchAccountStories_StoryElement {
    // message fields
    pub story: ::protobuf::SingularPtrField<PBMedia>,
    pub viewers: ::protobuf::RepeatedField<PBAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaksContentFetchAccountStories_StoryElement {
    fn default() -> &'a PBTaksContentFetchAccountStories_StoryElement {
        <PBTaksContentFetchAccountStories_StoryElement as ::protobuf::Message>::default_instance()
    }
}

impl PBTaksContentFetchAccountStories_StoryElement {
    pub fn new() -> PBTaksContentFetchAccountStories_StoryElement {
        ::std::default::Default::default()
    }

    // .PBMedia story = 1;


    pub fn get_story(&self) -> &PBMedia {
        self.story.as_ref().unwrap_or_else(|| <PBMedia as ::protobuf::Message>::default_instance())
    }
    pub fn clear_story(&mut self) {
        self.story.clear();
    }

    pub fn has_story(&self) -> bool {
        self.story.is_some()
    }

    // Param is passed by value, moved
    pub fn set_story(&mut self, v: PBMedia) {
        self.story = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_story(&mut self) -> &mut PBMedia {
        if self.story.is_none() {
            self.story.set_default();
        }
        self.story.as_mut().unwrap()
    }

    // Take field
    pub fn take_story(&mut self) -> PBMedia {
        self.story.take().unwrap_or_else(|| PBMedia::new())
    }

    // repeated .PBAccount viewers = 2;


    pub fn get_viewers(&self) -> &[PBAccount] {
        &self.viewers
    }
    pub fn clear_viewers(&mut self) {
        self.viewers.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: ::protobuf::RepeatedField<PBAccount>) {
        self.viewers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewers(&mut self) -> &mut ::protobuf::RepeatedField<PBAccount> {
        &mut self.viewers
    }

    // Take field
    pub fn take_viewers(&mut self) -> ::protobuf::RepeatedField<PBAccount> {
        ::std::mem::replace(&mut self.viewers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBTaksContentFetchAccountStories_StoryElement {
    fn is_initialized(&self) -> bool {
        for v in &self.story {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.story)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.viewers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.story.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.viewers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.story.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.viewers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaksContentFetchAccountStories_StoryElement {
        PBTaksContentFetchAccountStories_StoryElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "story",
                |m: &PBTaksContentFetchAccountStories_StoryElement| { &m.story },
                |m: &mut PBTaksContentFetchAccountStories_StoryElement| { &mut m.story },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "viewers",
                |m: &PBTaksContentFetchAccountStories_StoryElement| { &m.viewers },
                |m: &mut PBTaksContentFetchAccountStories_StoryElement| { &mut m.viewers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaksContentFetchAccountStories_StoryElement>(
                "PBTaksContentFetchAccountStories.StoryElement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaksContentFetchAccountStories_StoryElement {
        static instance: ::protobuf::rt::LazyV2<PBTaksContentFetchAccountStories_StoryElement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaksContentFetchAccountStories_StoryElement::new)
    }
}

impl ::protobuf::Clear for PBTaksContentFetchAccountStories_StoryElement {
    fn clear(&mut self) {
        self.story.clear();
        self.viewers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaksContentFetchAccountStories_StoryElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaksContentFetchAccountStories_StoryElement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskContentFetchMediaInfo {
    // message fields
    pub media: ::protobuf::SingularPtrField<PBMedia>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskContentFetchMediaInfo {
    fn default() -> &'a PBTaskContentFetchMediaInfo {
        <PBTaskContentFetchMediaInfo as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskContentFetchMediaInfo {
    pub fn new() -> PBTaskContentFetchMediaInfo {
        ::std::default::Default::default()
    }

    // .PBMedia media = 1;


    pub fn get_media(&self) -> &PBMedia {
        self.media.as_ref().unwrap_or_else(|| <PBMedia as ::protobuf::Message>::default_instance())
    }
    pub fn clear_media(&mut self) {
        self.media.clear();
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: PBMedia) {
        self.media = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media(&mut self) -> &mut PBMedia {
        if self.media.is_none() {
            self.media.set_default();
        }
        self.media.as_mut().unwrap()
    }

    // Take field
    pub fn take_media(&mut self) -> PBMedia {
        self.media.take().unwrap_or_else(|| PBMedia::new())
    }
}

impl ::protobuf::Message for PBTaskContentFetchMediaInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.media {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.media)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.media.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.media.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskContentFetchMediaInfo {
        PBTaskContentFetchMediaInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "media",
                |m: &PBTaskContentFetchMediaInfo| { &m.media },
                |m: &mut PBTaskContentFetchMediaInfo| { &mut m.media },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskContentFetchMediaInfo>(
                "PBTaskContentFetchMediaInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskContentFetchMediaInfo {
        static instance: ::protobuf::rt::LazyV2<PBTaskContentFetchMediaInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskContentFetchMediaInfo::new)
    }
}

impl ::protobuf::Clear for PBTaskContentFetchMediaInfo {
    fn clear(&mut self) {
        self.media.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskContentFetchMediaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskContentFetchMediaInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTask {
    // message fields
    pub taskType: PBTaskType,
    pub taskID: u64,
    pub taskState: PBTaskState,
    pub failureAction: PBTaskFailureAction,
    pub executorAccountID: ::std::string::String,
    pub executorCookie: ::std::string::String,
    // message oneof groups
    pub taskContent: ::std::option::Option<PBTask_oneof_taskContent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTask {
    fn default() -> &'a PBTask {
        <PBTask as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PBTask_oneof_taskContent {
    contentFetchAccountInfo(PBTaskContentFetchAccountInfo),
    contentFetchMediaLikers(PBTaskContentFetchMediaLikers),
    contentFetchMediaComments(PBTaskContentFetchMediaComments),
    contentFetchFollowings(PBTaskContentFetchAccountFollowings),
    contentFetchFollowers(PBTaskContentFetchAccountFollowers),
    contentFetchAccountMedias(PBTaskContentFetchAccountMedias),
    contentFetchLikedMedias(PBTaskContentFetchAccountLikedMedias),
    contentFetchBlockings(PBTaskContentFetchAccountBlockings),
    contentFetchAccountRelation(PBTaksContentFetchAccountRelation),
    contentFetchAccountActivities(PBTaskContentFetchAccountActivities),
    contentFetchAccountStories(PBTaksContentFetchAccountStories),
    contentFetchMediaInfo(PBTaskContentFetchMediaInfo),
}

impl PBTask {
    pub fn new() -> PBTask {
        ::std::default::Default::default()
    }

    // .PBTaskType taskType = 1;


    pub fn get_taskType(&self) -> PBTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBTaskType::PBTaskType_Noop;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBTaskType) {
        self.taskType = v;
    }

    // uint64 taskID = 2;


    pub fn get_taskID(&self) -> u64 {
        self.taskID
    }
    pub fn clear_taskID(&mut self) {
        self.taskID = 0;
    }

    // Param is passed by value, moved
    pub fn set_taskID(&mut self, v: u64) {
        self.taskID = v;
    }

    // .PBTaskState taskState = 3;


    pub fn get_taskState(&self) -> PBTaskState {
        self.taskState
    }
    pub fn clear_taskState(&mut self) {
        self.taskState = PBTaskState::PBTaskState_Pending;
    }

    // Param is passed by value, moved
    pub fn set_taskState(&mut self, v: PBTaskState) {
        self.taskState = v;
    }

    // .PBTaskFailureAction failureAction = 4;


    pub fn get_failureAction(&self) -> PBTaskFailureAction {
        self.failureAction
    }
    pub fn clear_failureAction(&mut self) {
        self.failureAction = PBTaskFailureAction::PBTaskFailureAction_DispatchToOther;
    }

    // Param is passed by value, moved
    pub fn set_failureAction(&mut self, v: PBTaskFailureAction) {
        self.failureAction = v;
    }

    // .PBTaskContentFetchAccountInfo contentFetchAccountInfo = 5;


    pub fn get_contentFetchAccountInfo(&self) -> &PBTaskContentFetchAccountInfo {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(ref v)) => v,
            _ => <PBTaskContentFetchAccountInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchAccountInfo(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchAccountInfo(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchAccountInfo(&mut self, v: PBTaskContentFetchAccountInfo) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchAccountInfo(&mut self) -> &mut PBTaskContentFetchAccountInfo {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(PBTaskContentFetchAccountInfo::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchAccountInfo(&mut self) -> PBTaskContentFetchAccountInfo {
        if self.has_contentFetchAccountInfo() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountInfo::new()
        }
    }

    // .PBTaskContentFetchMediaLikers contentFetchMediaLikers = 6;


    pub fn get_contentFetchMediaLikers(&self) -> &PBTaskContentFetchMediaLikers {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(ref v)) => v,
            _ => <PBTaskContentFetchMediaLikers as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchMediaLikers(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchMediaLikers(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchMediaLikers(&mut self, v: PBTaskContentFetchMediaLikers) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchMediaLikers(&mut self) -> &mut PBTaskContentFetchMediaLikers {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(PBTaskContentFetchMediaLikers::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchMediaLikers(&mut self) -> PBTaskContentFetchMediaLikers {
        if self.has_contentFetchMediaLikers() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchMediaLikers::new()
        }
    }

    // .PBTaskContentFetchMediaComments contentFetchMediaComments = 7;


    pub fn get_contentFetchMediaComments(&self) -> &PBTaskContentFetchMediaComments {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(ref v)) => v,
            _ => <PBTaskContentFetchMediaComments as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchMediaComments(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchMediaComments(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchMediaComments(&mut self, v: PBTaskContentFetchMediaComments) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchMediaComments(&mut self) -> &mut PBTaskContentFetchMediaComments {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(PBTaskContentFetchMediaComments::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchMediaComments(&mut self) -> PBTaskContentFetchMediaComments {
        if self.has_contentFetchMediaComments() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchMediaComments::new()
        }
    }

    // .PBTaskContentFetchAccountFollowings contentFetchFollowings = 8;


    pub fn get_contentFetchFollowings(&self) -> &PBTaskContentFetchAccountFollowings {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(ref v)) => v,
            _ => <PBTaskContentFetchAccountFollowings as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchFollowings(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchFollowings(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchFollowings(&mut self, v: PBTaskContentFetchAccountFollowings) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchFollowings(&mut self) -> &mut PBTaskContentFetchAccountFollowings {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(PBTaskContentFetchAccountFollowings::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchFollowings(&mut self) -> PBTaskContentFetchAccountFollowings {
        if self.has_contentFetchFollowings() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountFollowings::new()
        }
    }

    // .PBTaskContentFetchAccountFollowers contentFetchFollowers = 9;


    pub fn get_contentFetchFollowers(&self) -> &PBTaskContentFetchAccountFollowers {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(ref v)) => v,
            _ => <PBTaskContentFetchAccountFollowers as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchFollowers(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchFollowers(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchFollowers(&mut self, v: PBTaskContentFetchAccountFollowers) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchFollowers(&mut self) -> &mut PBTaskContentFetchAccountFollowers {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(PBTaskContentFetchAccountFollowers::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchFollowers(&mut self) -> PBTaskContentFetchAccountFollowers {
        if self.has_contentFetchFollowers() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountFollowers::new()
        }
    }

    // .PBTaskContentFetchAccountMedias contentFetchAccountMedias = 10;


    pub fn get_contentFetchAccountMedias(&self) -> &PBTaskContentFetchAccountMedias {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(ref v)) => v,
            _ => <PBTaskContentFetchAccountMedias as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchAccountMedias(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchAccountMedias(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchAccountMedias(&mut self, v: PBTaskContentFetchAccountMedias) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchAccountMedias(&mut self) -> &mut PBTaskContentFetchAccountMedias {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(PBTaskContentFetchAccountMedias::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchAccountMedias(&mut self) -> PBTaskContentFetchAccountMedias {
        if self.has_contentFetchAccountMedias() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountMedias::new()
        }
    }

    // .PBTaskContentFetchAccountLikedMedias contentFetchLikedMedias = 11;


    pub fn get_contentFetchLikedMedias(&self) -> &PBTaskContentFetchAccountLikedMedias {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(ref v)) => v,
            _ => <PBTaskContentFetchAccountLikedMedias as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchLikedMedias(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchLikedMedias(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchLikedMedias(&mut self, v: PBTaskContentFetchAccountLikedMedias) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchLikedMedias(&mut self) -> &mut PBTaskContentFetchAccountLikedMedias {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(PBTaskContentFetchAccountLikedMedias::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchLikedMedias(&mut self) -> PBTaskContentFetchAccountLikedMedias {
        if self.has_contentFetchLikedMedias() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountLikedMedias::new()
        }
    }

    // .PBTaskContentFetchAccountBlockings contentFetchBlockings = 12;


    pub fn get_contentFetchBlockings(&self) -> &PBTaskContentFetchAccountBlockings {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(ref v)) => v,
            _ => <PBTaskContentFetchAccountBlockings as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchBlockings(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchBlockings(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchBlockings(&mut self, v: PBTaskContentFetchAccountBlockings) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchBlockings(&mut self) -> &mut PBTaskContentFetchAccountBlockings {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(PBTaskContentFetchAccountBlockings::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchBlockings(&mut self) -> PBTaskContentFetchAccountBlockings {
        if self.has_contentFetchBlockings() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountBlockings::new()
        }
    }

    // .PBTaksContentFetchAccountRelation contentFetchAccountRelation = 13;


    pub fn get_contentFetchAccountRelation(&self) -> &PBTaksContentFetchAccountRelation {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(ref v)) => v,
            _ => <PBTaksContentFetchAccountRelation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchAccountRelation(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchAccountRelation(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchAccountRelation(&mut self, v: PBTaksContentFetchAccountRelation) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchAccountRelation(&mut self) -> &mut PBTaksContentFetchAccountRelation {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(PBTaksContentFetchAccountRelation::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchAccountRelation(&mut self) -> PBTaksContentFetchAccountRelation {
        if self.has_contentFetchAccountRelation() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaksContentFetchAccountRelation::new()
        }
    }

    // .PBTaskContentFetchAccountActivities contentFetchAccountActivities = 14;


    pub fn get_contentFetchAccountActivities(&self) -> &PBTaskContentFetchAccountActivities {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(ref v)) => v,
            _ => <PBTaskContentFetchAccountActivities as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchAccountActivities(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchAccountActivities(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchAccountActivities(&mut self, v: PBTaskContentFetchAccountActivities) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchAccountActivities(&mut self) -> &mut PBTaskContentFetchAccountActivities {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(PBTaskContentFetchAccountActivities::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchAccountActivities(&mut self) -> PBTaskContentFetchAccountActivities {
        if self.has_contentFetchAccountActivities() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountActivities::new()
        }
    }

    // .PBTaksContentFetchAccountStories contentFetchAccountStories = 15;


    pub fn get_contentFetchAccountStories(&self) -> &PBTaksContentFetchAccountStories {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(ref v)) => v,
            _ => <PBTaksContentFetchAccountStories as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchAccountStories(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchAccountStories(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchAccountStories(&mut self, v: PBTaksContentFetchAccountStories) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchAccountStories(&mut self) -> &mut PBTaksContentFetchAccountStories {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(PBTaksContentFetchAccountStories::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchAccountStories(&mut self) -> PBTaksContentFetchAccountStories {
        if self.has_contentFetchAccountStories() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaksContentFetchAccountStories::new()
        }
    }

    // .PBTaskContentFetchMediaInfo contentFetchMediaInfo = 16;


    pub fn get_contentFetchMediaInfo(&self) -> &PBTaskContentFetchMediaInfo {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(ref v)) => v,
            _ => <PBTaskContentFetchMediaInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchMediaInfo(&mut self) {
        self.taskContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchMediaInfo(&self) -> bool {
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchMediaInfo(&mut self, v: PBTaskContentFetchMediaInfo) {
        self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchMediaInfo(&mut self) -> &mut PBTaskContentFetchMediaInfo {
        if let ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(_)) = self.taskContent {
        } else {
            self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(PBTaskContentFetchMediaInfo::new()));
        }
        match self.taskContent {
            ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchMediaInfo(&mut self) -> PBTaskContentFetchMediaInfo {
        if self.has_contentFetchMediaInfo() {
            match self.taskContent.take() {
                ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchMediaInfo::new()
        }
    }

    // string executorAccountID = 30;


    pub fn get_executorAccountID(&self) -> &str {
        &self.executorAccountID
    }
    pub fn clear_executorAccountID(&mut self) {
        self.executorAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_executorAccountID(&mut self, v: ::std::string::String) {
        self.executorAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executorAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.executorAccountID
    }

    // Take field
    pub fn take_executorAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.executorAccountID, ::std::string::String::new())
    }

    // string executorCookie = 31;


    pub fn get_executorCookie(&self) -> &str {
        &self.executorCookie
    }
    pub fn clear_executorCookie(&mut self) {
        self.executorCookie.clear();
    }

    // Param is passed by value, moved
    pub fn set_executorCookie(&mut self, v: ::std::string::String) {
        self.executorCookie = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executorCookie(&mut self) -> &mut ::std::string::String {
        &mut self.executorCookie
    }

    // Take field
    pub fn take_executorCookie(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.executorCookie, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBTask {
    fn is_initialized(&self) -> bool {
        if let Some(PBTask_oneof_taskContent::contentFetchAccountInfo(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchMediaLikers(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchMediaComments(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchFollowings(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchFollowers(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchAccountMedias(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchLikedMedias(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchBlockings(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchAccountRelation(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchAccountActivities(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchAccountStories(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PBTask_oneof_taskContent::contentFetchMediaInfo(ref v)) = self.taskContent {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.taskID = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskState, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.failureAction, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountInfo(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaLikers(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaComments(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowings(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchFollowers(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountMedias(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchLikedMedias(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchBlockings(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountRelation(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountActivities(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchAccountStories(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.taskContent = ::std::option::Option::Some(PBTask_oneof_taskContent::contentFetchMediaInfo(is.read_message()?));
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.executorAccountID)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.executorCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.taskType != PBTaskType::PBTaskType_Noop {
            my_size += ::protobuf::rt::enum_size(1, self.taskType);
        }
        if self.taskID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.taskID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.taskState != PBTaskState::PBTaskState_Pending {
            my_size += ::protobuf::rt::enum_size(3, self.taskState);
        }
        if self.failureAction != PBTaskFailureAction::PBTaskFailureAction_DispatchToOther {
            my_size += ::protobuf::rt::enum_size(4, self.failureAction);
        }
        if !self.executorAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.executorAccountID);
        }
        if !self.executorCookie.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.executorCookie);
        }
        if let ::std::option::Option::Some(ref v) = self.taskContent {
            match v {
                &PBTask_oneof_taskContent::contentFetchAccountInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchMediaLikers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchMediaComments(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchFollowings(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchFollowers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchAccountMedias(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchLikedMedias(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchBlockings(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchAccountRelation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchAccountActivities(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchAccountStories(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PBTask_oneof_taskContent::contentFetchMediaInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.taskType != PBTaskType::PBTaskType_Noop {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.taskID != 0 {
            os.write_uint64(2, self.taskID)?;
        }
        if self.taskState != PBTaskState::PBTaskState_Pending {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.taskState))?;
        }
        if self.failureAction != PBTaskFailureAction::PBTaskFailureAction_DispatchToOther {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.failureAction))?;
        }
        if !self.executorAccountID.is_empty() {
            os.write_string(30, &self.executorAccountID)?;
        }
        if !self.executorCookie.is_empty() {
            os.write_string(31, &self.executorCookie)?;
        }
        if let ::std::option::Option::Some(ref v) = self.taskContent {
            match v {
                &PBTask_oneof_taskContent::contentFetchAccountInfo(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchMediaLikers(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchMediaComments(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchFollowings(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchFollowers(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchAccountMedias(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchLikedMedias(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchBlockings(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchAccountRelation(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchAccountActivities(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchAccountStories(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PBTask_oneof_taskContent::contentFetchMediaInfo(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTask {
        PBTask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskType>>(
                "taskType",
                |m: &PBTask| { &m.taskType },
                |m: &mut PBTask| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "taskID",
                |m: &PBTask| { &m.taskID },
                |m: &mut PBTask| { &mut m.taskID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskState>>(
                "taskState",
                |m: &PBTask| { &m.taskState },
                |m: &mut PBTask| { &mut m.taskState },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskFailureAction>>(
                "failureAction",
                |m: &PBTask| { &m.failureAction },
                |m: &mut PBTask| { &mut m.failureAction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountInfo>(
                "contentFetchAccountInfo",
                PBTask::has_contentFetchAccountInfo,
                PBTask::get_contentFetchAccountInfo,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchMediaLikers>(
                "contentFetchMediaLikers",
                PBTask::has_contentFetchMediaLikers,
                PBTask::get_contentFetchMediaLikers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchMediaComments>(
                "contentFetchMediaComments",
                PBTask::has_contentFetchMediaComments,
                PBTask::get_contentFetchMediaComments,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountFollowings>(
                "contentFetchFollowings",
                PBTask::has_contentFetchFollowings,
                PBTask::get_contentFetchFollowings,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountFollowers>(
                "contentFetchFollowers",
                PBTask::has_contentFetchFollowers,
                PBTask::get_contentFetchFollowers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountMedias>(
                "contentFetchAccountMedias",
                PBTask::has_contentFetchAccountMedias,
                PBTask::get_contentFetchAccountMedias,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountLikedMedias>(
                "contentFetchLikedMedias",
                PBTask::has_contentFetchLikedMedias,
                PBTask::get_contentFetchLikedMedias,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountBlockings>(
                "contentFetchBlockings",
                PBTask::has_contentFetchBlockings,
                PBTask::get_contentFetchBlockings,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaksContentFetchAccountRelation>(
                "contentFetchAccountRelation",
                PBTask::has_contentFetchAccountRelation,
                PBTask::get_contentFetchAccountRelation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountActivities>(
                "contentFetchAccountActivities",
                PBTask::has_contentFetchAccountActivities,
                PBTask::get_contentFetchAccountActivities,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaksContentFetchAccountStories>(
                "contentFetchAccountStories",
                PBTask::has_contentFetchAccountStories,
                PBTask::get_contentFetchAccountStories,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchMediaInfo>(
                "contentFetchMediaInfo",
                PBTask::has_contentFetchMediaInfo,
                PBTask::get_contentFetchMediaInfo,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "executorAccountID",
                |m: &PBTask| { &m.executorAccountID },
                |m: &mut PBTask| { &mut m.executorAccountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "executorCookie",
                |m: &PBTask| { &m.executorCookie },
                |m: &mut PBTask| { &mut m.executorCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTask>(
                "PBTask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTask {
        static instance: ::protobuf::rt::LazyV2<PBTask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTask::new)
    }
}

impl ::protobuf::Clear for PBTask {
    fn clear(&mut self) {
        self.taskType = PBTaskType::PBTaskType_Noop;
        self.taskID = 0;
        self.taskState = PBTaskState::PBTaskState_Pending;
        self.failureAction = PBTaskFailureAction::PBTaskFailureAction_DispatchToOther;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.taskContent = ::std::option::Option::None;
        self.executorAccountID.clear();
        self.executorCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBSpawnTaskRequest {
    // message fields
    pub details: ::protobuf::RepeatedField<PBSpawnTaskRequest_SpawnDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBSpawnTaskRequest {
    fn default() -> &'a PBSpawnTaskRequest {
        <PBSpawnTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBSpawnTaskRequest {
    pub fn new() -> PBSpawnTaskRequest {
        ::std::default::Default::default()
    }

    // repeated .PBSpawnTaskRequest.SpawnDetail details = 1;


    pub fn get_details(&self) -> &[PBSpawnTaskRequest_SpawnDetail] {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::RepeatedField<PBSpawnTaskRequest_SpawnDetail>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::protobuf::RepeatedField<PBSpawnTaskRequest_SpawnDetail> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::RepeatedField<PBSpawnTaskRequest_SpawnDetail> {
        ::std::mem::replace(&mut self.details, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBSpawnTaskRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.details {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBSpawnTaskRequest {
        PBSpawnTaskRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBSpawnTaskRequest_SpawnDetail>>(
                "details",
                |m: &PBSpawnTaskRequest| { &m.details },
                |m: &mut PBSpawnTaskRequest| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBSpawnTaskRequest>(
                "PBSpawnTaskRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBSpawnTaskRequest {
        static instance: ::protobuf::rt::LazyV2<PBSpawnTaskRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBSpawnTaskRequest::new)
    }
}

impl ::protobuf::Clear for PBSpawnTaskRequest {
    fn clear(&mut self) {
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBSpawnTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSpawnTaskRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBSpawnTaskRequest_SpawnDetail {
    // message fields
    pub taskType: PBTaskType,
    pub forceSpawn: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBSpawnTaskRequest_SpawnDetail {
    fn default() -> &'a PBSpawnTaskRequest_SpawnDetail {
        <PBSpawnTaskRequest_SpawnDetail as ::protobuf::Message>::default_instance()
    }
}

impl PBSpawnTaskRequest_SpawnDetail {
    pub fn new() -> PBSpawnTaskRequest_SpawnDetail {
        ::std::default::Default::default()
    }

    // .PBTaskType taskType = 1;


    pub fn get_taskType(&self) -> PBTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBTaskType::PBTaskType_Noop;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBTaskType) {
        self.taskType = v;
    }

    // bool forceSpawn = 2;


    pub fn get_forceSpawn(&self) -> bool {
        self.forceSpawn
    }
    pub fn clear_forceSpawn(&mut self) {
        self.forceSpawn = false;
    }

    // Param is passed by value, moved
    pub fn set_forceSpawn(&mut self, v: bool) {
        self.forceSpawn = v;
    }
}

impl ::protobuf::Message for PBSpawnTaskRequest_SpawnDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forceSpawn = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.taskType != PBTaskType::PBTaskType_Noop {
            my_size += ::protobuf::rt::enum_size(1, self.taskType);
        }
        if self.forceSpawn != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.taskType != PBTaskType::PBTaskType_Noop {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.forceSpawn != false {
            os.write_bool(2, self.forceSpawn)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBSpawnTaskRequest_SpawnDetail {
        PBSpawnTaskRequest_SpawnDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskType>>(
                "taskType",
                |m: &PBSpawnTaskRequest_SpawnDetail| { &m.taskType },
                |m: &mut PBSpawnTaskRequest_SpawnDetail| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forceSpawn",
                |m: &PBSpawnTaskRequest_SpawnDetail| { &m.forceSpawn },
                |m: &mut PBSpawnTaskRequest_SpawnDetail| { &mut m.forceSpawn },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBSpawnTaskRequest_SpawnDetail>(
                "PBSpawnTaskRequest.SpawnDetail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBSpawnTaskRequest_SpawnDetail {
        static instance: ::protobuf::rt::LazyV2<PBSpawnTaskRequest_SpawnDetail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBSpawnTaskRequest_SpawnDetail::new)
    }
}

impl ::protobuf::Clear for PBSpawnTaskRequest_SpawnDetail {
    fn clear(&mut self) {
        self.taskType = PBTaskType::PBTaskType_Noop;
        self.forceSpawn = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBSpawnTaskRequest_SpawnDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSpawnTaskRequest_SpawnDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBSpawnTaskReply {
    // message fields
    pub results: ::protobuf::RepeatedField<PBSpawnTaskReply_SpawnResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBSpawnTaskReply {
    fn default() -> &'a PBSpawnTaskReply {
        <PBSpawnTaskReply as ::protobuf::Message>::default_instance()
    }
}

impl PBSpawnTaskReply {
    pub fn new() -> PBSpawnTaskReply {
        ::std::default::Default::default()
    }

    // repeated .PBSpawnTaskReply.SpawnResult results = 1;


    pub fn get_results(&self) -> &[PBSpawnTaskReply_SpawnResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<PBSpawnTaskReply_SpawnResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<PBSpawnTaskReply_SpawnResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<PBSpawnTaskReply_SpawnResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBSpawnTaskReply {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBSpawnTaskReply {
        PBSpawnTaskReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBSpawnTaskReply_SpawnResult>>(
                "results",
                |m: &PBSpawnTaskReply| { &m.results },
                |m: &mut PBSpawnTaskReply| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBSpawnTaskReply>(
                "PBSpawnTaskReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBSpawnTaskReply {
        static instance: ::protobuf::rt::LazyV2<PBSpawnTaskReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBSpawnTaskReply::new)
    }
}

impl ::protobuf::Clear for PBSpawnTaskReply {
    fn clear(&mut self) {
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBSpawnTaskReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSpawnTaskReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBSpawnTaskReply_SpawnResult {
    // message fields
    pub taskType: PBTaskType,
    pub spawnStatus: PBSpawnTaskStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBSpawnTaskReply_SpawnResult {
    fn default() -> &'a PBSpawnTaskReply_SpawnResult {
        <PBSpawnTaskReply_SpawnResult as ::protobuf::Message>::default_instance()
    }
}

impl PBSpawnTaskReply_SpawnResult {
    pub fn new() -> PBSpawnTaskReply_SpawnResult {
        ::std::default::Default::default()
    }

    // .PBTaskType taskType = 1;


    pub fn get_taskType(&self) -> PBTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBTaskType::PBTaskType_Noop;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBTaskType) {
        self.taskType = v;
    }

    // .PBSpawnTaskStatus spawnStatus = 2;


    pub fn get_spawnStatus(&self) -> PBSpawnTaskStatus {
        self.spawnStatus
    }
    pub fn clear_spawnStatus(&mut self) {
        self.spawnStatus = PBSpawnTaskStatus::PBSpawnTaskStatus_OK;
    }

    // Param is passed by value, moved
    pub fn set_spawnStatus(&mut self, v: PBSpawnTaskStatus) {
        self.spawnStatus = v;
    }
}

impl ::protobuf::Message for PBSpawnTaskReply_SpawnResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.spawnStatus, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.taskType != PBTaskType::PBTaskType_Noop {
            my_size += ::protobuf::rt::enum_size(1, self.taskType);
        }
        if self.spawnStatus != PBSpawnTaskStatus::PBSpawnTaskStatus_OK {
            my_size += ::protobuf::rt::enum_size(2, self.spawnStatus);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.taskType != PBTaskType::PBTaskType_Noop {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.spawnStatus != PBSpawnTaskStatus::PBSpawnTaskStatus_OK {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.spawnStatus))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBSpawnTaskReply_SpawnResult {
        PBSpawnTaskReply_SpawnResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskType>>(
                "taskType",
                |m: &PBSpawnTaskReply_SpawnResult| { &m.taskType },
                |m: &mut PBSpawnTaskReply_SpawnResult| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBSpawnTaskStatus>>(
                "spawnStatus",
                |m: &PBSpawnTaskReply_SpawnResult| { &m.spawnStatus },
                |m: &mut PBSpawnTaskReply_SpawnResult| { &mut m.spawnStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBSpawnTaskReply_SpawnResult>(
                "PBSpawnTaskReply.SpawnResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBSpawnTaskReply_SpawnResult {
        static instance: ::protobuf::rt::LazyV2<PBSpawnTaskReply_SpawnResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBSpawnTaskReply_SpawnResult::new)
    }
}

impl ::protobuf::Clear for PBSpawnTaskReply_SpawnResult {
    fn clear(&mut self) {
        self.taskType = PBTaskType::PBTaskType_Noop;
        self.spawnStatus = PBSpawnTaskStatus::PBSpawnTaskStatus_OK;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBSpawnTaskReply_SpawnResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSpawnTaskReply_SpawnResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTaskCapability {
    // message fields
    pub taskTypes: ::std::vec::Vec<PBTaskType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTaskCapability {
    fn default() -> &'a PBTaskCapability {
        <PBTaskCapability as ::protobuf::Message>::default_instance()
    }
}

impl PBTaskCapability {
    pub fn new() -> PBTaskCapability {
        ::std::default::Default::default()
    }

    // repeated .PBTaskType taskTypes = 1;


    pub fn get_taskTypes(&self) -> &[PBTaskType] {
        &self.taskTypes
    }
    pub fn clear_taskTypes(&mut self) {
        self.taskTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_taskTypes(&mut self, v: ::std::vec::Vec<PBTaskType>) {
        self.taskTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taskTypes(&mut self) -> &mut ::std::vec::Vec<PBTaskType> {
        &mut self.taskTypes
    }

    // Take field
    pub fn take_taskTypes(&mut self) -> ::std::vec::Vec<PBTaskType> {
        ::std::mem::replace(&mut self.taskTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBTaskCapability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.taskTypes, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.taskTypes {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.taskTypes {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTaskCapability {
        PBTaskCapability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskType>>(
                "taskTypes",
                |m: &PBTaskCapability| { &m.taskTypes },
                |m: &mut PBTaskCapability| { &mut m.taskTypes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTaskCapability>(
                "PBTaskCapability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTaskCapability {
        static instance: ::protobuf::rt::LazyV2<PBTaskCapability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTaskCapability::new)
    }
}

impl ::protobuf::Clear for PBTaskCapability {
    fn clear(&mut self) {
        self.taskTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTaskCapability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskCapability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchTaskProgressRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchTaskProgressRequest {
    fn default() -> &'a PBFetchTaskProgressRequest {
        <PBFetchTaskProgressRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchTaskProgressRequest {
    pub fn new() -> PBFetchTaskProgressRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBFetchTaskProgressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchTaskProgressRequest {
        PBFetchTaskProgressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchTaskProgressRequest>(
                "PBFetchTaskProgressRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchTaskProgressRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchTaskProgressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchTaskProgressRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchTaskProgressRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchTaskProgressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchTaskProgressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchTaskProgressReply {
    // message fields
    pub progresses: ::protobuf::RepeatedField<PBFetchTaskProgressReply_TaskProgress>,
    pub pageProgress: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchTaskProgressReply {
    fn default() -> &'a PBFetchTaskProgressReply {
        <PBFetchTaskProgressReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchTaskProgressReply {
    pub fn new() -> PBFetchTaskProgressReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchTaskProgressReply.TaskProgress progresses = 1;


    pub fn get_progresses(&self) -> &[PBFetchTaskProgressReply_TaskProgress] {
        &self.progresses
    }
    pub fn clear_progresses(&mut self) {
        self.progresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_progresses(&mut self, v: ::protobuf::RepeatedField<PBFetchTaskProgressReply_TaskProgress>) {
        self.progresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_progresses(&mut self) -> &mut ::protobuf::RepeatedField<PBFetchTaskProgressReply_TaskProgress> {
        &mut self.progresses
    }

    // Take field
    pub fn take_progresses(&mut self) -> ::protobuf::RepeatedField<PBFetchTaskProgressReply_TaskProgress> {
        ::std::mem::replace(&mut self.progresses, ::protobuf::RepeatedField::new())
    }

    // int64 pageProgress = 2;


    pub fn get_pageProgress(&self) -> i64 {
        self.pageProgress
    }
    pub fn clear_pageProgress(&mut self) {
        self.pageProgress = 0;
    }

    // Param is passed by value, moved
    pub fn set_pageProgress(&mut self, v: i64) {
        self.pageProgress = v;
    }
}

impl ::protobuf::Message for PBFetchTaskProgressReply {
    fn is_initialized(&self) -> bool {
        for v in &self.progresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.progresses)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pageProgress = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.progresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.pageProgress != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pageProgress, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.progresses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.pageProgress != 0 {
            os.write_int64(2, self.pageProgress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchTaskProgressReply {
        PBFetchTaskProgressReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBFetchTaskProgressReply_TaskProgress>>(
                "progresses",
                |m: &PBFetchTaskProgressReply| { &m.progresses },
                |m: &mut PBFetchTaskProgressReply| { &mut m.progresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pageProgress",
                |m: &PBFetchTaskProgressReply| { &m.pageProgress },
                |m: &mut PBFetchTaskProgressReply| { &mut m.pageProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchTaskProgressReply>(
                "PBFetchTaskProgressReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchTaskProgressReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchTaskProgressReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchTaskProgressReply::new)
    }
}

impl ::protobuf::Clear for PBFetchTaskProgressReply {
    fn clear(&mut self) {
        self.progresses.clear();
        self.pageProgress = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchTaskProgressReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchTaskProgressReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchTaskProgressReply_TaskProgress {
    // message fields
    pub field_type: PBTaskProgressType,
    pub totalCount: i64,
    pub finishedCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchTaskProgressReply_TaskProgress {
    fn default() -> &'a PBFetchTaskProgressReply_TaskProgress {
        <PBFetchTaskProgressReply_TaskProgress as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchTaskProgressReply_TaskProgress {
    pub fn new() -> PBFetchTaskProgressReply_TaskProgress {
        ::std::default::Default::default()
    }

    // .PBTaskProgressType type = 1;


    pub fn get_field_type(&self) -> PBTaskProgressType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBTaskProgressType::PBTaskProgressType_None;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBTaskProgressType) {
        self.field_type = v;
    }

    // int64 totalCount = 2;


    pub fn get_totalCount(&self) -> i64 {
        self.totalCount
    }
    pub fn clear_totalCount(&mut self) {
        self.totalCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalCount(&mut self, v: i64) {
        self.totalCount = v;
    }

    // int64 finishedCount = 3;


    pub fn get_finishedCount(&self) -> i64 {
        self.finishedCount
    }
    pub fn clear_finishedCount(&mut self) {
        self.finishedCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_finishedCount(&mut self, v: i64) {
        self.finishedCount = v;
    }
}

impl ::protobuf::Message for PBFetchTaskProgressReply_TaskProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalCount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.finishedCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PBTaskProgressType::PBTaskProgressType_None {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.totalCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.totalCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.finishedCount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.finishedCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PBTaskProgressType::PBTaskProgressType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.totalCount != 0 {
            os.write_int64(2, self.totalCount)?;
        }
        if self.finishedCount != 0 {
            os.write_int64(3, self.finishedCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchTaskProgressReply_TaskProgress {
        PBFetchTaskProgressReply_TaskProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskProgressType>>(
                "type",
                |m: &PBFetchTaskProgressReply_TaskProgress| { &m.field_type },
                |m: &mut PBFetchTaskProgressReply_TaskProgress| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalCount",
                |m: &PBFetchTaskProgressReply_TaskProgress| { &m.totalCount },
                |m: &mut PBFetchTaskProgressReply_TaskProgress| { &mut m.totalCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "finishedCount",
                |m: &PBFetchTaskProgressReply_TaskProgress| { &m.finishedCount },
                |m: &mut PBFetchTaskProgressReply_TaskProgress| { &mut m.finishedCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchTaskProgressReply_TaskProgress>(
                "PBFetchTaskProgressReply.TaskProgress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchTaskProgressReply_TaskProgress {
        static instance: ::protobuf::rt::LazyV2<PBFetchTaskProgressReply_TaskProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchTaskProgressReply_TaskProgress::new)
    }
}

impl ::protobuf::Clear for PBFetchTaskProgressReply_TaskProgress {
    fn clear(&mut self) {
        self.field_type = PBTaskProgressType::PBTaskProgressType_None;
        self.totalCount = 0;
        self.finishedCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchTaskProgressReply_TaskProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchTaskProgressReply_TaskProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchCountDataRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub dataType: PBCountDataType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchCountDataRequest {
    fn default() -> &'a PBFetchCountDataRequest {
        <PBFetchCountDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchCountDataRequest {
    pub fn new() -> PBFetchCountDataRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // .PBCountDataType dataType = 2;


    pub fn get_dataType(&self) -> PBCountDataType {
        self.dataType
    }
    pub fn clear_dataType(&mut self) {
        self.dataType = PBCountDataType::PBCountDataType_None;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: PBCountDataType) {
        self.dataType = v;
    }
}

impl ::protobuf::Message for PBFetchCountDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.dataType != PBCountDataType::PBCountDataType_None {
            my_size += ::protobuf::rt::enum_size(2, self.dataType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.dataType != PBCountDataType::PBCountDataType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.dataType))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchCountDataRequest {
        PBFetchCountDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchCountDataRequest| { &m.accountID },
                |m: &mut PBFetchCountDataRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBCountDataType>>(
                "dataType",
                |m: &PBFetchCountDataRequest| { &m.dataType },
                |m: &mut PBFetchCountDataRequest| { &mut m.dataType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchCountDataRequest>(
                "PBFetchCountDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchCountDataRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchCountDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchCountDataRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchCountDataRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.dataType = PBCountDataType::PBCountDataType_None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchCountDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchCountDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchCountDataReply {
    // message fields
    pub count: i64,
    pub delta: i64,
    pub calculationInProgress: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchCountDataReply {
    fn default() -> &'a PBFetchCountDataReply {
        <PBFetchCountDataReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchCountDataReply {
    pub fn new() -> PBFetchCountDataReply {
        ::std::default::Default::default()
    }

    // int64 count = 1;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }

    // int64 delta = 2;


    pub fn get_delta(&self) -> i64 {
        self.delta
    }
    pub fn clear_delta(&mut self) {
        self.delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i64) {
        self.delta = v;
    }

    // bool calculationInProgress = 3;


    pub fn get_calculationInProgress(&self) -> bool {
        self.calculationInProgress
    }
    pub fn clear_calculationInProgress(&mut self) {
        self.calculationInProgress = false;
    }

    // Param is passed by value, moved
    pub fn set_calculationInProgress(&mut self, v: bool) {
        self.calculationInProgress = v;
    }
}

impl ::protobuf::Message for PBFetchCountDataReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delta = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.calculationInProgress = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.delta != 0 {
            my_size += ::protobuf::rt::value_size(2, self.delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.calculationInProgress != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_int64(1, self.count)?;
        }
        if self.delta != 0 {
            os.write_int64(2, self.delta)?;
        }
        if self.calculationInProgress != false {
            os.write_bool(3, self.calculationInProgress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchCountDataReply {
        PBFetchCountDataReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "count",
                |m: &PBFetchCountDataReply| { &m.count },
                |m: &mut PBFetchCountDataReply| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "delta",
                |m: &PBFetchCountDataReply| { &m.delta },
                |m: &mut PBFetchCountDataReply| { &mut m.delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "calculationInProgress",
                |m: &PBFetchCountDataReply| { &m.calculationInProgress },
                |m: &mut PBFetchCountDataReply| { &mut m.calculationInProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchCountDataReply>(
                "PBFetchCountDataReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchCountDataReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchCountDataReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchCountDataReply::new)
    }
}

impl ::protobuf::Clear for PBFetchCountDataReply {
    fn clear(&mut self) {
        self.count = 0;
        self.delta = 0;
        self.calculationInProgress = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchCountDataReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchCountDataReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBAccountListElement {
    // message fields
    pub targetAccount: ::protobuf::SingularPtrField<PBAccount>,
    pub outgoingRelation: PBRelationship,
    pub incomingRelation: PBRelationship,
    pub likeCount: i64,
    pub commentCount: i64,
    pub followerCount: i64,
    pub incomingActionTime: i64,
    pub media: ::protobuf::SingularPtrField<PBMedia>,
    pub relatedMedias: ::protobuf::RepeatedField<PBAccountListElement_MediaWithRelation>,
    pub needToUpdateRelations: bool,
    pub content: ::std::string::String,
    pub score: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBAccountListElement {
    fn default() -> &'a PBAccountListElement {
        <PBAccountListElement as ::protobuf::Message>::default_instance()
    }
}

impl PBAccountListElement {
    pub fn new() -> PBAccountListElement {
        ::std::default::Default::default()
    }

    // .PBAccount targetAccount = 1;


    pub fn get_targetAccount(&self) -> &PBAccount {
        self.targetAccount.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_targetAccount(&mut self) {
        self.targetAccount.clear();
    }

    pub fn has_targetAccount(&self) -> bool {
        self.targetAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetAccount(&mut self, v: PBAccount) {
        self.targetAccount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAccount(&mut self) -> &mut PBAccount {
        if self.targetAccount.is_none() {
            self.targetAccount.set_default();
        }
        self.targetAccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetAccount(&mut self) -> PBAccount {
        self.targetAccount.take().unwrap_or_else(|| PBAccount::new())
    }

    // .PBRelationship outgoingRelation = 2;


    pub fn get_outgoingRelation(&self) -> PBRelationship {
        self.outgoingRelation
    }
    pub fn clear_outgoingRelation(&mut self) {
        self.outgoingRelation = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_outgoingRelation(&mut self, v: PBRelationship) {
        self.outgoingRelation = v;
    }

    // .PBRelationship incomingRelation = 3;


    pub fn get_incomingRelation(&self) -> PBRelationship {
        self.incomingRelation
    }
    pub fn clear_incomingRelation(&mut self) {
        self.incomingRelation = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_incomingRelation(&mut self, v: PBRelationship) {
        self.incomingRelation = v;
    }

    // int64 likeCount = 4;


    pub fn get_likeCount(&self) -> i64 {
        self.likeCount
    }
    pub fn clear_likeCount(&mut self) {
        self.likeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_likeCount(&mut self, v: i64) {
        self.likeCount = v;
    }

    // int64 commentCount = 5;


    pub fn get_commentCount(&self) -> i64 {
        self.commentCount
    }
    pub fn clear_commentCount(&mut self) {
        self.commentCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_commentCount(&mut self, v: i64) {
        self.commentCount = v;
    }

    // int64 followerCount = 6;


    pub fn get_followerCount(&self) -> i64 {
        self.followerCount
    }
    pub fn clear_followerCount(&mut self) {
        self.followerCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_followerCount(&mut self, v: i64) {
        self.followerCount = v;
    }

    // int64 incomingActionTime = 7;


    pub fn get_incomingActionTime(&self) -> i64 {
        self.incomingActionTime
    }
    pub fn clear_incomingActionTime(&mut self) {
        self.incomingActionTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_incomingActionTime(&mut self, v: i64) {
        self.incomingActionTime = v;
    }

    // .PBMedia media = 8;


    pub fn get_media(&self) -> &PBMedia {
        self.media.as_ref().unwrap_or_else(|| <PBMedia as ::protobuf::Message>::default_instance())
    }
    pub fn clear_media(&mut self) {
        self.media.clear();
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: PBMedia) {
        self.media = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media(&mut self) -> &mut PBMedia {
        if self.media.is_none() {
            self.media.set_default();
        }
        self.media.as_mut().unwrap()
    }

    // Take field
    pub fn take_media(&mut self) -> PBMedia {
        self.media.take().unwrap_or_else(|| PBMedia::new())
    }

    // repeated .PBAccountListElement.MediaWithRelation relatedMedias = 9;


    pub fn get_relatedMedias(&self) -> &[PBAccountListElement_MediaWithRelation] {
        &self.relatedMedias
    }
    pub fn clear_relatedMedias(&mut self) {
        self.relatedMedias.clear();
    }

    // Param is passed by value, moved
    pub fn set_relatedMedias(&mut self, v: ::protobuf::RepeatedField<PBAccountListElement_MediaWithRelation>) {
        self.relatedMedias = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relatedMedias(&mut self) -> &mut ::protobuf::RepeatedField<PBAccountListElement_MediaWithRelation> {
        &mut self.relatedMedias
    }

    // Take field
    pub fn take_relatedMedias(&mut self) -> ::protobuf::RepeatedField<PBAccountListElement_MediaWithRelation> {
        ::std::mem::replace(&mut self.relatedMedias, ::protobuf::RepeatedField::new())
    }

    // bool needToUpdateRelations = 10;


    pub fn get_needToUpdateRelations(&self) -> bool {
        self.needToUpdateRelations
    }
    pub fn clear_needToUpdateRelations(&mut self) {
        self.needToUpdateRelations = false;
    }

    // Param is passed by value, moved
    pub fn set_needToUpdateRelations(&mut self, v: bool) {
        self.needToUpdateRelations = v;
    }

    // string content = 11;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    // int64 score = 12;


    pub fn get_score(&self) -> i64 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i64) {
        self.score = v;
    }
}

impl ::protobuf::Message for PBAccountListElement {
    fn is_initialized(&self) -> bool {
        for v in &self.targetAccount {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relatedMedias {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetAccount)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.outgoingRelation, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.incomingRelation, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.likeCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commentCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.followerCount = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.incomingActionTime = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.media)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relatedMedias)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needToUpdateRelations = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetAccount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.outgoingRelation != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(2, self.outgoingRelation);
        }
        if self.incomingRelation != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(3, self.incomingRelation);
        }
        if self.likeCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.likeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commentCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.commentCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.followerCount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.followerCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.incomingActionTime != 0 {
            my_size += ::protobuf::rt::value_size(7, self.incomingActionTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.media.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.relatedMedias {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.needToUpdateRelations != false {
            my_size += 2;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.content);
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(12, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetAccount.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.outgoingRelation != PBRelationship::PBRelationship_Null {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.outgoingRelation))?;
        }
        if self.incomingRelation != PBRelationship::PBRelationship_Null {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.incomingRelation))?;
        }
        if self.likeCount != 0 {
            os.write_int64(4, self.likeCount)?;
        }
        if self.commentCount != 0 {
            os.write_int64(5, self.commentCount)?;
        }
        if self.followerCount != 0 {
            os.write_int64(6, self.followerCount)?;
        }
        if self.incomingActionTime != 0 {
            os.write_int64(7, self.incomingActionTime)?;
        }
        if let Some(ref v) = self.media.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.relatedMedias {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.needToUpdateRelations != false {
            os.write_bool(10, self.needToUpdateRelations)?;
        }
        if !self.content.is_empty() {
            os.write_string(11, &self.content)?;
        }
        if self.score != 0 {
            os.write_int64(12, self.score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBAccountListElement {
        PBAccountListElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "targetAccount",
                |m: &PBAccountListElement| { &m.targetAccount },
                |m: &mut PBAccountListElement| { &mut m.targetAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "outgoingRelation",
                |m: &PBAccountListElement| { &m.outgoingRelation },
                |m: &mut PBAccountListElement| { &mut m.outgoingRelation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "incomingRelation",
                |m: &PBAccountListElement| { &m.incomingRelation },
                |m: &mut PBAccountListElement| { &mut m.incomingRelation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "likeCount",
                |m: &PBAccountListElement| { &m.likeCount },
                |m: &mut PBAccountListElement| { &mut m.likeCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commentCount",
                |m: &PBAccountListElement| { &m.commentCount },
                |m: &mut PBAccountListElement| { &mut m.commentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "followerCount",
                |m: &PBAccountListElement| { &m.followerCount },
                |m: &mut PBAccountListElement| { &mut m.followerCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "incomingActionTime",
                |m: &PBAccountListElement| { &m.incomingActionTime },
                |m: &mut PBAccountListElement| { &mut m.incomingActionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "media",
                |m: &PBAccountListElement| { &m.media },
                |m: &mut PBAccountListElement| { &mut m.media },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccountListElement_MediaWithRelation>>(
                "relatedMedias",
                |m: &PBAccountListElement| { &m.relatedMedias },
                |m: &mut PBAccountListElement| { &mut m.relatedMedias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needToUpdateRelations",
                |m: &PBAccountListElement| { &m.needToUpdateRelations },
                |m: &mut PBAccountListElement| { &mut m.needToUpdateRelations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content",
                |m: &PBAccountListElement| { &m.content },
                |m: &mut PBAccountListElement| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "score",
                |m: &PBAccountListElement| { &m.score },
                |m: &mut PBAccountListElement| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBAccountListElement>(
                "PBAccountListElement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBAccountListElement {
        static instance: ::protobuf::rt::LazyV2<PBAccountListElement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBAccountListElement::new)
    }
}

impl ::protobuf::Clear for PBAccountListElement {
    fn clear(&mut self) {
        self.targetAccount.clear();
        self.outgoingRelation = PBRelationship::PBRelationship_Null;
        self.incomingRelation = PBRelationship::PBRelationship_Null;
        self.likeCount = 0;
        self.commentCount = 0;
        self.followerCount = 0;
        self.incomingActionTime = 0;
        self.media.clear();
        self.relatedMedias.clear();
        self.needToUpdateRelations = false;
        self.content.clear();
        self.score = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBAccountListElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAccountListElement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBAccountListElement_MediaWithRelation {
    // message fields
    pub media: ::protobuf::SingularPtrField<PBMedia>,
    pub relation: PBRelationshipToMedia,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBAccountListElement_MediaWithRelation {
    fn default() -> &'a PBAccountListElement_MediaWithRelation {
        <PBAccountListElement_MediaWithRelation as ::protobuf::Message>::default_instance()
    }
}

impl PBAccountListElement_MediaWithRelation {
    pub fn new() -> PBAccountListElement_MediaWithRelation {
        ::std::default::Default::default()
    }

    // .PBMedia media = 1;


    pub fn get_media(&self) -> &PBMedia {
        self.media.as_ref().unwrap_or_else(|| <PBMedia as ::protobuf::Message>::default_instance())
    }
    pub fn clear_media(&mut self) {
        self.media.clear();
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: PBMedia) {
        self.media = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media(&mut self) -> &mut PBMedia {
        if self.media.is_none() {
            self.media.set_default();
        }
        self.media.as_mut().unwrap()
    }

    // Take field
    pub fn take_media(&mut self) -> PBMedia {
        self.media.take().unwrap_or_else(|| PBMedia::new())
    }

    // .PBRelationshipToMedia relation = 2;


    pub fn get_relation(&self) -> PBRelationshipToMedia {
        self.relation
    }
    pub fn clear_relation(&mut self) {
        self.relation = PBRelationshipToMedia::PBRelationshipToMedia_Null;
    }

    // Param is passed by value, moved
    pub fn set_relation(&mut self, v: PBRelationshipToMedia) {
        self.relation = v;
    }
}

impl ::protobuf::Message for PBAccountListElement_MediaWithRelation {
    fn is_initialized(&self) -> bool {
        for v in &self.media {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.media)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.relation, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.media.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.relation != PBRelationshipToMedia::PBRelationshipToMedia_Null {
            my_size += ::protobuf::rt::enum_size(2, self.relation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.media.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.relation != PBRelationshipToMedia::PBRelationshipToMedia_Null {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.relation))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBAccountListElement_MediaWithRelation {
        PBAccountListElement_MediaWithRelation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "media",
                |m: &PBAccountListElement_MediaWithRelation| { &m.media },
                |m: &mut PBAccountListElement_MediaWithRelation| { &mut m.media },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationshipToMedia>>(
                "relation",
                |m: &PBAccountListElement_MediaWithRelation| { &m.relation },
                |m: &mut PBAccountListElement_MediaWithRelation| { &mut m.relation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBAccountListElement_MediaWithRelation>(
                "PBAccountListElement.MediaWithRelation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBAccountListElement_MediaWithRelation {
        static instance: ::protobuf::rt::LazyV2<PBAccountListElement_MediaWithRelation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBAccountListElement_MediaWithRelation::new)
    }
}

impl ::protobuf::Clear for PBAccountListElement_MediaWithRelation {
    fn clear(&mut self) {
        self.media.clear();
        self.relation = PBRelationshipToMedia::PBRelationshipToMedia_Null;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBAccountListElement_MediaWithRelation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAccountListElement_MediaWithRelation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountListDataRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub dataType: PBAccountListDataType,
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub startTime: i64,
    pub endTime: i64,
    pub noRelatedMedias: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountListDataRequest {
    fn default() -> &'a PBFetchAccountListDataRequest {
        <PBFetchAccountListDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountListDataRequest {
    pub fn new() -> PBFetchAccountListDataRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // .PBAccountListDataType dataType = 2;


    pub fn get_dataType(&self) -> PBAccountListDataType {
        self.dataType
    }
    pub fn clear_dataType(&mut self) {
        self.dataType = PBAccountListDataType::PBAccountListDataType_None;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: PBAccountListDataType) {
        self.dataType = v;
    }

    // .PBPagination pagination = 3;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // int64 startTime = 4;


    pub fn get_startTime(&self) -> i64 {
        self.startTime
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: i64) {
        self.startTime = v;
    }

    // int64 endTime = 5;


    pub fn get_endTime(&self) -> i64 {
        self.endTime
    }
    pub fn clear_endTime(&mut self) {
        self.endTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_endTime(&mut self, v: i64) {
        self.endTime = v;
    }

    // bool noRelatedMedias = 6;


    pub fn get_noRelatedMedias(&self) -> bool {
        self.noRelatedMedias
    }
    pub fn clear_noRelatedMedias(&mut self) {
        self.noRelatedMedias = false;
    }

    // Param is passed by value, moved
    pub fn set_noRelatedMedias(&mut self, v: bool) {
        self.noRelatedMedias = v;
    }
}

impl ::protobuf::Message for PBFetchAccountListDataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endTime = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noRelatedMedias = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.dataType != PBAccountListDataType::PBAccountListDataType_None {
            my_size += ::protobuf::rt::enum_size(2, self.dataType);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.startTime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.startTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endTime != 0 {
            my_size += ::protobuf::rt::value_size(5, self.endTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.noRelatedMedias != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.dataType != PBAccountListDataType::PBAccountListDataType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.dataType))?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.startTime != 0 {
            os.write_int64(4, self.startTime)?;
        }
        if self.endTime != 0 {
            os.write_int64(5, self.endTime)?;
        }
        if self.noRelatedMedias != false {
            os.write_bool(6, self.noRelatedMedias)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountListDataRequest {
        PBFetchAccountListDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchAccountListDataRequest| { &m.accountID },
                |m: &mut PBFetchAccountListDataRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountListDataType>>(
                "dataType",
                |m: &PBFetchAccountListDataRequest| { &m.dataType },
                |m: &mut PBFetchAccountListDataRequest| { &mut m.dataType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchAccountListDataRequest| { &m.pagination },
                |m: &mut PBFetchAccountListDataRequest| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTime",
                |m: &PBFetchAccountListDataRequest| { &m.startTime },
                |m: &mut PBFetchAccountListDataRequest| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endTime",
                |m: &PBFetchAccountListDataRequest| { &m.endTime },
                |m: &mut PBFetchAccountListDataRequest| { &mut m.endTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noRelatedMedias",
                |m: &PBFetchAccountListDataRequest| { &m.noRelatedMedias },
                |m: &mut PBFetchAccountListDataRequest| { &mut m.noRelatedMedias },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountListDataRequest>(
                "PBFetchAccountListDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountListDataRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountListDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountListDataRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountListDataRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.dataType = PBAccountListDataType::PBAccountListDataType_None;
        self.pagination.clear();
        self.startTime = 0;
        self.endTime = 0;
        self.noRelatedMedias = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountListDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountListDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountListDataReply {
    // message fields
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub elements: ::protobuf::RepeatedField<PBAccountListElement>,
    pub calculationInProgress: bool,
    pub totalDataCount: i64,
    pub maxScore: i64,
    pub hasNext: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountListDataReply {
    fn default() -> &'a PBFetchAccountListDataReply {
        <PBFetchAccountListDataReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountListDataReply {
    pub fn new() -> PBFetchAccountListDataReply {
        ::std::default::Default::default()
    }

    // .PBPagination pagination = 1;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // repeated .PBAccountListElement elements = 2;


    pub fn get_elements(&self) -> &[PBAccountListElement] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<PBAccountListElement>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<PBAccountListElement> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<PBAccountListElement> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    // bool calculationInProgress = 3;


    pub fn get_calculationInProgress(&self) -> bool {
        self.calculationInProgress
    }
    pub fn clear_calculationInProgress(&mut self) {
        self.calculationInProgress = false;
    }

    // Param is passed by value, moved
    pub fn set_calculationInProgress(&mut self, v: bool) {
        self.calculationInProgress = v;
    }

    // int64 totalDataCount = 4;


    pub fn get_totalDataCount(&self) -> i64 {
        self.totalDataCount
    }
    pub fn clear_totalDataCount(&mut self) {
        self.totalDataCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalDataCount(&mut self, v: i64) {
        self.totalDataCount = v;
    }

    // int64 maxScore = 5;


    pub fn get_maxScore(&self) -> i64 {
        self.maxScore
    }
    pub fn clear_maxScore(&mut self) {
        self.maxScore = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxScore(&mut self, v: i64) {
        self.maxScore = v;
    }

    // bool hasNext = 6;


    pub fn get_hasNext(&self) -> bool {
        self.hasNext
    }
    pub fn clear_hasNext(&mut self) {
        self.hasNext = false;
    }

    // Param is passed by value, moved
    pub fn set_hasNext(&mut self, v: bool) {
        self.hasNext = v;
    }
}

impl ::protobuf::Message for PBFetchAccountListDataReply {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.calculationInProgress = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalDataCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxScore = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasNext = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.calculationInProgress != false {
            my_size += 2;
        }
        if self.totalDataCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.totalDataCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxScore != 0 {
            my_size += ::protobuf::rt::value_size(5, self.maxScore, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hasNext != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.elements {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.calculationInProgress != false {
            os.write_bool(3, self.calculationInProgress)?;
        }
        if self.totalDataCount != 0 {
            os.write_int64(4, self.totalDataCount)?;
        }
        if self.maxScore != 0 {
            os.write_int64(5, self.maxScore)?;
        }
        if self.hasNext != false {
            os.write_bool(6, self.hasNext)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountListDataReply {
        PBFetchAccountListDataReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchAccountListDataReply| { &m.pagination },
                |m: &mut PBFetchAccountListDataReply| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccountListElement>>(
                "elements",
                |m: &PBFetchAccountListDataReply| { &m.elements },
                |m: &mut PBFetchAccountListDataReply| { &mut m.elements },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "calculationInProgress",
                |m: &PBFetchAccountListDataReply| { &m.calculationInProgress },
                |m: &mut PBFetchAccountListDataReply| { &mut m.calculationInProgress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalDataCount",
                |m: &PBFetchAccountListDataReply| { &m.totalDataCount },
                |m: &mut PBFetchAccountListDataReply| { &mut m.totalDataCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maxScore",
                |m: &PBFetchAccountListDataReply| { &m.maxScore },
                |m: &mut PBFetchAccountListDataReply| { &mut m.maxScore },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasNext",
                |m: &PBFetchAccountListDataReply| { &m.hasNext },
                |m: &mut PBFetchAccountListDataReply| { &mut m.hasNext },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountListDataReply>(
                "PBFetchAccountListDataReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountListDataReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountListDataReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountListDataReply::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountListDataReply {
    fn clear(&mut self) {
        self.pagination.clear();
        self.elements.clear();
        self.calculationInProgress = false;
        self.totalDataCount = 0;
        self.maxScore = 0;
        self.hasNext = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountListDataReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountListDataReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchMostEngagingMediasRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub mediaType: PBMediaType,
    pub recentDays: i64,
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub engagingType: PBMediaEngagingType,
    pub startTime: i64,
    pub endTime: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchMostEngagingMediasRequest {
    fn default() -> &'a PBFetchMostEngagingMediasRequest {
        <PBFetchMostEngagingMediasRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchMostEngagingMediasRequest {
    pub fn new() -> PBFetchMostEngagingMediasRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // .PBMediaType mediaType = 2;


    pub fn get_mediaType(&self) -> PBMediaType {
        self.mediaType
    }
    pub fn clear_mediaType(&mut self) {
        self.mediaType = PBMediaType::PBMediaType_None;
    }

    // Param is passed by value, moved
    pub fn set_mediaType(&mut self, v: PBMediaType) {
        self.mediaType = v;
    }

    // int64 recentDays = 3;


    pub fn get_recentDays(&self) -> i64 {
        self.recentDays
    }
    pub fn clear_recentDays(&mut self) {
        self.recentDays = 0;
    }

    // Param is passed by value, moved
    pub fn set_recentDays(&mut self, v: i64) {
        self.recentDays = v;
    }

    // .PBPagination pagination = 4;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // .PBMediaEngagingType engagingType = 5;


    pub fn get_engagingType(&self) -> PBMediaEngagingType {
        self.engagingType
    }
    pub fn clear_engagingType(&mut self) {
        self.engagingType = PBMediaEngagingType::EngagingType_All;
    }

    // Param is passed by value, moved
    pub fn set_engagingType(&mut self, v: PBMediaEngagingType) {
        self.engagingType = v;
    }

    // int64 startTime = 6;


    pub fn get_startTime(&self) -> i64 {
        self.startTime
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: i64) {
        self.startTime = v;
    }

    // int64 endTime = 7;


    pub fn get_endTime(&self) -> i64 {
        self.endTime
    }
    pub fn clear_endTime(&mut self) {
        self.endTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_endTime(&mut self, v: i64) {
        self.endTime = v;
    }
}

impl ::protobuf::Message for PBFetchMostEngagingMediasRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mediaType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.recentDays = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.engagingType, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.mediaType != PBMediaType::PBMediaType_None {
            my_size += ::protobuf::rt::enum_size(2, self.mediaType);
        }
        if self.recentDays != 0 {
            my_size += ::protobuf::rt::value_size(3, self.recentDays, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.engagingType != PBMediaEngagingType::EngagingType_All {
            my_size += ::protobuf::rt::enum_size(5, self.engagingType);
        }
        if self.startTime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.startTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endTime != 0 {
            my_size += ::protobuf::rt::value_size(7, self.endTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.mediaType != PBMediaType::PBMediaType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.mediaType))?;
        }
        if self.recentDays != 0 {
            os.write_int64(3, self.recentDays)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.engagingType != PBMediaEngagingType::EngagingType_All {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.engagingType))?;
        }
        if self.startTime != 0 {
            os.write_int64(6, self.startTime)?;
        }
        if self.endTime != 0 {
            os.write_int64(7, self.endTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchMostEngagingMediasRequest {
        PBFetchMostEngagingMediasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchMostEngagingMediasRequest| { &m.accountID },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBMediaType>>(
                "mediaType",
                |m: &PBFetchMostEngagingMediasRequest| { &m.mediaType },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.mediaType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "recentDays",
                |m: &PBFetchMostEngagingMediasRequest| { &m.recentDays },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.recentDays },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchMostEngagingMediasRequest| { &m.pagination },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBMediaEngagingType>>(
                "engagingType",
                |m: &PBFetchMostEngagingMediasRequest| { &m.engagingType },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.engagingType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTime",
                |m: &PBFetchMostEngagingMediasRequest| { &m.startTime },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endTime",
                |m: &PBFetchMostEngagingMediasRequest| { &m.endTime },
                |m: &mut PBFetchMostEngagingMediasRequest| { &mut m.endTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchMostEngagingMediasRequest>(
                "PBFetchMostEngagingMediasRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchMostEngagingMediasRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchMostEngagingMediasRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchMostEngagingMediasRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchMostEngagingMediasRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.mediaType = PBMediaType::PBMediaType_None;
        self.recentDays = 0;
        self.pagination.clear();
        self.engagingType = PBMediaEngagingType::EngagingType_All;
        self.startTime = 0;
        self.endTime = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchMostEngagingMediasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchMostEngagingMediasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchMostEngagingMediasReply {
    // message fields
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub medias: ::protobuf::RepeatedField<PBMedia>,
    pub calculationInProgress: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchMostEngagingMediasReply {
    fn default() -> &'a PBFetchMostEngagingMediasReply {
        <PBFetchMostEngagingMediasReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchMostEngagingMediasReply {
    pub fn new() -> PBFetchMostEngagingMediasReply {
        ::std::default::Default::default()
    }

    // .PBPagination pagination = 1;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // repeated .PBMedia medias = 2;


    pub fn get_medias(&self) -> &[PBMedia] {
        &self.medias
    }
    pub fn clear_medias(&mut self) {
        self.medias.clear();
    }

    // Param is passed by value, moved
    pub fn set_medias(&mut self, v: ::protobuf::RepeatedField<PBMedia>) {
        self.medias = v;
    }

    // Mutable pointer to the field.
    pub fn mut_medias(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia> {
        &mut self.medias
    }

    // Take field
    pub fn take_medias(&mut self) -> ::protobuf::RepeatedField<PBMedia> {
        ::std::mem::replace(&mut self.medias, ::protobuf::RepeatedField::new())
    }

    // bool calculationInProgress = 3;


    pub fn get_calculationInProgress(&self) -> bool {
        self.calculationInProgress
    }
    pub fn clear_calculationInProgress(&mut self) {
        self.calculationInProgress = false;
    }

    // Param is passed by value, moved
    pub fn set_calculationInProgress(&mut self, v: bool) {
        self.calculationInProgress = v;
    }
}

impl ::protobuf::Message for PBFetchMostEngagingMediasReply {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medias {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.medias)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.calculationInProgress = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.medias {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.calculationInProgress != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.medias {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.calculationInProgress != false {
            os.write_bool(3, self.calculationInProgress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchMostEngagingMediasReply {
        PBFetchMostEngagingMediasReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchMostEngagingMediasReply| { &m.pagination },
                |m: &mut PBFetchMostEngagingMediasReply| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "medias",
                |m: &PBFetchMostEngagingMediasReply| { &m.medias },
                |m: &mut PBFetchMostEngagingMediasReply| { &mut m.medias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "calculationInProgress",
                |m: &PBFetchMostEngagingMediasReply| { &m.calculationInProgress },
                |m: &mut PBFetchMostEngagingMediasReply| { &mut m.calculationInProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchMostEngagingMediasReply>(
                "PBFetchMostEngagingMediasReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchMostEngagingMediasReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchMostEngagingMediasReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchMostEngagingMediasReply::new)
    }
}

impl ::protobuf::Clear for PBFetchMostEngagingMediasReply {
    fn clear(&mut self) {
        self.pagination.clear();
        self.medias.clear();
        self.calculationInProgress = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchMostEngagingMediasReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchMostEngagingMediasReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchEngagedMediasRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub targetAccountID: ::std::string::String,
    pub engagingType: PBMediaEngagingType,
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchEngagedMediasRequest {
    fn default() -> &'a PBFetchEngagedMediasRequest {
        <PBFetchEngagedMediasRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchEngagedMediasRequest {
    pub fn new() -> PBFetchEngagedMediasRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string targetAccountID = 2;


    pub fn get_targetAccountID(&self) -> &str {
        &self.targetAccountID
    }
    pub fn clear_targetAccountID(&mut self) {
        self.targetAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAccountID(&mut self, v: ::std::string::String) {
        self.targetAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.targetAccountID
    }

    // Take field
    pub fn take_targetAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAccountID, ::std::string::String::new())
    }

    // .PBMediaEngagingType engagingType = 3;


    pub fn get_engagingType(&self) -> PBMediaEngagingType {
        self.engagingType
    }
    pub fn clear_engagingType(&mut self) {
        self.engagingType = PBMediaEngagingType::EngagingType_All;
    }

    // Param is passed by value, moved
    pub fn set_engagingType(&mut self, v: PBMediaEngagingType) {
        self.engagingType = v;
    }

    // .PBPagination pagination = 4;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }
}

impl ::protobuf::Message for PBFetchEngagedMediasRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAccountID)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.engagingType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.targetAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.targetAccountID);
        }
        if self.engagingType != PBMediaEngagingType::EngagingType_All {
            my_size += ::protobuf::rt::enum_size(3, self.engagingType);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.targetAccountID.is_empty() {
            os.write_string(2, &self.targetAccountID)?;
        }
        if self.engagingType != PBMediaEngagingType::EngagingType_All {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.engagingType))?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchEngagedMediasRequest {
        PBFetchEngagedMediasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchEngagedMediasRequest| { &m.accountID },
                |m: &mut PBFetchEngagedMediasRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAccountID",
                |m: &PBFetchEngagedMediasRequest| { &m.targetAccountID },
                |m: &mut PBFetchEngagedMediasRequest| { &mut m.targetAccountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBMediaEngagingType>>(
                "engagingType",
                |m: &PBFetchEngagedMediasRequest| { &m.engagingType },
                |m: &mut PBFetchEngagedMediasRequest| { &mut m.engagingType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchEngagedMediasRequest| { &m.pagination },
                |m: &mut PBFetchEngagedMediasRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchEngagedMediasRequest>(
                "PBFetchEngagedMediasRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchEngagedMediasRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchEngagedMediasRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchEngagedMediasRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchEngagedMediasRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.targetAccountID.clear();
        self.engagingType = PBMediaEngagingType::EngagingType_All;
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchEngagedMediasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchEngagedMediasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchEngagedMediasReply {
    // message fields
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub medias: ::protobuf::RepeatedField<PBFetchEngagedMediasReply_EngagedMedia>,
    pub calculationInProgress: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchEngagedMediasReply {
    fn default() -> &'a PBFetchEngagedMediasReply {
        <PBFetchEngagedMediasReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchEngagedMediasReply {
    pub fn new() -> PBFetchEngagedMediasReply {
        ::std::default::Default::default()
    }

    // .PBPagination pagination = 1;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // repeated .PBFetchEngagedMediasReply.EngagedMedia medias = 2;


    pub fn get_medias(&self) -> &[PBFetchEngagedMediasReply_EngagedMedia] {
        &self.medias
    }
    pub fn clear_medias(&mut self) {
        self.medias.clear();
    }

    // Param is passed by value, moved
    pub fn set_medias(&mut self, v: ::protobuf::RepeatedField<PBFetchEngagedMediasReply_EngagedMedia>) {
        self.medias = v;
    }

    // Mutable pointer to the field.
    pub fn mut_medias(&mut self) -> &mut ::protobuf::RepeatedField<PBFetchEngagedMediasReply_EngagedMedia> {
        &mut self.medias
    }

    // Take field
    pub fn take_medias(&mut self) -> ::protobuf::RepeatedField<PBFetchEngagedMediasReply_EngagedMedia> {
        ::std::mem::replace(&mut self.medias, ::protobuf::RepeatedField::new())
    }

    // bool calculationInProgress = 3;


    pub fn get_calculationInProgress(&self) -> bool {
        self.calculationInProgress
    }
    pub fn clear_calculationInProgress(&mut self) {
        self.calculationInProgress = false;
    }

    // Param is passed by value, moved
    pub fn set_calculationInProgress(&mut self, v: bool) {
        self.calculationInProgress = v;
    }
}

impl ::protobuf::Message for PBFetchEngagedMediasReply {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medias {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.medias)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.calculationInProgress = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.medias {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.calculationInProgress != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.medias {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.calculationInProgress != false {
            os.write_bool(3, self.calculationInProgress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchEngagedMediasReply {
        PBFetchEngagedMediasReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchEngagedMediasReply| { &m.pagination },
                |m: &mut PBFetchEngagedMediasReply| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBFetchEngagedMediasReply_EngagedMedia>>(
                "medias",
                |m: &PBFetchEngagedMediasReply| { &m.medias },
                |m: &mut PBFetchEngagedMediasReply| { &mut m.medias },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "calculationInProgress",
                |m: &PBFetchEngagedMediasReply| { &m.calculationInProgress },
                |m: &mut PBFetchEngagedMediasReply| { &mut m.calculationInProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchEngagedMediasReply>(
                "PBFetchEngagedMediasReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchEngagedMediasReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchEngagedMediasReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchEngagedMediasReply::new)
    }
}

impl ::protobuf::Clear for PBFetchEngagedMediasReply {
    fn clear(&mut self) {
        self.pagination.clear();
        self.medias.clear();
        self.calculationInProgress = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchEngagedMediasReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchEngagedMediasReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchEngagedMediasReply_EngagedMedia {
    // message fields
    pub media: ::protobuf::SingularPtrField<PBMedia>,
    pub engagingType: PBMediaEngagingType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchEngagedMediasReply_EngagedMedia {
    fn default() -> &'a PBFetchEngagedMediasReply_EngagedMedia {
        <PBFetchEngagedMediasReply_EngagedMedia as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchEngagedMediasReply_EngagedMedia {
    pub fn new() -> PBFetchEngagedMediasReply_EngagedMedia {
        ::std::default::Default::default()
    }

    // .PBMedia media = 1;


    pub fn get_media(&self) -> &PBMedia {
        self.media.as_ref().unwrap_or_else(|| <PBMedia as ::protobuf::Message>::default_instance())
    }
    pub fn clear_media(&mut self) {
        self.media.clear();
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: PBMedia) {
        self.media = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media(&mut self) -> &mut PBMedia {
        if self.media.is_none() {
            self.media.set_default();
        }
        self.media.as_mut().unwrap()
    }

    // Take field
    pub fn take_media(&mut self) -> PBMedia {
        self.media.take().unwrap_or_else(|| PBMedia::new())
    }

    // .PBMediaEngagingType engagingType = 2;


    pub fn get_engagingType(&self) -> PBMediaEngagingType {
        self.engagingType
    }
    pub fn clear_engagingType(&mut self) {
        self.engagingType = PBMediaEngagingType::EngagingType_All;
    }

    // Param is passed by value, moved
    pub fn set_engagingType(&mut self, v: PBMediaEngagingType) {
        self.engagingType = v;
    }
}

impl ::protobuf::Message for PBFetchEngagedMediasReply_EngagedMedia {
    fn is_initialized(&self) -> bool {
        for v in &self.media {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.media)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.engagingType, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.media.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.engagingType != PBMediaEngagingType::EngagingType_All {
            my_size += ::protobuf::rt::enum_size(2, self.engagingType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.media.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.engagingType != PBMediaEngagingType::EngagingType_All {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.engagingType))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchEngagedMediasReply_EngagedMedia {
        PBFetchEngagedMediasReply_EngagedMedia::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "media",
                |m: &PBFetchEngagedMediasReply_EngagedMedia| { &m.media },
                |m: &mut PBFetchEngagedMediasReply_EngagedMedia| { &mut m.media },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBMediaEngagingType>>(
                "engagingType",
                |m: &PBFetchEngagedMediasReply_EngagedMedia| { &m.engagingType },
                |m: &mut PBFetchEngagedMediasReply_EngagedMedia| { &mut m.engagingType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchEngagedMediasReply_EngagedMedia>(
                "PBFetchEngagedMediasReply.EngagedMedia",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchEngagedMediasReply_EngagedMedia {
        static instance: ::protobuf::rt::LazyV2<PBFetchEngagedMediasReply_EngagedMedia> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchEngagedMediasReply_EngagedMedia::new)
    }
}

impl ::protobuf::Clear for PBFetchEngagedMediasReply_EngagedMedia {
    fn clear(&mut self) {
        self.media.clear();
        self.engagingType = PBMediaEngagingType::EngagingType_All;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchEngagedMediasReply_EngagedMedia {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchEngagedMediasReply_EngagedMedia {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchSpotlightDataRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub targetAccountID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchSpotlightDataRequest {
    fn default() -> &'a PBFetchSpotlightDataRequest {
        <PBFetchSpotlightDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchSpotlightDataRequest {
    pub fn new() -> PBFetchSpotlightDataRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string targetAccountID = 2;


    pub fn get_targetAccountID(&self) -> &str {
        &self.targetAccountID
    }
    pub fn clear_targetAccountID(&mut self) {
        self.targetAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAccountID(&mut self, v: ::std::string::String) {
        self.targetAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.targetAccountID
    }

    // Take field
    pub fn take_targetAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.targetAccountID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBFetchSpotlightDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.targetAccountID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.targetAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.targetAccountID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.targetAccountID.is_empty() {
            os.write_string(2, &self.targetAccountID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchSpotlightDataRequest {
        PBFetchSpotlightDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchSpotlightDataRequest| { &m.accountID },
                |m: &mut PBFetchSpotlightDataRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAccountID",
                |m: &PBFetchSpotlightDataRequest| { &m.targetAccountID },
                |m: &mut PBFetchSpotlightDataRequest| { &mut m.targetAccountID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchSpotlightDataRequest>(
                "PBFetchSpotlightDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchSpotlightDataRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchSpotlightDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchSpotlightDataRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchSpotlightDataRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.targetAccountID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchSpotlightDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchSpotlightDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchSpotlightDataReply {
    // message fields
    pub likeCountFromTargetAccount: i64,
    pub commentCountFromTargetAccount: i64,
    pub mostLikedMediasOwnedByTargetAccount: ::protobuf::RepeatedField<PBMedia>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchSpotlightDataReply {
    fn default() -> &'a PBFetchSpotlightDataReply {
        <PBFetchSpotlightDataReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchSpotlightDataReply {
    pub fn new() -> PBFetchSpotlightDataReply {
        ::std::default::Default::default()
    }

    // int64 likeCountFromTargetAccount = 1;


    pub fn get_likeCountFromTargetAccount(&self) -> i64 {
        self.likeCountFromTargetAccount
    }
    pub fn clear_likeCountFromTargetAccount(&mut self) {
        self.likeCountFromTargetAccount = 0;
    }

    // Param is passed by value, moved
    pub fn set_likeCountFromTargetAccount(&mut self, v: i64) {
        self.likeCountFromTargetAccount = v;
    }

    // int64 commentCountFromTargetAccount = 2;


    pub fn get_commentCountFromTargetAccount(&self) -> i64 {
        self.commentCountFromTargetAccount
    }
    pub fn clear_commentCountFromTargetAccount(&mut self) {
        self.commentCountFromTargetAccount = 0;
    }

    // Param is passed by value, moved
    pub fn set_commentCountFromTargetAccount(&mut self, v: i64) {
        self.commentCountFromTargetAccount = v;
    }

    // repeated .PBMedia mostLikedMediasOwnedByTargetAccount = 3;


    pub fn get_mostLikedMediasOwnedByTargetAccount(&self) -> &[PBMedia] {
        &self.mostLikedMediasOwnedByTargetAccount
    }
    pub fn clear_mostLikedMediasOwnedByTargetAccount(&mut self) {
        self.mostLikedMediasOwnedByTargetAccount.clear();
    }

    // Param is passed by value, moved
    pub fn set_mostLikedMediasOwnedByTargetAccount(&mut self, v: ::protobuf::RepeatedField<PBMedia>) {
        self.mostLikedMediasOwnedByTargetAccount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mostLikedMediasOwnedByTargetAccount(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia> {
        &mut self.mostLikedMediasOwnedByTargetAccount
    }

    // Take field
    pub fn take_mostLikedMediasOwnedByTargetAccount(&mut self) -> ::protobuf::RepeatedField<PBMedia> {
        ::std::mem::replace(&mut self.mostLikedMediasOwnedByTargetAccount, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchSpotlightDataReply {
    fn is_initialized(&self) -> bool {
        for v in &self.mostLikedMediasOwnedByTargetAccount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.likeCountFromTargetAccount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commentCountFromTargetAccount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mostLikedMediasOwnedByTargetAccount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.likeCountFromTargetAccount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.likeCountFromTargetAccount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commentCountFromTargetAccount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.commentCountFromTargetAccount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.mostLikedMediasOwnedByTargetAccount {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.likeCountFromTargetAccount != 0 {
            os.write_int64(1, self.likeCountFromTargetAccount)?;
        }
        if self.commentCountFromTargetAccount != 0 {
            os.write_int64(2, self.commentCountFromTargetAccount)?;
        }
        for v in &self.mostLikedMediasOwnedByTargetAccount {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchSpotlightDataReply {
        PBFetchSpotlightDataReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "likeCountFromTargetAccount",
                |m: &PBFetchSpotlightDataReply| { &m.likeCountFromTargetAccount },
                |m: &mut PBFetchSpotlightDataReply| { &mut m.likeCountFromTargetAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "commentCountFromTargetAccount",
                |m: &PBFetchSpotlightDataReply| { &m.commentCountFromTargetAccount },
                |m: &mut PBFetchSpotlightDataReply| { &mut m.commentCountFromTargetAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "mostLikedMediasOwnedByTargetAccount",
                |m: &PBFetchSpotlightDataReply| { &m.mostLikedMediasOwnedByTargetAccount },
                |m: &mut PBFetchSpotlightDataReply| { &mut m.mostLikedMediasOwnedByTargetAccount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchSpotlightDataReply>(
                "PBFetchSpotlightDataReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchSpotlightDataReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchSpotlightDataReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchSpotlightDataReply::new)
    }
}

impl ::protobuf::Clear for PBFetchSpotlightDataReply {
    fn clear(&mut self) {
        self.likeCountFromTargetAccount = 0;
        self.commentCountFromTargetAccount = 0;
        self.mostLikedMediasOwnedByTargetAccount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchSpotlightDataReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchSpotlightDataReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchHistoryCountRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub field_type: PBFetchHistoryCountType,
    pub startTime: i64,
    pub endTime: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchHistoryCountRequest {
    fn default() -> &'a PBFetchHistoryCountRequest {
        <PBFetchHistoryCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchHistoryCountRequest {
    pub fn new() -> PBFetchHistoryCountRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // .PBFetchHistoryCountType type = 2;


    pub fn get_field_type(&self) -> PBFetchHistoryCountType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBFetchHistoryCountType::PBFetchHistoryCountType_Follower;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBFetchHistoryCountType) {
        self.field_type = v;
    }

    // int64 startTime = 3;


    pub fn get_startTime(&self) -> i64 {
        self.startTime
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: i64) {
        self.startTime = v;
    }

    // int64 endTime = 4;


    pub fn get_endTime(&self) -> i64 {
        self.endTime
    }
    pub fn clear_endTime(&mut self) {
        self.endTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_endTime(&mut self, v: i64) {
        self.endTime = v;
    }
}

impl ::protobuf::Message for PBFetchHistoryCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.field_type != PBFetchHistoryCountType::PBFetchHistoryCountType_Follower {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if self.startTime != 0 {
            my_size += ::protobuf::rt::value_size(3, self.startTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endTime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.endTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.field_type != PBFetchHistoryCountType::PBFetchHistoryCountType_Follower {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.startTime != 0 {
            os.write_int64(3, self.startTime)?;
        }
        if self.endTime != 0 {
            os.write_int64(4, self.endTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchHistoryCountRequest {
        PBFetchHistoryCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchHistoryCountRequest| { &m.accountID },
                |m: &mut PBFetchHistoryCountRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBFetchHistoryCountType>>(
                "type",
                |m: &PBFetchHistoryCountRequest| { &m.field_type },
                |m: &mut PBFetchHistoryCountRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTime",
                |m: &PBFetchHistoryCountRequest| { &m.startTime },
                |m: &mut PBFetchHistoryCountRequest| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endTime",
                |m: &PBFetchHistoryCountRequest| { &m.endTime },
                |m: &mut PBFetchHistoryCountRequest| { &mut m.endTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchHistoryCountRequest>(
                "PBFetchHistoryCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchHistoryCountRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchHistoryCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchHistoryCountRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchHistoryCountRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.field_type = PBFetchHistoryCountType::PBFetchHistoryCountType_Follower;
        self.startTime = 0;
        self.endTime = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchHistoryCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchHistoryCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchHistoryCountReply {
    // message fields
    pub counts: ::protobuf::RepeatedField<PBFetchHistoryCountReply_CountData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchHistoryCountReply {
    fn default() -> &'a PBFetchHistoryCountReply {
        <PBFetchHistoryCountReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchHistoryCountReply {
    pub fn new() -> PBFetchHistoryCountReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchHistoryCountReply.CountData counts = 1;


    pub fn get_counts(&self) -> &[PBFetchHistoryCountReply_CountData] {
        &self.counts
    }
    pub fn clear_counts(&mut self) {
        self.counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_counts(&mut self, v: ::protobuf::RepeatedField<PBFetchHistoryCountReply_CountData>) {
        self.counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counts(&mut self) -> &mut ::protobuf::RepeatedField<PBFetchHistoryCountReply_CountData> {
        &mut self.counts
    }

    // Take field
    pub fn take_counts(&mut self) -> ::protobuf::RepeatedField<PBFetchHistoryCountReply_CountData> {
        ::std::mem::replace(&mut self.counts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchHistoryCountReply {
    fn is_initialized(&self) -> bool {
        for v in &self.counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.counts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchHistoryCountReply {
        PBFetchHistoryCountReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBFetchHistoryCountReply_CountData>>(
                "counts",
                |m: &PBFetchHistoryCountReply| { &m.counts },
                |m: &mut PBFetchHistoryCountReply| { &mut m.counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchHistoryCountReply>(
                "PBFetchHistoryCountReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchHistoryCountReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchHistoryCountReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchHistoryCountReply::new)
    }
}

impl ::protobuf::Clear for PBFetchHistoryCountReply {
    fn clear(&mut self) {
        self.counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchHistoryCountReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchHistoryCountReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchHistoryCountReply_CountData {
    // message fields
    pub count: i64,
    pub time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchHistoryCountReply_CountData {
    fn default() -> &'a PBFetchHistoryCountReply_CountData {
        <PBFetchHistoryCountReply_CountData as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchHistoryCountReply_CountData {
    pub fn new() -> PBFetchHistoryCountReply_CountData {
        ::std::default::Default::default()
    }

    // int64 count = 1;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }

    // int64 time = 2;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }
}

impl ::protobuf::Message for PBFetchHistoryCountReply_CountData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_int64(1, self.count)?;
        }
        if self.time != 0 {
            os.write_int64(2, self.time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchHistoryCountReply_CountData {
        PBFetchHistoryCountReply_CountData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "count",
                |m: &PBFetchHistoryCountReply_CountData| { &m.count },
                |m: &mut PBFetchHistoryCountReply_CountData| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "time",
                |m: &PBFetchHistoryCountReply_CountData| { &m.time },
                |m: &mut PBFetchHistoryCountReply_CountData| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchHistoryCountReply_CountData>(
                "PBFetchHistoryCountReply.CountData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchHistoryCountReply_CountData {
        static instance: ::protobuf::rt::LazyV2<PBFetchHistoryCountReply_CountData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchHistoryCountReply_CountData::new)
    }
}

impl ::protobuf::Clear for PBFetchHistoryCountReply_CountData {
    fn clear(&mut self) {
        self.count = 0;
        self.time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchHistoryCountReply_CountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchHistoryCountReply_CountData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountRelationsRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub targetAccountIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountRelationsRequest {
    fn default() -> &'a PBFetchAccountRelationsRequest {
        <PBFetchAccountRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountRelationsRequest {
    pub fn new() -> PBFetchAccountRelationsRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // repeated string targetAccountIDs = 2;


    pub fn get_targetAccountIDs(&self) -> &[::std::string::String] {
        &self.targetAccountIDs
    }
    pub fn clear_targetAccountIDs(&mut self) {
        self.targetAccountIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetAccountIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.targetAccountIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetAccountIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetAccountIDs
    }

    // Take field
    pub fn take_targetAccountIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.targetAccountIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchAccountRelationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.targetAccountIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        for value in &self.targetAccountIDs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        for v in &self.targetAccountIDs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountRelationsRequest {
        PBFetchAccountRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchAccountRelationsRequest| { &m.accountID },
                |m: &mut PBFetchAccountRelationsRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetAccountIDs",
                |m: &PBFetchAccountRelationsRequest| { &m.targetAccountIDs },
                |m: &mut PBFetchAccountRelationsRequest| { &mut m.targetAccountIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountRelationsRequest>(
                "PBFetchAccountRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountRelationsRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountRelationsRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.targetAccountIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountRelationsReply {
    // message fields
    pub relationMap: ::std::collections::HashMap<::std::string::String, PBFetchAccountRelationsReply_RelationData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountRelationsReply {
    fn default() -> &'a PBFetchAccountRelationsReply {
        <PBFetchAccountRelationsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountRelationsReply {
    pub fn new() -> PBFetchAccountRelationsReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchAccountRelationsReply.RelationMapEntry relationMap = 1;


    pub fn get_relationMap(&self) -> &::std::collections::HashMap<::std::string::String, PBFetchAccountRelationsReply_RelationData> {
        &self.relationMap
    }
    pub fn clear_relationMap(&mut self) {
        self.relationMap.clear();
    }

    // Param is passed by value, moved
    pub fn set_relationMap(&mut self, v: ::std::collections::HashMap<::std::string::String, PBFetchAccountRelationsReply_RelationData>) {
        self.relationMap = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relationMap(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, PBFetchAccountRelationsReply_RelationData> {
        &mut self.relationMap
    }

    // Take field
    pub fn take_relationMap(&mut self) -> ::std::collections::HashMap<::std::string::String, PBFetchAccountRelationsReply_RelationData> {
        ::std::mem::replace(&mut self.relationMap, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PBFetchAccountRelationsReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<PBFetchAccountRelationsReply_RelationData>>(wire_type, is, &mut self.relationMap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<PBFetchAccountRelationsReply_RelationData>>(1, &self.relationMap);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<PBFetchAccountRelationsReply_RelationData>>(1, &self.relationMap, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountRelationsReply {
        PBFetchAccountRelationsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<PBFetchAccountRelationsReply_RelationData>>(
                "relationMap",
                |m: &PBFetchAccountRelationsReply| { &m.relationMap },
                |m: &mut PBFetchAccountRelationsReply| { &mut m.relationMap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountRelationsReply>(
                "PBFetchAccountRelationsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountRelationsReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountRelationsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountRelationsReply::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountRelationsReply {
    fn clear(&mut self) {
        self.relationMap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountRelationsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountRelationsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountRelationsReply_RelationData {
    // message fields
    pub outgoingRelation: PBRelationship,
    pub incomingRelation: PBRelationship,
    pub needToUpdateRelations: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountRelationsReply_RelationData {
    fn default() -> &'a PBFetchAccountRelationsReply_RelationData {
        <PBFetchAccountRelationsReply_RelationData as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountRelationsReply_RelationData {
    pub fn new() -> PBFetchAccountRelationsReply_RelationData {
        ::std::default::Default::default()
    }

    // .PBRelationship outgoingRelation = 1;


    pub fn get_outgoingRelation(&self) -> PBRelationship {
        self.outgoingRelation
    }
    pub fn clear_outgoingRelation(&mut self) {
        self.outgoingRelation = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_outgoingRelation(&mut self, v: PBRelationship) {
        self.outgoingRelation = v;
    }

    // .PBRelationship incomingRelation = 2;


    pub fn get_incomingRelation(&self) -> PBRelationship {
        self.incomingRelation
    }
    pub fn clear_incomingRelation(&mut self) {
        self.incomingRelation = PBRelationship::PBRelationship_Null;
    }

    // Param is passed by value, moved
    pub fn set_incomingRelation(&mut self, v: PBRelationship) {
        self.incomingRelation = v;
    }

    // bool needToUpdateRelations = 3;


    pub fn get_needToUpdateRelations(&self) -> bool {
        self.needToUpdateRelations
    }
    pub fn clear_needToUpdateRelations(&mut self) {
        self.needToUpdateRelations = false;
    }

    // Param is passed by value, moved
    pub fn set_needToUpdateRelations(&mut self, v: bool) {
        self.needToUpdateRelations = v;
    }
}

impl ::protobuf::Message for PBFetchAccountRelationsReply_RelationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.outgoingRelation, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.incomingRelation, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needToUpdateRelations = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.outgoingRelation != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(1, self.outgoingRelation);
        }
        if self.incomingRelation != PBRelationship::PBRelationship_Null {
            my_size += ::protobuf::rt::enum_size(2, self.incomingRelation);
        }
        if self.needToUpdateRelations != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.outgoingRelation != PBRelationship::PBRelationship_Null {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.outgoingRelation))?;
        }
        if self.incomingRelation != PBRelationship::PBRelationship_Null {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.incomingRelation))?;
        }
        if self.needToUpdateRelations != false {
            os.write_bool(3, self.needToUpdateRelations)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountRelationsReply_RelationData {
        PBFetchAccountRelationsReply_RelationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "outgoingRelation",
                |m: &PBFetchAccountRelationsReply_RelationData| { &m.outgoingRelation },
                |m: &mut PBFetchAccountRelationsReply_RelationData| { &mut m.outgoingRelation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBRelationship>>(
                "incomingRelation",
                |m: &PBFetchAccountRelationsReply_RelationData| { &m.incomingRelation },
                |m: &mut PBFetchAccountRelationsReply_RelationData| { &mut m.incomingRelation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needToUpdateRelations",
                |m: &PBFetchAccountRelationsReply_RelationData| { &m.needToUpdateRelations },
                |m: &mut PBFetchAccountRelationsReply_RelationData| { &mut m.needToUpdateRelations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountRelationsReply_RelationData>(
                "PBFetchAccountRelationsReply.RelationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountRelationsReply_RelationData {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountRelationsReply_RelationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountRelationsReply_RelationData::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountRelationsReply_RelationData {
    fn clear(&mut self) {
        self.outgoingRelation = PBRelationship::PBRelationship_Null;
        self.incomingRelation = PBRelationship::PBRelationship_Null;
        self.needToUpdateRelations = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountRelationsReply_RelationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountRelationsReply_RelationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBProfileViewerElement {
    // message fields
    pub viewer: ::protobuf::SingularPtrField<PBAccountListElement>,
    pub viewCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBProfileViewerElement {
    fn default() -> &'a PBProfileViewerElement {
        <PBProfileViewerElement as ::protobuf::Message>::default_instance()
    }
}

impl PBProfileViewerElement {
    pub fn new() -> PBProfileViewerElement {
        ::std::default::Default::default()
    }

    // .PBAccountListElement viewer = 1;


    pub fn get_viewer(&self) -> &PBAccountListElement {
        self.viewer.as_ref().unwrap_or_else(|| <PBAccountListElement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_viewer(&mut self) {
        self.viewer.clear();
    }

    pub fn has_viewer(&self) -> bool {
        self.viewer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewer(&mut self, v: PBAccountListElement) {
        self.viewer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_viewer(&mut self) -> &mut PBAccountListElement {
        if self.viewer.is_none() {
            self.viewer.set_default();
        }
        self.viewer.as_mut().unwrap()
    }

    // Take field
    pub fn take_viewer(&mut self) -> PBAccountListElement {
        self.viewer.take().unwrap_or_else(|| PBAccountListElement::new())
    }

    // int64 viewCount = 2;


    pub fn get_viewCount(&self) -> i64 {
        self.viewCount
    }
    pub fn clear_viewCount(&mut self) {
        self.viewCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_viewCount(&mut self, v: i64) {
        self.viewCount = v;
    }
}

impl ::protobuf::Message for PBProfileViewerElement {
    fn is_initialized(&self) -> bool {
        for v in &self.viewer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.viewer)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.viewCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.viewer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.viewCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.viewCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.viewer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.viewCount != 0 {
            os.write_int64(2, self.viewCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBProfileViewerElement {
        PBProfileViewerElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccountListElement>>(
                "viewer",
                |m: &PBProfileViewerElement| { &m.viewer },
                |m: &mut PBProfileViewerElement| { &mut m.viewer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "viewCount",
                |m: &PBProfileViewerElement| { &m.viewCount },
                |m: &mut PBProfileViewerElement| { &mut m.viewCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBProfileViewerElement>(
                "PBProfileViewerElement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBProfileViewerElement {
        static instance: ::protobuf::rt::LazyV2<PBProfileViewerElement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBProfileViewerElement::new)
    }
}

impl ::protobuf::Clear for PBProfileViewerElement {
    fn clear(&mut self) {
        self.viewer.clear();
        self.viewCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBProfileViewerElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBProfileViewerElement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchProfileViewersRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub startTime: i64,
    pub endTime: i64,
    pub noRelatedMedias: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchProfileViewersRequest {
    fn default() -> &'a PBFetchProfileViewersRequest {
        <PBFetchProfileViewersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchProfileViewersRequest {
    pub fn new() -> PBFetchProfileViewersRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // int64 startTime = 2;


    pub fn get_startTime(&self) -> i64 {
        self.startTime
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: i64) {
        self.startTime = v;
    }

    // int64 endTime = 3;


    pub fn get_endTime(&self) -> i64 {
        self.endTime
    }
    pub fn clear_endTime(&mut self) {
        self.endTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_endTime(&mut self, v: i64) {
        self.endTime = v;
    }

    // bool noRelatedMedias = 4;


    pub fn get_noRelatedMedias(&self) -> bool {
        self.noRelatedMedias
    }
    pub fn clear_noRelatedMedias(&mut self) {
        self.noRelatedMedias = false;
    }

    // Param is passed by value, moved
    pub fn set_noRelatedMedias(&mut self, v: bool) {
        self.noRelatedMedias = v;
    }
}

impl ::protobuf::Message for PBFetchProfileViewersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endTime = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noRelatedMedias = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.startTime != 0 {
            my_size += ::protobuf::rt::value_size(2, self.startTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endTime != 0 {
            my_size += ::protobuf::rt::value_size(3, self.endTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.noRelatedMedias != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.startTime != 0 {
            os.write_int64(2, self.startTime)?;
        }
        if self.endTime != 0 {
            os.write_int64(3, self.endTime)?;
        }
        if self.noRelatedMedias != false {
            os.write_bool(4, self.noRelatedMedias)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchProfileViewersRequest {
        PBFetchProfileViewersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchProfileViewersRequest| { &m.accountID },
                |m: &mut PBFetchProfileViewersRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTime",
                |m: &PBFetchProfileViewersRequest| { &m.startTime },
                |m: &mut PBFetchProfileViewersRequest| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endTime",
                |m: &PBFetchProfileViewersRequest| { &m.endTime },
                |m: &mut PBFetchProfileViewersRequest| { &mut m.endTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noRelatedMedias",
                |m: &PBFetchProfileViewersRequest| { &m.noRelatedMedias },
                |m: &mut PBFetchProfileViewersRequest| { &mut m.noRelatedMedias },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchProfileViewersRequest>(
                "PBFetchProfileViewersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchProfileViewersRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchProfileViewersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchProfileViewersRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchProfileViewersRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.startTime = 0;
        self.endTime = 0;
        self.noRelatedMedias = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchProfileViewersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchProfileViewersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchProfileViewersReply {
    // message fields
    pub dataArray: ::protobuf::RepeatedField<PBFetchProfileViewersReply_ViewerData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchProfileViewersReply {
    fn default() -> &'a PBFetchProfileViewersReply {
        <PBFetchProfileViewersReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchProfileViewersReply {
    pub fn new() -> PBFetchProfileViewersReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchProfileViewersReply.ViewerData dataArray = 1;


    pub fn get_dataArray(&self) -> &[PBFetchProfileViewersReply_ViewerData] {
        &self.dataArray
    }
    pub fn clear_dataArray(&mut self) {
        self.dataArray.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataArray(&mut self, v: ::protobuf::RepeatedField<PBFetchProfileViewersReply_ViewerData>) {
        self.dataArray = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dataArray(&mut self) -> &mut ::protobuf::RepeatedField<PBFetchProfileViewersReply_ViewerData> {
        &mut self.dataArray
    }

    // Take field
    pub fn take_dataArray(&mut self) -> ::protobuf::RepeatedField<PBFetchProfileViewersReply_ViewerData> {
        ::std::mem::replace(&mut self.dataArray, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchProfileViewersReply {
    fn is_initialized(&self) -> bool {
        for v in &self.dataArray {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dataArray)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dataArray {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dataArray {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchProfileViewersReply {
        PBFetchProfileViewersReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBFetchProfileViewersReply_ViewerData>>(
                "dataArray",
                |m: &PBFetchProfileViewersReply| { &m.dataArray },
                |m: &mut PBFetchProfileViewersReply| { &mut m.dataArray },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchProfileViewersReply>(
                "PBFetchProfileViewersReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchProfileViewersReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchProfileViewersReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchProfileViewersReply::new)
    }
}

impl ::protobuf::Clear for PBFetchProfileViewersReply {
    fn clear(&mut self) {
        self.dataArray.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchProfileViewersReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchProfileViewersReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchProfileViewersReply_ViewerData {
    // message fields
    pub viewDateTime: i64,
    pub elements: ::protobuf::RepeatedField<PBProfileViewerElement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchProfileViewersReply_ViewerData {
    fn default() -> &'a PBFetchProfileViewersReply_ViewerData {
        <PBFetchProfileViewersReply_ViewerData as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchProfileViewersReply_ViewerData {
    pub fn new() -> PBFetchProfileViewersReply_ViewerData {
        ::std::default::Default::default()
    }

    // int64 viewDateTime = 1;


    pub fn get_viewDateTime(&self) -> i64 {
        self.viewDateTime
    }
    pub fn clear_viewDateTime(&mut self) {
        self.viewDateTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_viewDateTime(&mut self, v: i64) {
        self.viewDateTime = v;
    }

    // repeated .PBProfileViewerElement elements = 2;


    pub fn get_elements(&self) -> &[PBProfileViewerElement] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<PBProfileViewerElement>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<PBProfileViewerElement> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<PBProfileViewerElement> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchProfileViewersReply_ViewerData {
    fn is_initialized(&self) -> bool {
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.viewDateTime = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.viewDateTime != 0 {
            my_size += ::protobuf::rt::value_size(1, self.viewDateTime, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.viewDateTime != 0 {
            os.write_int64(1, self.viewDateTime)?;
        }
        for v in &self.elements {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchProfileViewersReply_ViewerData {
        PBFetchProfileViewersReply_ViewerData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "viewDateTime",
                |m: &PBFetchProfileViewersReply_ViewerData| { &m.viewDateTime },
                |m: &mut PBFetchProfileViewersReply_ViewerData| { &mut m.viewDateTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBProfileViewerElement>>(
                "elements",
                |m: &PBFetchProfileViewersReply_ViewerData| { &m.elements },
                |m: &mut PBFetchProfileViewersReply_ViewerData| { &mut m.elements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchProfileViewersReply_ViewerData>(
                "PBFetchProfileViewersReply.ViewerData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchProfileViewersReply_ViewerData {
        static instance: ::protobuf::rt::LazyV2<PBFetchProfileViewersReply_ViewerData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchProfileViewersReply_ViewerData::new)
    }
}

impl ::protobuf::Clear for PBFetchProfileViewersReply_ViewerData {
    fn clear(&mut self) {
        self.viewDateTime = 0;
        self.elements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchProfileViewersReply_ViewerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchProfileViewersReply_ViewerData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostTextNotification {
    // message fields
    pub title: ::std::string::String,
    pub content: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostTextNotification {
    fn default() -> &'a PBPostTextNotification {
        <PBPostTextNotification as ::protobuf::Message>::default_instance()
    }
}

impl PBPostTextNotification {
    pub fn new() -> PBPostTextNotification {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string content = 2;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBPostTextNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostTextNotification {
        PBPostTextNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &PBPostTextNotification| { &m.title },
                |m: &mut PBPostTextNotification| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content",
                |m: &PBPostTextNotification| { &m.content },
                |m: &mut PBPostTextNotification| { &mut m.content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostTextNotification>(
                "PBPostTextNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostTextNotification {
        static instance: ::protobuf::rt::LazyV2<PBPostTextNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostTextNotification::new)
    }
}

impl ::protobuf::Clear for PBPostTextNotification {
    fn clear(&mut self) {
        self.title.clear();
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostTextNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostTextNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostChangeNotification {
    // message fields
    pub changeType: PBChangeType,
    pub changeCount: i64,
    pub isAccumulated: bool,
    pub sinceTime: i64,
    pub accountID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostChangeNotification {
    fn default() -> &'a PBPostChangeNotification {
        <PBPostChangeNotification as ::protobuf::Message>::default_instance()
    }
}

impl PBPostChangeNotification {
    pub fn new() -> PBPostChangeNotification {
        ::std::default::Default::default()
    }

    // .PBChangeType changeType = 1;


    pub fn get_changeType(&self) -> PBChangeType {
        self.changeType
    }
    pub fn clear_changeType(&mut self) {
        self.changeType = PBChangeType::PBChangeType_None;
    }

    // Param is passed by value, moved
    pub fn set_changeType(&mut self, v: PBChangeType) {
        self.changeType = v;
    }

    // int64 changeCount = 2;


    pub fn get_changeCount(&self) -> i64 {
        self.changeCount
    }
    pub fn clear_changeCount(&mut self) {
        self.changeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_changeCount(&mut self, v: i64) {
        self.changeCount = v;
    }

    // bool isAccumulated = 3;


    pub fn get_isAccumulated(&self) -> bool {
        self.isAccumulated
    }
    pub fn clear_isAccumulated(&mut self) {
        self.isAccumulated = false;
    }

    // Param is passed by value, moved
    pub fn set_isAccumulated(&mut self, v: bool) {
        self.isAccumulated = v;
    }

    // int64 sinceTime = 4;


    pub fn get_sinceTime(&self) -> i64 {
        self.sinceTime
    }
    pub fn clear_sinceTime(&mut self) {
        self.sinceTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_sinceTime(&mut self, v: i64) {
        self.sinceTime = v;
    }

    // string accountID = 5;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PBPostChangeNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.changeType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.changeCount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isAccumulated = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sinceTime = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.changeType != PBChangeType::PBChangeType_None {
            my_size += ::protobuf::rt::enum_size(1, self.changeType);
        }
        if self.changeCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.changeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isAccumulated != false {
            my_size += 2;
        }
        if self.sinceTime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.sinceTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.accountID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.changeType != PBChangeType::PBChangeType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.changeType))?;
        }
        if self.changeCount != 0 {
            os.write_int64(2, self.changeCount)?;
        }
        if self.isAccumulated != false {
            os.write_bool(3, self.isAccumulated)?;
        }
        if self.sinceTime != 0 {
            os.write_int64(4, self.sinceTime)?;
        }
        if !self.accountID.is_empty() {
            os.write_string(5, &self.accountID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostChangeNotification {
        PBPostChangeNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBChangeType>>(
                "changeType",
                |m: &PBPostChangeNotification| { &m.changeType },
                |m: &mut PBPostChangeNotification| { &mut m.changeType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "changeCount",
                |m: &PBPostChangeNotification| { &m.changeCount },
                |m: &mut PBPostChangeNotification| { &mut m.changeCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isAccumulated",
                |m: &PBPostChangeNotification| { &m.isAccumulated },
                |m: &mut PBPostChangeNotification| { &mut m.isAccumulated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sinceTime",
                |m: &PBPostChangeNotification| { &m.sinceTime },
                |m: &mut PBPostChangeNotification| { &mut m.sinceTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBPostChangeNotification| { &m.accountID },
                |m: &mut PBPostChangeNotification| { &mut m.accountID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostChangeNotification>(
                "PBPostChangeNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostChangeNotification {
        static instance: ::protobuf::rt::LazyV2<PBPostChangeNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostChangeNotification::new)
    }
}

impl ::protobuf::Clear for PBPostChangeNotification {
    fn clear(&mut self) {
        self.changeType = PBChangeType::PBChangeType_None;
        self.changeCount = 0;
        self.isAccumulated = false;
        self.sinceTime = 0;
        self.accountID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostChangeNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostChangeNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBValidateSubscriptionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBValidateSubscriptionRequest {
    fn default() -> &'a PBValidateSubscriptionRequest {
        <PBValidateSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBValidateSubscriptionRequest {
    pub fn new() -> PBValidateSubscriptionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBValidateSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBValidateSubscriptionRequest {
        PBValidateSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBValidateSubscriptionRequest>(
                "PBValidateSubscriptionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBValidateSubscriptionRequest {
        static instance: ::protobuf::rt::LazyV2<PBValidateSubscriptionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBValidateSubscriptionRequest::new)
    }
}

impl ::protobuf::Clear for PBValidateSubscriptionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBValidateSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBValidateSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBValidateSubscriptionReply {
    // message fields
    pub status: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBValidateSubscriptionReply {
    fn default() -> &'a PBValidateSubscriptionReply {
        <PBValidateSubscriptionReply as ::protobuf::Message>::default_instance()
    }
}

impl PBValidateSubscriptionReply {
    pub fn new() -> PBValidateSubscriptionReply {
        ::std::default::Default::default()
    }

    // bool status = 1;


    pub fn get_status(&self) -> bool {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = false;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: bool) {
        self.status = v;
    }
}

impl ::protobuf::Message for PBValidateSubscriptionReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != false {
            os.write_bool(1, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBValidateSubscriptionReply {
        PBValidateSubscriptionReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "status",
                |m: &PBValidateSubscriptionReply| { &m.status },
                |m: &mut PBValidateSubscriptionReply| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBValidateSubscriptionReply>(
                "PBValidateSubscriptionReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBValidateSubscriptionReply {
        static instance: ::protobuf::rt::LazyV2<PBValidateSubscriptionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBValidateSubscriptionReply::new)
    }
}

impl ::protobuf::Clear for PBValidateSubscriptionReply {
    fn clear(&mut self) {
        self.status = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBValidateSubscriptionReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBValidateSubscriptionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBIsPremiumRequest {
    // message fields
    pub types: ::std::vec::Vec<PBAccountListDataType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBIsPremiumRequest {
    fn default() -> &'a PBIsPremiumRequest {
        <PBIsPremiumRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBIsPremiumRequest {
    pub fn new() -> PBIsPremiumRequest {
        ::std::default::Default::default()
    }

    // repeated .PBAccountListDataType types = 1;


    pub fn get_types(&self) -> &[PBAccountListDataType] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<PBAccountListDataType>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<PBAccountListDataType> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<PBAccountListDataType> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBIsPremiumRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.types {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBIsPremiumRequest {
        PBIsPremiumRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountListDataType>>(
                "types",
                |m: &PBIsPremiumRequest| { &m.types },
                |m: &mut PBIsPremiumRequest| { &mut m.types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBIsPremiumRequest>(
                "PBIsPremiumRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBIsPremiumRequest {
        static instance: ::protobuf::rt::LazyV2<PBIsPremiumRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBIsPremiumRequest::new)
    }
}

impl ::protobuf::Clear for PBIsPremiumRequest {
    fn clear(&mut self) {
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBIsPremiumRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBIsPremiumRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBIsPremiumReply {
    // message fields
    pub premiums: ::protobuf::RepeatedField<PBIsPremiumReply_PremiumInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBIsPremiumReply {
    fn default() -> &'a PBIsPremiumReply {
        <PBIsPremiumReply as ::protobuf::Message>::default_instance()
    }
}

impl PBIsPremiumReply {
    pub fn new() -> PBIsPremiumReply {
        ::std::default::Default::default()
    }

    // repeated .PBIsPremiumReply.PremiumInfo premiums = 1;


    pub fn get_premiums(&self) -> &[PBIsPremiumReply_PremiumInfo] {
        &self.premiums
    }
    pub fn clear_premiums(&mut self) {
        self.premiums.clear();
    }

    // Param is passed by value, moved
    pub fn set_premiums(&mut self, v: ::protobuf::RepeatedField<PBIsPremiumReply_PremiumInfo>) {
        self.premiums = v;
    }

    // Mutable pointer to the field.
    pub fn mut_premiums(&mut self) -> &mut ::protobuf::RepeatedField<PBIsPremiumReply_PremiumInfo> {
        &mut self.premiums
    }

    // Take field
    pub fn take_premiums(&mut self) -> ::protobuf::RepeatedField<PBIsPremiumReply_PremiumInfo> {
        ::std::mem::replace(&mut self.premiums, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBIsPremiumReply {
    fn is_initialized(&self) -> bool {
        for v in &self.premiums {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.premiums)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.premiums {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.premiums {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBIsPremiumReply {
        PBIsPremiumReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBIsPremiumReply_PremiumInfo>>(
                "premiums",
                |m: &PBIsPremiumReply| { &m.premiums },
                |m: &mut PBIsPremiumReply| { &mut m.premiums },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBIsPremiumReply>(
                "PBIsPremiumReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBIsPremiumReply {
        static instance: ::protobuf::rt::LazyV2<PBIsPremiumReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBIsPremiumReply::new)
    }
}

impl ::protobuf::Clear for PBIsPremiumReply {
    fn clear(&mut self) {
        self.premiums.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBIsPremiumReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBIsPremiumReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBIsPremiumReply_PremiumInfo {
    // message fields
    pub field_type: PBAccountListDataType,
    pub isPremium: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBIsPremiumReply_PremiumInfo {
    fn default() -> &'a PBIsPremiumReply_PremiumInfo {
        <PBIsPremiumReply_PremiumInfo as ::protobuf::Message>::default_instance()
    }
}

impl PBIsPremiumReply_PremiumInfo {
    pub fn new() -> PBIsPremiumReply_PremiumInfo {
        ::std::default::Default::default()
    }

    // .PBAccountListDataType type = 1;


    pub fn get_field_type(&self) -> PBAccountListDataType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBAccountListDataType::PBAccountListDataType_None;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBAccountListDataType) {
        self.field_type = v;
    }

    // bool isPremium = 2;


    pub fn get_isPremium(&self) -> bool {
        self.isPremium
    }
    pub fn clear_isPremium(&mut self) {
        self.isPremium = false;
    }

    // Param is passed by value, moved
    pub fn set_isPremium(&mut self, v: bool) {
        self.isPremium = v;
    }
}

impl ::protobuf::Message for PBIsPremiumReply_PremiumInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isPremium = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PBAccountListDataType::PBAccountListDataType_None {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.isPremium != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PBAccountListDataType::PBAccountListDataType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.isPremium != false {
            os.write_bool(2, self.isPremium)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBIsPremiumReply_PremiumInfo {
        PBIsPremiumReply_PremiumInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountListDataType>>(
                "type",
                |m: &PBIsPremiumReply_PremiumInfo| { &m.field_type },
                |m: &mut PBIsPremiumReply_PremiumInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isPremium",
                |m: &PBIsPremiumReply_PremiumInfo| { &m.isPremium },
                |m: &mut PBIsPremiumReply_PremiumInfo| { &mut m.isPremium },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBIsPremiumReply_PremiumInfo>(
                "PBIsPremiumReply.PremiumInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBIsPremiumReply_PremiumInfo {
        static instance: ::protobuf::rt::LazyV2<PBIsPremiumReply_PremiumInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBIsPremiumReply_PremiumInfo::new)
    }
}

impl ::protobuf::Clear for PBIsPremiumReply_PremiumInfo {
    fn clear(&mut self) {
        self.field_type = PBAccountListDataType::PBAccountListDataType_None;
        self.isPremium = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBIsPremiumReply_PremiumInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBIsPremiumReply_PremiumInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBReportPageRequest {
    // message fields
    pub countElements: ::std::vec::Vec<PBCountDataType>,
    pub listElements: ::std::vec::Vec<PBAccountListDataType>,
    pub urgent: bool,
    pub countExcludeFromProgress: ::std::vec::Vec<PBCountDataType>,
    pub listExcludeFromProgress: ::std::vec::Vec<PBAccountListDataType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBReportPageRequest {
    fn default() -> &'a PBReportPageRequest {
        <PBReportPageRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBReportPageRequest {
    pub fn new() -> PBReportPageRequest {
        ::std::default::Default::default()
    }

    // repeated .PBCountDataType countElements = 1;


    pub fn get_countElements(&self) -> &[PBCountDataType] {
        &self.countElements
    }
    pub fn clear_countElements(&mut self) {
        self.countElements.clear();
    }

    // Param is passed by value, moved
    pub fn set_countElements(&mut self, v: ::std::vec::Vec<PBCountDataType>) {
        self.countElements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_countElements(&mut self) -> &mut ::std::vec::Vec<PBCountDataType> {
        &mut self.countElements
    }

    // Take field
    pub fn take_countElements(&mut self) -> ::std::vec::Vec<PBCountDataType> {
        ::std::mem::replace(&mut self.countElements, ::std::vec::Vec::new())
    }

    // repeated .PBAccountListDataType listElements = 2;


    pub fn get_listElements(&self) -> &[PBAccountListDataType] {
        &self.listElements
    }
    pub fn clear_listElements(&mut self) {
        self.listElements.clear();
    }

    // Param is passed by value, moved
    pub fn set_listElements(&mut self, v: ::std::vec::Vec<PBAccountListDataType>) {
        self.listElements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listElements(&mut self) -> &mut ::std::vec::Vec<PBAccountListDataType> {
        &mut self.listElements
    }

    // Take field
    pub fn take_listElements(&mut self) -> ::std::vec::Vec<PBAccountListDataType> {
        ::std::mem::replace(&mut self.listElements, ::std::vec::Vec::new())
    }

    // bool urgent = 3;


    pub fn get_urgent(&self) -> bool {
        self.urgent
    }
    pub fn clear_urgent(&mut self) {
        self.urgent = false;
    }

    // Param is passed by value, moved
    pub fn set_urgent(&mut self, v: bool) {
        self.urgent = v;
    }

    // repeated .PBCountDataType countExcludeFromProgress = 4;


    pub fn get_countExcludeFromProgress(&self) -> &[PBCountDataType] {
        &self.countExcludeFromProgress
    }
    pub fn clear_countExcludeFromProgress(&mut self) {
        self.countExcludeFromProgress.clear();
    }

    // Param is passed by value, moved
    pub fn set_countExcludeFromProgress(&mut self, v: ::std::vec::Vec<PBCountDataType>) {
        self.countExcludeFromProgress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_countExcludeFromProgress(&mut self) -> &mut ::std::vec::Vec<PBCountDataType> {
        &mut self.countExcludeFromProgress
    }

    // Take field
    pub fn take_countExcludeFromProgress(&mut self) -> ::std::vec::Vec<PBCountDataType> {
        ::std::mem::replace(&mut self.countExcludeFromProgress, ::std::vec::Vec::new())
    }

    // repeated .PBAccountListDataType listExcludeFromProgress = 5;


    pub fn get_listExcludeFromProgress(&self) -> &[PBAccountListDataType] {
        &self.listExcludeFromProgress
    }
    pub fn clear_listExcludeFromProgress(&mut self) {
        self.listExcludeFromProgress.clear();
    }

    // Param is passed by value, moved
    pub fn set_listExcludeFromProgress(&mut self, v: ::std::vec::Vec<PBAccountListDataType>) {
        self.listExcludeFromProgress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listExcludeFromProgress(&mut self) -> &mut ::std::vec::Vec<PBAccountListDataType> {
        &mut self.listExcludeFromProgress
    }

    // Take field
    pub fn take_listExcludeFromProgress(&mut self) -> ::std::vec::Vec<PBAccountListDataType> {
        ::std::mem::replace(&mut self.listExcludeFromProgress, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBReportPageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.countElements, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.listElements, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.urgent = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.countExcludeFromProgress, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.listExcludeFromProgress, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.countElements {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in &self.listElements {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if self.urgent != false {
            my_size += 2;
        }
        for value in &self.countExcludeFromProgress {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        for value in &self.listExcludeFromProgress {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.countElements {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.listElements {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.urgent != false {
            os.write_bool(3, self.urgent)?;
        }
        for v in &self.countExcludeFromProgress {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.listExcludeFromProgress {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBReportPageRequest {
        PBReportPageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBCountDataType>>(
                "countElements",
                |m: &PBReportPageRequest| { &m.countElements },
                |m: &mut PBReportPageRequest| { &mut m.countElements },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountListDataType>>(
                "listElements",
                |m: &PBReportPageRequest| { &m.listElements },
                |m: &mut PBReportPageRequest| { &mut m.listElements },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "urgent",
                |m: &PBReportPageRequest| { &m.urgent },
                |m: &mut PBReportPageRequest| { &mut m.urgent },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBCountDataType>>(
                "countExcludeFromProgress",
                |m: &PBReportPageRequest| { &m.countExcludeFromProgress },
                |m: &mut PBReportPageRequest| { &mut m.countExcludeFromProgress },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBAccountListDataType>>(
                "listExcludeFromProgress",
                |m: &PBReportPageRequest| { &m.listExcludeFromProgress },
                |m: &mut PBReportPageRequest| { &mut m.listExcludeFromProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBReportPageRequest>(
                "PBReportPageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBReportPageRequest {
        static instance: ::protobuf::rt::LazyV2<PBReportPageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBReportPageRequest::new)
    }
}

impl ::protobuf::Clear for PBReportPageRequest {
    fn clear(&mut self) {
        self.countElements.clear();
        self.listElements.clear();
        self.urgent = false;
        self.countExcludeFromProgress.clear();
        self.listExcludeFromProgress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBReportPageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBReportPageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBReportPageReply {
    // message fields
    pub spawnedNewTasks: bool,
    pub pageProgress: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBReportPageReply {
    fn default() -> &'a PBReportPageReply {
        <PBReportPageReply as ::protobuf::Message>::default_instance()
    }
}

impl PBReportPageReply {
    pub fn new() -> PBReportPageReply {
        ::std::default::Default::default()
    }

    // bool spawnedNewTasks = 1;


    pub fn get_spawnedNewTasks(&self) -> bool {
        self.spawnedNewTasks
    }
    pub fn clear_spawnedNewTasks(&mut self) {
        self.spawnedNewTasks = false;
    }

    // Param is passed by value, moved
    pub fn set_spawnedNewTasks(&mut self, v: bool) {
        self.spawnedNewTasks = v;
    }

    // int64 pageProgress = 2;


    pub fn get_pageProgress(&self) -> i64 {
        self.pageProgress
    }
    pub fn clear_pageProgress(&mut self) {
        self.pageProgress = 0;
    }

    // Param is passed by value, moved
    pub fn set_pageProgress(&mut self, v: i64) {
        self.pageProgress = v;
    }
}

impl ::protobuf::Message for PBReportPageReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spawnedNewTasks = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pageProgress = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.spawnedNewTasks != false {
            my_size += 2;
        }
        if self.pageProgress != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pageProgress, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.spawnedNewTasks != false {
            os.write_bool(1, self.spawnedNewTasks)?;
        }
        if self.pageProgress != 0 {
            os.write_int64(2, self.pageProgress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBReportPageReply {
        PBReportPageReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spawnedNewTasks",
                |m: &PBReportPageReply| { &m.spawnedNewTasks },
                |m: &mut PBReportPageReply| { &mut m.spawnedNewTasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pageProgress",
                |m: &PBReportPageReply| { &m.pageProgress },
                |m: &mut PBReportPageReply| { &mut m.pageProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBReportPageReply>(
                "PBReportPageReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBReportPageReply {
        static instance: ::protobuf::rt::LazyV2<PBReportPageReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBReportPageReply::new)
    }
}

impl ::protobuf::Clear for PBReportPageReply {
    fn clear(&mut self) {
        self.spawnedNewTasks = false;
        self.pageProgress = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBReportPageReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBReportPageReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostCountDataNotification {
    // message fields
    pub dataTypes: ::std::vec::Vec<PBCountDataType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostCountDataNotification {
    fn default() -> &'a PBPostCountDataNotification {
        <PBPostCountDataNotification as ::protobuf::Message>::default_instance()
    }
}

impl PBPostCountDataNotification {
    pub fn new() -> PBPostCountDataNotification {
        ::std::default::Default::default()
    }

    // repeated .PBCountDataType dataTypes = 1;


    pub fn get_dataTypes(&self) -> &[PBCountDataType] {
        &self.dataTypes
    }
    pub fn clear_dataTypes(&mut self) {
        self.dataTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataTypes(&mut self, v: ::std::vec::Vec<PBCountDataType>) {
        self.dataTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dataTypes(&mut self) -> &mut ::std::vec::Vec<PBCountDataType> {
        &mut self.dataTypes
    }

    // Take field
    pub fn take_dataTypes(&mut self) -> ::std::vec::Vec<PBCountDataType> {
        ::std::mem::replace(&mut self.dataTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBPostCountDataNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.dataTypes, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dataTypes {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dataTypes {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostCountDataNotification {
        PBPostCountDataNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBCountDataType>>(
                "dataTypes",
                |m: &PBPostCountDataNotification| { &m.dataTypes },
                |m: &mut PBPostCountDataNotification| { &mut m.dataTypes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostCountDataNotification>(
                "PBPostCountDataNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostCountDataNotification {
        static instance: ::protobuf::rt::LazyV2<PBPostCountDataNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostCountDataNotification::new)
    }
}

impl ::protobuf::Clear for PBPostCountDataNotification {
    fn clear(&mut self) {
        self.dataTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostCountDataNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostCountDataNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTransferExistingServerBatchTasksToClientRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTransferExistingServerBatchTasksToClientRequest {
    fn default() -> &'a PBTransferExistingServerBatchTasksToClientRequest {
        <PBTransferExistingServerBatchTasksToClientRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBTransferExistingServerBatchTasksToClientRequest {
    pub fn new() -> PBTransferExistingServerBatchTasksToClientRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PBTransferExistingServerBatchTasksToClientRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTransferExistingServerBatchTasksToClientRequest {
        PBTransferExistingServerBatchTasksToClientRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTransferExistingServerBatchTasksToClientRequest>(
                "PBTransferExistingServerBatchTasksToClientRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTransferExistingServerBatchTasksToClientRequest {
        static instance: ::protobuf::rt::LazyV2<PBTransferExistingServerBatchTasksToClientRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTransferExistingServerBatchTasksToClientRequest::new)
    }
}

impl ::protobuf::Clear for PBTransferExistingServerBatchTasksToClientRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTransferExistingServerBatchTasksToClientRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTransferExistingServerBatchTasksToClientRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBTransferExistingServerBatchTasksToClientReply {
    // message fields
    pub unfinishedFollowTargetInstagramIDs: ::std::vec::Vec<i64>,
    pub unfinishedUnfollowTargetInstagramIDs: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBTransferExistingServerBatchTasksToClientReply {
    fn default() -> &'a PBTransferExistingServerBatchTasksToClientReply {
        <PBTransferExistingServerBatchTasksToClientReply as ::protobuf::Message>::default_instance()
    }
}

impl PBTransferExistingServerBatchTasksToClientReply {
    pub fn new() -> PBTransferExistingServerBatchTasksToClientReply {
        ::std::default::Default::default()
    }

    // repeated int64 unfinishedFollowTargetInstagramIDs = 1;


    pub fn get_unfinishedFollowTargetInstagramIDs(&self) -> &[i64] {
        &self.unfinishedFollowTargetInstagramIDs
    }
    pub fn clear_unfinishedFollowTargetInstagramIDs(&mut self) {
        self.unfinishedFollowTargetInstagramIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_unfinishedFollowTargetInstagramIDs(&mut self, v: ::std::vec::Vec<i64>) {
        self.unfinishedFollowTargetInstagramIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unfinishedFollowTargetInstagramIDs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.unfinishedFollowTargetInstagramIDs
    }

    // Take field
    pub fn take_unfinishedFollowTargetInstagramIDs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.unfinishedFollowTargetInstagramIDs, ::std::vec::Vec::new())
    }

    // repeated int64 unfinishedUnfollowTargetInstagramIDs = 2;


    pub fn get_unfinishedUnfollowTargetInstagramIDs(&self) -> &[i64] {
        &self.unfinishedUnfollowTargetInstagramIDs
    }
    pub fn clear_unfinishedUnfollowTargetInstagramIDs(&mut self) {
        self.unfinishedUnfollowTargetInstagramIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_unfinishedUnfollowTargetInstagramIDs(&mut self, v: ::std::vec::Vec<i64>) {
        self.unfinishedUnfollowTargetInstagramIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unfinishedUnfollowTargetInstagramIDs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.unfinishedUnfollowTargetInstagramIDs
    }

    // Take field
    pub fn take_unfinishedUnfollowTargetInstagramIDs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.unfinishedUnfollowTargetInstagramIDs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBTransferExistingServerBatchTasksToClientReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.unfinishedFollowTargetInstagramIDs)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.unfinishedUnfollowTargetInstagramIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unfinishedFollowTargetInstagramIDs {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.unfinishedUnfollowTargetInstagramIDs {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unfinishedFollowTargetInstagramIDs {
            os.write_int64(1, *v)?;
        };
        for v in &self.unfinishedUnfollowTargetInstagramIDs {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBTransferExistingServerBatchTasksToClientReply {
        PBTransferExistingServerBatchTasksToClientReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unfinishedFollowTargetInstagramIDs",
                |m: &PBTransferExistingServerBatchTasksToClientReply| { &m.unfinishedFollowTargetInstagramIDs },
                |m: &mut PBTransferExistingServerBatchTasksToClientReply| { &mut m.unfinishedFollowTargetInstagramIDs },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unfinishedUnfollowTargetInstagramIDs",
                |m: &PBTransferExistingServerBatchTasksToClientReply| { &m.unfinishedUnfollowTargetInstagramIDs },
                |m: &mut PBTransferExistingServerBatchTasksToClientReply| { &mut m.unfinishedUnfollowTargetInstagramIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBTransferExistingServerBatchTasksToClientReply>(
                "PBTransferExistingServerBatchTasksToClientReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBTransferExistingServerBatchTasksToClientReply {
        static instance: ::protobuf::rt::LazyV2<PBTransferExistingServerBatchTasksToClientReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBTransferExistingServerBatchTasksToClientReply::new)
    }
}

impl ::protobuf::Clear for PBTransferExistingServerBatchTasksToClientReply {
    fn clear(&mut self) {
        self.unfinishedFollowTargetInstagramIDs.clear();
        self.unfinishedUnfollowTargetInstagramIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBTransferExistingServerBatchTasksToClientReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTransferExistingServerBatchTasksToClientReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchBatchTaskRequest {
    // message fields
    pub taskIDs: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchBatchTaskRequest {
    fn default() -> &'a PBFetchBatchTaskRequest {
        <PBFetchBatchTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchBatchTaskRequest {
    pub fn new() -> PBFetchBatchTaskRequest {
        ::std::default::Default::default()
    }

    // repeated int64 taskIDs = 1;


    pub fn get_taskIDs(&self) -> &[i64] {
        &self.taskIDs
    }
    pub fn clear_taskIDs(&mut self) {
        self.taskIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_taskIDs(&mut self, v: ::std::vec::Vec<i64>) {
        self.taskIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taskIDs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.taskIDs
    }

    // Take field
    pub fn take_taskIDs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.taskIDs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBFetchBatchTaskRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.taskIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.taskIDs {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.taskIDs {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchBatchTaskRequest {
        PBFetchBatchTaskRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "taskIDs",
                |m: &PBFetchBatchTaskRequest| { &m.taskIDs },
                |m: &mut PBFetchBatchTaskRequest| { &mut m.taskIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchBatchTaskRequest>(
                "PBFetchBatchTaskRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchBatchTaskRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchBatchTaskRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchBatchTaskRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchBatchTaskRequest {
    fn clear(&mut self) {
        self.taskIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchBatchTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchBatchTaskRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBBatchTaskSummary {
    // message fields
    pub taskID: i64,
    pub taskType: PBBatchTaskType,
    pub taskStatus: PBBatchTaskStatus,
    pub totalTargetCount: i64,
    pub finishedTargetCount: i64,
    pub startTime: i64,
    pub endTime: i64,
    pub firstTargetAccount: ::protobuf::SingularPtrField<PBAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBBatchTaskSummary {
    fn default() -> &'a PBBatchTaskSummary {
        <PBBatchTaskSummary as ::protobuf::Message>::default_instance()
    }
}

impl PBBatchTaskSummary {
    pub fn new() -> PBBatchTaskSummary {
        ::std::default::Default::default()
    }

    // int64 taskID = 1;


    pub fn get_taskID(&self) -> i64 {
        self.taskID
    }
    pub fn clear_taskID(&mut self) {
        self.taskID = 0;
    }

    // Param is passed by value, moved
    pub fn set_taskID(&mut self, v: i64) {
        self.taskID = v;
    }

    // .PBBatchTaskType taskType = 2;


    pub fn get_taskType(&self) -> PBBatchTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBBatchTaskType) {
        self.taskType = v;
    }

    // .PBBatchTaskStatus taskStatus = 3;


    pub fn get_taskStatus(&self) -> PBBatchTaskStatus {
        self.taskStatus
    }
    pub fn clear_taskStatus(&mut self) {
        self.taskStatus = PBBatchTaskStatus::PBBatchTaskStatus_Pending;
    }

    // Param is passed by value, moved
    pub fn set_taskStatus(&mut self, v: PBBatchTaskStatus) {
        self.taskStatus = v;
    }

    // int64 totalTargetCount = 4;


    pub fn get_totalTargetCount(&self) -> i64 {
        self.totalTargetCount
    }
    pub fn clear_totalTargetCount(&mut self) {
        self.totalTargetCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalTargetCount(&mut self, v: i64) {
        self.totalTargetCount = v;
    }

    // int64 finishedTargetCount = 5;


    pub fn get_finishedTargetCount(&self) -> i64 {
        self.finishedTargetCount
    }
    pub fn clear_finishedTargetCount(&mut self) {
        self.finishedTargetCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_finishedTargetCount(&mut self, v: i64) {
        self.finishedTargetCount = v;
    }

    // int64 startTime = 6;


    pub fn get_startTime(&self) -> i64 {
        self.startTime
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: i64) {
        self.startTime = v;
    }

    // int64 endTime = 7;


    pub fn get_endTime(&self) -> i64 {
        self.endTime
    }
    pub fn clear_endTime(&mut self) {
        self.endTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_endTime(&mut self, v: i64) {
        self.endTime = v;
    }

    // .PBAccount firstTargetAccount = 8;


    pub fn get_firstTargetAccount(&self) -> &PBAccount {
        self.firstTargetAccount.as_ref().unwrap_or_else(|| <PBAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_firstTargetAccount(&mut self) {
        self.firstTargetAccount.clear();
    }

    pub fn has_firstTargetAccount(&self) -> bool {
        self.firstTargetAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstTargetAccount(&mut self, v: PBAccount) {
        self.firstTargetAccount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstTargetAccount(&mut self) -> &mut PBAccount {
        if self.firstTargetAccount.is_none() {
            self.firstTargetAccount.set_default();
        }
        self.firstTargetAccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstTargetAccount(&mut self) -> PBAccount {
        self.firstTargetAccount.take().unwrap_or_else(|| PBAccount::new())
    }
}

impl ::protobuf::Message for PBBatchTaskSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.firstTargetAccount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.taskID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskStatus, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalTargetCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.finishedTargetCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endTime = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.firstTargetAccount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.taskID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.taskID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            my_size += ::protobuf::rt::enum_size(2, self.taskType);
        }
        if self.taskStatus != PBBatchTaskStatus::PBBatchTaskStatus_Pending {
            my_size += ::protobuf::rt::enum_size(3, self.taskStatus);
        }
        if self.totalTargetCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.totalTargetCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.finishedTargetCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.finishedTargetCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.startTime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.startTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endTime != 0 {
            my_size += ::protobuf::rt::value_size(7, self.endTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.firstTargetAccount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.taskID != 0 {
            os.write_int64(1, self.taskID)?;
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.taskStatus != PBBatchTaskStatus::PBBatchTaskStatus_Pending {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.taskStatus))?;
        }
        if self.totalTargetCount != 0 {
            os.write_int64(4, self.totalTargetCount)?;
        }
        if self.finishedTargetCount != 0 {
            os.write_int64(5, self.finishedTargetCount)?;
        }
        if self.startTime != 0 {
            os.write_int64(6, self.startTime)?;
        }
        if self.endTime != 0 {
            os.write_int64(7, self.endTime)?;
        }
        if let Some(ref v) = self.firstTargetAccount.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBBatchTaskSummary {
        PBBatchTaskSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "taskID",
                |m: &PBBatchTaskSummary| { &m.taskID },
                |m: &mut PBBatchTaskSummary| { &mut m.taskID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskType>>(
                "taskType",
                |m: &PBBatchTaskSummary| { &m.taskType },
                |m: &mut PBBatchTaskSummary| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskStatus>>(
                "taskStatus",
                |m: &PBBatchTaskSummary| { &m.taskStatus },
                |m: &mut PBBatchTaskSummary| { &mut m.taskStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalTargetCount",
                |m: &PBBatchTaskSummary| { &m.totalTargetCount },
                |m: &mut PBBatchTaskSummary| { &mut m.totalTargetCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "finishedTargetCount",
                |m: &PBBatchTaskSummary| { &m.finishedTargetCount },
                |m: &mut PBBatchTaskSummary| { &mut m.finishedTargetCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTime",
                |m: &PBBatchTaskSummary| { &m.startTime },
                |m: &mut PBBatchTaskSummary| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endTime",
                |m: &PBBatchTaskSummary| { &m.endTime },
                |m: &mut PBBatchTaskSummary| { &mut m.endTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccount>>(
                "firstTargetAccount",
                |m: &PBBatchTaskSummary| { &m.firstTargetAccount },
                |m: &mut PBBatchTaskSummary| { &mut m.firstTargetAccount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBBatchTaskSummary>(
                "PBBatchTaskSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBBatchTaskSummary {
        static instance: ::protobuf::rt::LazyV2<PBBatchTaskSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBBatchTaskSummary::new)
    }
}

impl ::protobuf::Clear for PBBatchTaskSummary {
    fn clear(&mut self) {
        self.taskID = 0;
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
        self.taskStatus = PBBatchTaskStatus::PBBatchTaskStatus_Pending;
        self.totalTargetCount = 0;
        self.finishedTargetCount = 0;
        self.startTime = 0;
        self.endTime = 0;
        self.firstTargetAccount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBBatchTaskSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBBatchTaskSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchBatchTaskReply {
    // message fields
    pub results: ::protobuf::RepeatedField<PBBatchTaskSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchBatchTaskReply {
    fn default() -> &'a PBFetchBatchTaskReply {
        <PBFetchBatchTaskReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchBatchTaskReply {
    pub fn new() -> PBFetchBatchTaskReply {
        ::std::default::Default::default()
    }

    // repeated .PBBatchTaskSummary results = 1;


    pub fn get_results(&self) -> &[PBBatchTaskSummary] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<PBBatchTaskSummary>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<PBBatchTaskSummary> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<PBBatchTaskSummary> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchBatchTaskReply {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchBatchTaskReply {
        PBFetchBatchTaskReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBBatchTaskSummary>>(
                "results",
                |m: &PBFetchBatchTaskReply| { &m.results },
                |m: &mut PBFetchBatchTaskReply| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchBatchTaskReply>(
                "PBFetchBatchTaskReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchBatchTaskReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchBatchTaskReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchBatchTaskReply::new)
    }
}

impl ::protobuf::Clear for PBFetchBatchTaskReply {
    fn clear(&mut self) {
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchBatchTaskReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchBatchTaskReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBUpdateBatchTaskRequest {
    // message fields
    pub field_type: PBUpdateBatchTaskType,
    pub taskType: PBBatchTaskType,
    pub taskID: i64,
    pub targetIDs: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBUpdateBatchTaskRequest {
    fn default() -> &'a PBUpdateBatchTaskRequest {
        <PBUpdateBatchTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBUpdateBatchTaskRequest {
    pub fn new() -> PBUpdateBatchTaskRequest {
        ::std::default::Default::default()
    }

    // .PBUpdateBatchTaskType type = 1;


    pub fn get_field_type(&self) -> PBUpdateBatchTaskType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBUpdateBatchTaskType::PBUpdateBatchTaskType_None;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBUpdateBatchTaskType) {
        self.field_type = v;
    }

    // .PBBatchTaskType taskType = 2;


    pub fn get_taskType(&self) -> PBBatchTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBBatchTaskType) {
        self.taskType = v;
    }

    // int64 taskID = 3;


    pub fn get_taskID(&self) -> i64 {
        self.taskID
    }
    pub fn clear_taskID(&mut self) {
        self.taskID = 0;
    }

    // Param is passed by value, moved
    pub fn set_taskID(&mut self, v: i64) {
        self.taskID = v;
    }

    // repeated int64 targetIDs = 4;


    pub fn get_targetIDs(&self) -> &[i64] {
        &self.targetIDs
    }
    pub fn clear_targetIDs(&mut self) {
        self.targetIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetIDs(&mut self, v: ::std::vec::Vec<i64>) {
        self.targetIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetIDs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.targetIDs
    }

    // Take field
    pub fn take_targetIDs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.targetIDs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBUpdateBatchTaskRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.taskID = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.targetIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PBUpdateBatchTaskType::PBUpdateBatchTaskType_None {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            my_size += ::protobuf::rt::enum_size(2, self.taskType);
        }
        if self.taskID != 0 {
            my_size += ::protobuf::rt::value_size(3, self.taskID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.targetIDs {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PBUpdateBatchTaskType::PBUpdateBatchTaskType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.taskID != 0 {
            os.write_int64(3, self.taskID)?;
        }
        for v in &self.targetIDs {
            os.write_int64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBUpdateBatchTaskRequest {
        PBUpdateBatchTaskRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBUpdateBatchTaskType>>(
                "type",
                |m: &PBUpdateBatchTaskRequest| { &m.field_type },
                |m: &mut PBUpdateBatchTaskRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskType>>(
                "taskType",
                |m: &PBUpdateBatchTaskRequest| { &m.taskType },
                |m: &mut PBUpdateBatchTaskRequest| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "taskID",
                |m: &PBUpdateBatchTaskRequest| { &m.taskID },
                |m: &mut PBUpdateBatchTaskRequest| { &mut m.taskID },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "targetIDs",
                |m: &PBUpdateBatchTaskRequest| { &m.targetIDs },
                |m: &mut PBUpdateBatchTaskRequest| { &mut m.targetIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBUpdateBatchTaskRequest>(
                "PBUpdateBatchTaskRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBUpdateBatchTaskRequest {
        static instance: ::protobuf::rt::LazyV2<PBUpdateBatchTaskRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBUpdateBatchTaskRequest::new)
    }
}

impl ::protobuf::Clear for PBUpdateBatchTaskRequest {
    fn clear(&mut self) {
        self.field_type = PBUpdateBatchTaskType::PBUpdateBatchTaskType_None;
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
        self.taskID = 0;
        self.targetIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBUpdateBatchTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBUpdateBatchTaskRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBUpdateBatchTaskReply {
    // message fields
    pub taskID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBUpdateBatchTaskReply {
    fn default() -> &'a PBUpdateBatchTaskReply {
        <PBUpdateBatchTaskReply as ::protobuf::Message>::default_instance()
    }
}

impl PBUpdateBatchTaskReply {
    pub fn new() -> PBUpdateBatchTaskReply {
        ::std::default::Default::default()
    }

    // int64 taskID = 1;


    pub fn get_taskID(&self) -> i64 {
        self.taskID
    }
    pub fn clear_taskID(&mut self) {
        self.taskID = 0;
    }

    // Param is passed by value, moved
    pub fn set_taskID(&mut self, v: i64) {
        self.taskID = v;
    }
}

impl ::protobuf::Message for PBUpdateBatchTaskReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.taskID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.taskID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.taskID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.taskID != 0 {
            os.write_int64(1, self.taskID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBUpdateBatchTaskReply {
        PBUpdateBatchTaskReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "taskID",
                |m: &PBUpdateBatchTaskReply| { &m.taskID },
                |m: &mut PBUpdateBatchTaskReply| { &mut m.taskID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBUpdateBatchTaskReply>(
                "PBUpdateBatchTaskReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBUpdateBatchTaskReply {
        static instance: ::protobuf::rt::LazyV2<PBUpdateBatchTaskReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBUpdateBatchTaskReply::new)
    }
}

impl ::protobuf::Clear for PBUpdateBatchTaskReply {
    fn clear(&mut self) {
        self.taskID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBUpdateBatchTaskReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBUpdateBatchTaskReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchPendingBatchTaskTargetsRequest {
    // message fields
    pub taskTypes: ::std::vec::Vec<PBBatchTaskType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchPendingBatchTaskTargetsRequest {
    fn default() -> &'a PBFetchPendingBatchTaskTargetsRequest {
        <PBFetchPendingBatchTaskTargetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchPendingBatchTaskTargetsRequest {
    pub fn new() -> PBFetchPendingBatchTaskTargetsRequest {
        ::std::default::Default::default()
    }

    // repeated .PBBatchTaskType taskTypes = 1;


    pub fn get_taskTypes(&self) -> &[PBBatchTaskType] {
        &self.taskTypes
    }
    pub fn clear_taskTypes(&mut self) {
        self.taskTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_taskTypes(&mut self, v: ::std::vec::Vec<PBBatchTaskType>) {
        self.taskTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taskTypes(&mut self) -> &mut ::std::vec::Vec<PBBatchTaskType> {
        &mut self.taskTypes
    }

    // Take field
    pub fn take_taskTypes(&mut self) -> ::std::vec::Vec<PBBatchTaskType> {
        ::std::mem::replace(&mut self.taskTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBFetchPendingBatchTaskTargetsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.taskTypes, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.taskTypes {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.taskTypes {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchPendingBatchTaskTargetsRequest {
        PBFetchPendingBatchTaskTargetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskType>>(
                "taskTypes",
                |m: &PBFetchPendingBatchTaskTargetsRequest| { &m.taskTypes },
                |m: &mut PBFetchPendingBatchTaskTargetsRequest| { &mut m.taskTypes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchPendingBatchTaskTargetsRequest>(
                "PBFetchPendingBatchTaskTargetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchPendingBatchTaskTargetsRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchPendingBatchTaskTargetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchPendingBatchTaskTargetsRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchPendingBatchTaskTargetsRequest {
    fn clear(&mut self) {
        self.taskTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchPendingBatchTaskTargetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchPendingBatchTaskTargetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchPendingBatchTaskTargetsReply {
    // message fields
    pub results: ::protobuf::RepeatedField<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchPendingBatchTaskTargetsReply {
    fn default() -> &'a PBFetchPendingBatchTaskTargetsReply {
        <PBFetchPendingBatchTaskTargetsReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchPendingBatchTaskTargetsReply {
    pub fn new() -> PBFetchPendingBatchTaskTargetsReply {
        ::std::default::Default::default()
    }

    // repeated .PBFetchPendingBatchTaskTargetsReply.PendingBatchTaskTargets results = 1;


    pub fn get_results(&self) -> &[PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PBFetchPendingBatchTaskTargetsReply {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchPendingBatchTaskTargetsReply {
        PBFetchPendingBatchTaskTargetsReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets>>(
                "results",
                |m: &PBFetchPendingBatchTaskTargetsReply| { &m.results },
                |m: &mut PBFetchPendingBatchTaskTargetsReply| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchPendingBatchTaskTargetsReply>(
                "PBFetchPendingBatchTaskTargetsReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchPendingBatchTaskTargetsReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchPendingBatchTaskTargetsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchPendingBatchTaskTargetsReply::new)
    }
}

impl ::protobuf::Clear for PBFetchPendingBatchTaskTargetsReply {
    fn clear(&mut self) {
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchPendingBatchTaskTargetsReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchPendingBatchTaskTargetsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    // message fields
    pub taskType: PBBatchTaskType,
    pub pendingTargetIDs: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    fn default() -> &'a PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
        <PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    pub fn new() -> PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
        ::std::default::Default::default()
    }

    // .PBBatchTaskType taskType = 1;


    pub fn get_taskType(&self) -> PBBatchTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBBatchTaskType) {
        self.taskType = v;
    }

    // repeated int64 pendingTargetIDs = 2;


    pub fn get_pendingTargetIDs(&self) -> &[i64] {
        &self.pendingTargetIDs
    }
    pub fn clear_pendingTargetIDs(&mut self) {
        self.pendingTargetIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pendingTargetIDs(&mut self, v: ::std::vec::Vec<i64>) {
        self.pendingTargetIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pendingTargetIDs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.pendingTargetIDs
    }

    // Take field
    pub fn take_pendingTargetIDs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.pendingTargetIDs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.pendingTargetIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            my_size += ::protobuf::rt::enum_size(1, self.taskType);
        }
        for value in &self.pendingTargetIDs {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        for v in &self.pendingTargetIDs {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
        PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskType>>(
                "taskType",
                |m: &PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets| { &m.taskType },
                |m: &mut PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pendingTargetIDs",
                |m: &PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets| { &m.pendingTargetIDs },
                |m: &mut PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets| { &mut m.pendingTargetIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets>(
                "PBFetchPendingBatchTaskTargetsReply.PendingBatchTaskTargets",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
        static instance: ::protobuf::rt::LazyV2<PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets::new)
    }
}

impl ::protobuf::Clear for PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    fn clear(&mut self) {
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
        self.pendingTargetIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchPendingBatchTaskTargetsReply_PendingBatchTaskTargets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostPendingBatchTaskTargetDelta {
    // message fields
    pub deltaType: PBPostPendingBatchTaskTargetDeltaType,
    pub taskType: PBBatchTaskType,
    pub taskID: i64,
    pub accountID: ::std::string::String,
    pub targetIDs: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostPendingBatchTaskTargetDelta {
    fn default() -> &'a PBPostPendingBatchTaskTargetDelta {
        <PBPostPendingBatchTaskTargetDelta as ::protobuf::Message>::default_instance()
    }
}

impl PBPostPendingBatchTaskTargetDelta {
    pub fn new() -> PBPostPendingBatchTaskTargetDelta {
        ::std::default::Default::default()
    }

    // .PBPostPendingBatchTaskTargetDeltaType deltaType = 1;


    pub fn get_deltaType(&self) -> PBPostPendingBatchTaskTargetDeltaType {
        self.deltaType
    }
    pub fn clear_deltaType(&mut self) {
        self.deltaType = PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None;
    }

    // Param is passed by value, moved
    pub fn set_deltaType(&mut self, v: PBPostPendingBatchTaskTargetDeltaType) {
        self.deltaType = v;
    }

    // .PBBatchTaskType taskType = 2;


    pub fn get_taskType(&self) -> PBBatchTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBBatchTaskType) {
        self.taskType = v;
    }

    // int64 taskID = 3;


    pub fn get_taskID(&self) -> i64 {
        self.taskID
    }
    pub fn clear_taskID(&mut self) {
        self.taskID = 0;
    }

    // Param is passed by value, moved
    pub fn set_taskID(&mut self, v: i64) {
        self.taskID = v;
    }

    // string accountID = 4;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // repeated int64 targetIDs = 5;


    pub fn get_targetIDs(&self) -> &[i64] {
        &self.targetIDs
    }
    pub fn clear_targetIDs(&mut self) {
        self.targetIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetIDs(&mut self, v: ::std::vec::Vec<i64>) {
        self.targetIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetIDs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.targetIDs
    }

    // Take field
    pub fn take_targetIDs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.targetIDs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PBPostPendingBatchTaskTargetDelta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.deltaType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.taskID = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.targetIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.deltaType != PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None {
            my_size += ::protobuf::rt::enum_size(1, self.deltaType);
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            my_size += ::protobuf::rt::enum_size(2, self.taskType);
        }
        if self.taskID != 0 {
            my_size += ::protobuf::rt::value_size(3, self.taskID, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.accountID);
        }
        for value in &self.targetIDs {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.deltaType != PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.deltaType))?;
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.taskID != 0 {
            os.write_int64(3, self.taskID)?;
        }
        if !self.accountID.is_empty() {
            os.write_string(4, &self.accountID)?;
        }
        for v in &self.targetIDs {
            os.write_int64(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostPendingBatchTaskTargetDelta {
        PBPostPendingBatchTaskTargetDelta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBPostPendingBatchTaskTargetDeltaType>>(
                "deltaType",
                |m: &PBPostPendingBatchTaskTargetDelta| { &m.deltaType },
                |m: &mut PBPostPendingBatchTaskTargetDelta| { &mut m.deltaType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskType>>(
                "taskType",
                |m: &PBPostPendingBatchTaskTargetDelta| { &m.taskType },
                |m: &mut PBPostPendingBatchTaskTargetDelta| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "taskID",
                |m: &PBPostPendingBatchTaskTargetDelta| { &m.taskID },
                |m: &mut PBPostPendingBatchTaskTargetDelta| { &mut m.taskID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBPostPendingBatchTaskTargetDelta| { &m.accountID },
                |m: &mut PBPostPendingBatchTaskTargetDelta| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "targetIDs",
                |m: &PBPostPendingBatchTaskTargetDelta| { &m.targetIDs },
                |m: &mut PBPostPendingBatchTaskTargetDelta| { &mut m.targetIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostPendingBatchTaskTargetDelta>(
                "PBPostPendingBatchTaskTargetDelta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostPendingBatchTaskTargetDelta {
        static instance: ::protobuf::rt::LazyV2<PBPostPendingBatchTaskTargetDelta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostPendingBatchTaskTargetDelta::new)
    }
}

impl ::protobuf::Clear for PBPostPendingBatchTaskTargetDelta {
    fn clear(&mut self) {
        self.deltaType = PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None;
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
        self.taskID = 0;
        self.accountID.clear();
        self.targetIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostPendingBatchTaskTargetDelta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostPendingBatchTaskTargetDelta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBPostBatchTaskCompleteNotification {
    // message fields
    pub accountID: ::std::string::String,
    pub taskID: i64,
    pub taskType: PBBatchTaskType,
    pub taskStatus: PBBatchTaskStatus,
    pub totalTargetCount: i64,
    pub finishedTargetCount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBPostBatchTaskCompleteNotification {
    fn default() -> &'a PBPostBatchTaskCompleteNotification {
        <PBPostBatchTaskCompleteNotification as ::protobuf::Message>::default_instance()
    }
}

impl PBPostBatchTaskCompleteNotification {
    pub fn new() -> PBPostBatchTaskCompleteNotification {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // int64 taskID = 2;


    pub fn get_taskID(&self) -> i64 {
        self.taskID
    }
    pub fn clear_taskID(&mut self) {
        self.taskID = 0;
    }

    // Param is passed by value, moved
    pub fn set_taskID(&mut self, v: i64) {
        self.taskID = v;
    }

    // .PBBatchTaskType taskType = 3;


    pub fn get_taskType(&self) -> PBBatchTaskType {
        self.taskType
    }
    pub fn clear_taskType(&mut self) {
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
    }

    // Param is passed by value, moved
    pub fn set_taskType(&mut self, v: PBBatchTaskType) {
        self.taskType = v;
    }

    // .PBBatchTaskStatus taskStatus = 4;


    pub fn get_taskStatus(&self) -> PBBatchTaskStatus {
        self.taskStatus
    }
    pub fn clear_taskStatus(&mut self) {
        self.taskStatus = PBBatchTaskStatus::PBBatchTaskStatus_Pending;
    }

    // Param is passed by value, moved
    pub fn set_taskStatus(&mut self, v: PBBatchTaskStatus) {
        self.taskStatus = v;
    }

    // int64 totalTargetCount = 5;


    pub fn get_totalTargetCount(&self) -> i64 {
        self.totalTargetCount
    }
    pub fn clear_totalTargetCount(&mut self) {
        self.totalTargetCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalTargetCount(&mut self, v: i64) {
        self.totalTargetCount = v;
    }

    // int64 finishedTargetCount = 6;


    pub fn get_finishedTargetCount(&self) -> i64 {
        self.finishedTargetCount
    }
    pub fn clear_finishedTargetCount(&mut self) {
        self.finishedTargetCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_finishedTargetCount(&mut self, v: i64) {
        self.finishedTargetCount = v;
    }
}

impl ::protobuf::Message for PBPostBatchTaskCompleteNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.taskID = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.taskStatus, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalTargetCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.finishedTargetCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if self.taskID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.taskID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            my_size += ::protobuf::rt::enum_size(3, self.taskType);
        }
        if self.taskStatus != PBBatchTaskStatus::PBBatchTaskStatus_Pending {
            my_size += ::protobuf::rt::enum_size(4, self.taskStatus);
        }
        if self.totalTargetCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.totalTargetCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.finishedTargetCount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.finishedTargetCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if self.taskID != 0 {
            os.write_int64(2, self.taskID)?;
        }
        if self.taskType != PBBatchTaskType::PBBatchTaskType_None {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.taskType))?;
        }
        if self.taskStatus != PBBatchTaskStatus::PBBatchTaskStatus_Pending {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.taskStatus))?;
        }
        if self.totalTargetCount != 0 {
            os.write_int64(5, self.totalTargetCount)?;
        }
        if self.finishedTargetCount != 0 {
            os.write_int64(6, self.finishedTargetCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBPostBatchTaskCompleteNotification {
        PBPostBatchTaskCompleteNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBPostBatchTaskCompleteNotification| { &m.accountID },
                |m: &mut PBPostBatchTaskCompleteNotification| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "taskID",
                |m: &PBPostBatchTaskCompleteNotification| { &m.taskID },
                |m: &mut PBPostBatchTaskCompleteNotification| { &mut m.taskID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskType>>(
                "taskType",
                |m: &PBPostBatchTaskCompleteNotification| { &m.taskType },
                |m: &mut PBPostBatchTaskCompleteNotification| { &mut m.taskType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBBatchTaskStatus>>(
                "taskStatus",
                |m: &PBPostBatchTaskCompleteNotification| { &m.taskStatus },
                |m: &mut PBPostBatchTaskCompleteNotification| { &mut m.taskStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalTargetCount",
                |m: &PBPostBatchTaskCompleteNotification| { &m.totalTargetCount },
                |m: &mut PBPostBatchTaskCompleteNotification| { &mut m.totalTargetCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "finishedTargetCount",
                |m: &PBPostBatchTaskCompleteNotification| { &m.finishedTargetCount },
                |m: &mut PBPostBatchTaskCompleteNotification| { &mut m.finishedTargetCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBPostBatchTaskCompleteNotification>(
                "PBPostBatchTaskCompleteNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBPostBatchTaskCompleteNotification {
        static instance: ::protobuf::rt::LazyV2<PBPostBatchTaskCompleteNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBPostBatchTaskCompleteNotification::new)
    }
}

impl ::protobuf::Clear for PBPostBatchTaskCompleteNotification {
    fn clear(&mut self) {
        self.accountID.clear();
        self.taskID = 0;
        self.taskType = PBBatchTaskType::PBBatchTaskType_None;
        self.taskStatus = PBBatchTaskStatus::PBBatchTaskStatus_Pending;
        self.totalTargetCount = 0;
        self.finishedTargetCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBPostBatchTaskCompleteNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostBatchTaskCompleteNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBProxiedFetchContent {
    // message fields
    pub field_type: PBTaskType,
    pub executorAccountID: ::std::string::String,
    // message oneof groups
    pub fetchContent: ::std::option::Option<PBProxiedFetchContent_oneof_fetchContent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBProxiedFetchContent {
    fn default() -> &'a PBProxiedFetchContent {
        <PBProxiedFetchContent as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PBProxiedFetchContent_oneof_fetchContent {
    contentFetchAccountInfo(PBTaskContentFetchAccountInfo),
}

impl PBProxiedFetchContent {
    pub fn new() -> PBProxiedFetchContent {
        ::std::default::Default::default()
    }

    // .PBTaskType type = 1;


    pub fn get_field_type(&self) -> PBTaskType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBTaskType::PBTaskType_Noop;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBTaskType) {
        self.field_type = v;
    }

    // string executorAccountID = 2;


    pub fn get_executorAccountID(&self) -> &str {
        &self.executorAccountID
    }
    pub fn clear_executorAccountID(&mut self) {
        self.executorAccountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_executorAccountID(&mut self, v: ::std::string::String) {
        self.executorAccountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executorAccountID(&mut self) -> &mut ::std::string::String {
        &mut self.executorAccountID
    }

    // Take field
    pub fn take_executorAccountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.executorAccountID, ::std::string::String::new())
    }

    // .PBTaskContentFetchAccountInfo contentFetchAccountInfo = 3;


    pub fn get_contentFetchAccountInfo(&self) -> &PBTaskContentFetchAccountInfo {
        match self.fetchContent {
            ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(ref v)) => v,
            _ => <PBTaskContentFetchAccountInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_contentFetchAccountInfo(&mut self) {
        self.fetchContent = ::std::option::Option::None;
    }

    pub fn has_contentFetchAccountInfo(&self) -> bool {
        match self.fetchContent {
            ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contentFetchAccountInfo(&mut self, v: PBTaskContentFetchAccountInfo) {
        self.fetchContent = ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contentFetchAccountInfo(&mut self) -> &mut PBTaskContentFetchAccountInfo {
        if let ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(_)) = self.fetchContent {
        } else {
            self.fetchContent = ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(PBTaskContentFetchAccountInfo::new()));
        }
        match self.fetchContent {
            ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contentFetchAccountInfo(&mut self) -> PBTaskContentFetchAccountInfo {
        if self.has_contentFetchAccountInfo() {
            match self.fetchContent.take() {
                ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PBTaskContentFetchAccountInfo::new()
        }
    }
}

impl ::protobuf::Message for PBProxiedFetchContent {
    fn is_initialized(&self) -> bool {
        if let Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(ref v)) = self.fetchContent {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.executorAccountID)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fetchContent = ::std::option::Option::Some(PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PBTaskType::PBTaskType_Noop {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.executorAccountID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.executorAccountID);
        }
        if let ::std::option::Option::Some(ref v) = self.fetchContent {
            match v {
                &PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PBTaskType::PBTaskType_Noop {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.executorAccountID.is_empty() {
            os.write_string(2, &self.executorAccountID)?;
        }
        if let ::std::option::Option::Some(ref v) = self.fetchContent {
            match v {
                &PBProxiedFetchContent_oneof_fetchContent::contentFetchAccountInfo(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBProxiedFetchContent {
        PBProxiedFetchContent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBTaskType>>(
                "type",
                |m: &PBProxiedFetchContent| { &m.field_type },
                |m: &mut PBProxiedFetchContent| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "executorAccountID",
                |m: &PBProxiedFetchContent| { &m.executorAccountID },
                |m: &mut PBProxiedFetchContent| { &mut m.executorAccountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PBTaskContentFetchAccountInfo>(
                "contentFetchAccountInfo",
                PBProxiedFetchContent::has_contentFetchAccountInfo,
                PBProxiedFetchContent::get_contentFetchAccountInfo,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBProxiedFetchContent>(
                "PBProxiedFetchContent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBProxiedFetchContent {
        static instance: ::protobuf::rt::LazyV2<PBProxiedFetchContent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBProxiedFetchContent::new)
    }
}

impl ::protobuf::Clear for PBProxiedFetchContent {
    fn clear(&mut self) {
        self.field_type = PBTaskType::PBTaskType_Noop;
        self.executorAccountID.clear();
        self.fetchContent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBProxiedFetchContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBProxiedFetchContent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountStoriesRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountStoriesRequest {
    fn default() -> &'a PBFetchAccountStoriesRequest {
        <PBFetchAccountStoriesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountStoriesRequest {
    pub fn new() -> PBFetchAccountStoriesRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // .PBPagination pagination = 2;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }
}

impl ::protobuf::Message for PBFetchAccountStoriesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountStoriesRequest {
        PBFetchAccountStoriesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchAccountStoriesRequest| { &m.accountID },
                |m: &mut PBFetchAccountStoriesRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchAccountStoriesRequest| { &m.pagination },
                |m: &mut PBFetchAccountStoriesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountStoriesRequest>(
                "PBFetchAccountStoriesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountStoriesRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountStoriesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountStoriesRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountStoriesRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountStoriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountStoriesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchAccountStoriesReply {
    // message fields
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub stories: ::protobuf::RepeatedField<PBMedia>,
    pub hasNext: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchAccountStoriesReply {
    fn default() -> &'a PBFetchAccountStoriesReply {
        <PBFetchAccountStoriesReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchAccountStoriesReply {
    pub fn new() -> PBFetchAccountStoriesReply {
        ::std::default::Default::default()
    }

    // .PBPagination pagination = 1;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // repeated .PBMedia stories = 2;


    pub fn get_stories(&self) -> &[PBMedia] {
        &self.stories
    }
    pub fn clear_stories(&mut self) {
        self.stories.clear();
    }

    // Param is passed by value, moved
    pub fn set_stories(&mut self, v: ::protobuf::RepeatedField<PBMedia>) {
        self.stories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stories(&mut self) -> &mut ::protobuf::RepeatedField<PBMedia> {
        &mut self.stories
    }

    // Take field
    pub fn take_stories(&mut self) -> ::protobuf::RepeatedField<PBMedia> {
        ::std::mem::replace(&mut self.stories, ::protobuf::RepeatedField::new())
    }

    // bool hasNext = 3;


    pub fn get_hasNext(&self) -> bool {
        self.hasNext
    }
    pub fn clear_hasNext(&mut self) {
        self.hasNext = false;
    }

    // Param is passed by value, moved
    pub fn set_hasNext(&mut self, v: bool) {
        self.hasNext = v;
    }
}

impl ::protobuf::Message for PBFetchAccountStoriesReply {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stories)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasNext = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.hasNext != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stories {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.hasNext != false {
            os.write_bool(3, self.hasNext)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchAccountStoriesReply {
        PBFetchAccountStoriesReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchAccountStoriesReply| { &m.pagination },
                |m: &mut PBFetchAccountStoriesReply| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBMedia>>(
                "stories",
                |m: &PBFetchAccountStoriesReply| { &m.stories },
                |m: &mut PBFetchAccountStoriesReply| { &mut m.stories },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasNext",
                |m: &PBFetchAccountStoriesReply| { &m.hasNext },
                |m: &mut PBFetchAccountStoriesReply| { &mut m.hasNext },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchAccountStoriesReply>(
                "PBFetchAccountStoriesReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchAccountStoriesReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchAccountStoriesReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchAccountStoriesReply::new)
    }
}

impl ::protobuf::Clear for PBFetchAccountStoriesReply {
    fn clear(&mut self) {
        self.pagination.clear();
        self.stories.clear();
        self.hasNext = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchAccountStoriesReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchAccountStoriesReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchStoryViewersRequest {
    // message fields
    pub accountID: ::std::string::String,
    pub storyID: ::std::string::String,
    pub field_type: PBStoryViewerType,
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchStoryViewersRequest {
    fn default() -> &'a PBFetchStoryViewersRequest {
        <PBFetchStoryViewersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchStoryViewersRequest {
    pub fn new() -> PBFetchStoryViewersRequest {
        ::std::default::Default::default()
    }

    // string accountID = 1;


    pub fn get_accountID(&self) -> &str {
        &self.accountID
    }
    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: ::std::string::String) {
        self.accountID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut ::std::string::String {
        &mut self.accountID
    }

    // Take field
    pub fn take_accountID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountID, ::std::string::String::new())
    }

    // string storyID = 2;


    pub fn get_storyID(&self) -> &str {
        &self.storyID
    }
    pub fn clear_storyID(&mut self) {
        self.storyID.clear();
    }

    // Param is passed by value, moved
    pub fn set_storyID(&mut self, v: ::std::string::String) {
        self.storyID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storyID(&mut self) -> &mut ::std::string::String {
        &mut self.storyID
    }

    // Take field
    pub fn take_storyID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storyID, ::std::string::String::new())
    }

    // .PBStoryViewerType type = 3;


    pub fn get_field_type(&self) -> PBStoryViewerType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PBStoryViewerType::PBStoryViewerType_All;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PBStoryViewerType) {
        self.field_type = v;
    }

    // .PBPagination pagination = 4;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }
}

impl ::protobuf::Message for PBFetchStoryViewersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storyID)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accountID);
        }
        if !self.storyID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.storyID);
        }
        if self.field_type != PBStoryViewerType::PBStoryViewerType_All {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountID.is_empty() {
            os.write_string(1, &self.accountID)?;
        }
        if !self.storyID.is_empty() {
            os.write_string(2, &self.storyID)?;
        }
        if self.field_type != PBStoryViewerType::PBStoryViewerType_All {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchStoryViewersRequest {
        PBFetchStoryViewersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountID",
                |m: &PBFetchStoryViewersRequest| { &m.accountID },
                |m: &mut PBFetchStoryViewersRequest| { &mut m.accountID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storyID",
                |m: &PBFetchStoryViewersRequest| { &m.storyID },
                |m: &mut PBFetchStoryViewersRequest| { &mut m.storyID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PBStoryViewerType>>(
                "type",
                |m: &PBFetchStoryViewersRequest| { &m.field_type },
                |m: &mut PBFetchStoryViewersRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchStoryViewersRequest| { &m.pagination },
                |m: &mut PBFetchStoryViewersRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchStoryViewersRequest>(
                "PBFetchStoryViewersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchStoryViewersRequest {
        static instance: ::protobuf::rt::LazyV2<PBFetchStoryViewersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchStoryViewersRequest::new)
    }
}

impl ::protobuf::Clear for PBFetchStoryViewersRequest {
    fn clear(&mut self) {
        self.accountID.clear();
        self.storyID.clear();
        self.field_type = PBStoryViewerType::PBStoryViewerType_All;
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchStoryViewersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchStoryViewersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PBFetchStoryViewersReply {
    // message fields
    pub pagination: ::protobuf::SingularPtrField<PBPagination>,
    pub viewers: ::protobuf::RepeatedField<PBAccountListElement>,
    pub hasNext: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PBFetchStoryViewersReply {
    fn default() -> &'a PBFetchStoryViewersReply {
        <PBFetchStoryViewersReply as ::protobuf::Message>::default_instance()
    }
}

impl PBFetchStoryViewersReply {
    pub fn new() -> PBFetchStoryViewersReply {
        ::std::default::Default::default()
    }

    // .PBPagination pagination = 1;


    pub fn get_pagination(&self) -> &PBPagination {
        self.pagination.as_ref().unwrap_or_else(|| <PBPagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: PBPagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut PBPagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> PBPagination {
        self.pagination.take().unwrap_or_else(|| PBPagination::new())
    }

    // repeated .PBAccountListElement viewers = 2;


    pub fn get_viewers(&self) -> &[PBAccountListElement] {
        &self.viewers
    }
    pub fn clear_viewers(&mut self) {
        self.viewers.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: ::protobuf::RepeatedField<PBAccountListElement>) {
        self.viewers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewers(&mut self) -> &mut ::protobuf::RepeatedField<PBAccountListElement> {
        &mut self.viewers
    }

    // Take field
    pub fn take_viewers(&mut self) -> ::protobuf::RepeatedField<PBAccountListElement> {
        ::std::mem::replace(&mut self.viewers, ::protobuf::RepeatedField::new())
    }

    // bool hasNext = 3;


    pub fn get_hasNext(&self) -> bool {
        self.hasNext
    }
    pub fn clear_hasNext(&mut self) {
        self.hasNext = false;
    }

    // Param is passed by value, moved
    pub fn set_hasNext(&mut self, v: bool) {
        self.hasNext = v;
    }
}

impl ::protobuf::Message for PBFetchStoryViewersReply {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.viewers)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasNext = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.viewers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.hasNext != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.viewers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.hasNext != false {
            os.write_bool(3, self.hasNext)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PBFetchStoryViewersReply {
        PBFetchStoryViewersReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBPagination>>(
                "pagination",
                |m: &PBFetchStoryViewersReply| { &m.pagination },
                |m: &mut PBFetchStoryViewersReply| { &mut m.pagination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PBAccountListElement>>(
                "viewers",
                |m: &PBFetchStoryViewersReply| { &m.viewers },
                |m: &mut PBFetchStoryViewersReply| { &mut m.viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasNext",
                |m: &PBFetchStoryViewersReply| { &m.hasNext },
                |m: &mut PBFetchStoryViewersReply| { &mut m.hasNext },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PBFetchStoryViewersReply>(
                "PBFetchStoryViewersReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PBFetchStoryViewersReply {
        static instance: ::protobuf::rt::LazyV2<PBFetchStoryViewersReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PBFetchStoryViewersReply::new)
    }
}

impl ::protobuf::Clear for PBFetchStoryViewersReply {
    fn clear(&mut self) {
        self.pagination.clear();
        self.viewers.clear();
        self.hasNext = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PBFetchStoryViewersReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchStoryViewersReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBAPIType {
    PostNotification = 0,
    Login = 1,
    Logout = 2,
    RefreshConnection = 3,
    ReloadSettings = 4,
    FetchAppParams = 5,
    UpdateOneSignalPlayerID = 6,
    FetchConfig = 7,
    FetchProducts = 10,
    ValidateTransaction = 11,
    FetchVIPProducts = 12,
    BuyVIPProduct = 13,
    FetchUserPurchaseHistory = 14,
    VerifySubscription = 15,
    VerifySubscriptionAndroid = 16,
    FetchGifts = 20,
    DoGift = 21,
    VIPPitch = 22,
    PostOneSignalNotification = 29,
    FetchUserSettings = 30,
    PostUserSettings = 31,
    DispatchTask = 100,
    PostTask = 101,
    SpawnTask = 102,
    PostTaskCapability = 105,
    FetchTaskProgress = 108,
    FetchCountData = 110,
    FetchAccountListData = 111,
    FetchMostEngagingMedias = 112,
    FetchSpotlightData = 113,
    FetchHistoryCounts = 114,
    FetchAccountRelations = 115,
    FetchProfileViewers = 116,
    FetchEngagedMedias = 117,
    FetchAccountStories = 118,
    FetchStoryViewers = 119,
    PostTextNotification = 150,
    PostChangeNotifcation = 151,
    PostCountDataNotification = 152,
    PostPendingBatchTaskTargetDelta = 153,
    PostBatchTaskCompleteNotification = 154,
    TransferExistingServerBatchTasksToClient = 155,
    ValidateSubscription = 200,
    IsPremium = 300,
    ReportPage = 400,
    FetchBatchTask = 500,
    UpdateBatchTask = 501,
    FetchPendingBatchTaskTargets = 510,
    ProxiedFetchContent = 600,
}

impl ::protobuf::ProtobufEnum for PBAPIType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBAPIType> {
        match value {
            0 => ::std::option::Option::Some(PBAPIType::PostNotification),
            1 => ::std::option::Option::Some(PBAPIType::Login),
            2 => ::std::option::Option::Some(PBAPIType::Logout),
            3 => ::std::option::Option::Some(PBAPIType::RefreshConnection),
            4 => ::std::option::Option::Some(PBAPIType::ReloadSettings),
            5 => ::std::option::Option::Some(PBAPIType::FetchAppParams),
            6 => ::std::option::Option::Some(PBAPIType::UpdateOneSignalPlayerID),
            7 => ::std::option::Option::Some(PBAPIType::FetchConfig),
            10 => ::std::option::Option::Some(PBAPIType::FetchProducts),
            11 => ::std::option::Option::Some(PBAPIType::ValidateTransaction),
            12 => ::std::option::Option::Some(PBAPIType::FetchVIPProducts),
            13 => ::std::option::Option::Some(PBAPIType::BuyVIPProduct),
            14 => ::std::option::Option::Some(PBAPIType::FetchUserPurchaseHistory),
            15 => ::std::option::Option::Some(PBAPIType::VerifySubscription),
            16 => ::std::option::Option::Some(PBAPIType::VerifySubscriptionAndroid),
            20 => ::std::option::Option::Some(PBAPIType::FetchGifts),
            21 => ::std::option::Option::Some(PBAPIType::DoGift),
            22 => ::std::option::Option::Some(PBAPIType::VIPPitch),
            29 => ::std::option::Option::Some(PBAPIType::PostOneSignalNotification),
            30 => ::std::option::Option::Some(PBAPIType::FetchUserSettings),
            31 => ::std::option::Option::Some(PBAPIType::PostUserSettings),
            100 => ::std::option::Option::Some(PBAPIType::DispatchTask),
            101 => ::std::option::Option::Some(PBAPIType::PostTask),
            102 => ::std::option::Option::Some(PBAPIType::SpawnTask),
            105 => ::std::option::Option::Some(PBAPIType::PostTaskCapability),
            108 => ::std::option::Option::Some(PBAPIType::FetchTaskProgress),
            110 => ::std::option::Option::Some(PBAPIType::FetchCountData),
            111 => ::std::option::Option::Some(PBAPIType::FetchAccountListData),
            112 => ::std::option::Option::Some(PBAPIType::FetchMostEngagingMedias),
            113 => ::std::option::Option::Some(PBAPIType::FetchSpotlightData),
            114 => ::std::option::Option::Some(PBAPIType::FetchHistoryCounts),
            115 => ::std::option::Option::Some(PBAPIType::FetchAccountRelations),
            116 => ::std::option::Option::Some(PBAPIType::FetchProfileViewers),
            117 => ::std::option::Option::Some(PBAPIType::FetchEngagedMedias),
            118 => ::std::option::Option::Some(PBAPIType::FetchAccountStories),
            119 => ::std::option::Option::Some(PBAPIType::FetchStoryViewers),
            150 => ::std::option::Option::Some(PBAPIType::PostTextNotification),
            151 => ::std::option::Option::Some(PBAPIType::PostChangeNotifcation),
            152 => ::std::option::Option::Some(PBAPIType::PostCountDataNotification),
            153 => ::std::option::Option::Some(PBAPIType::PostPendingBatchTaskTargetDelta),
            154 => ::std::option::Option::Some(PBAPIType::PostBatchTaskCompleteNotification),
            155 => ::std::option::Option::Some(PBAPIType::TransferExistingServerBatchTasksToClient),
            200 => ::std::option::Option::Some(PBAPIType::ValidateSubscription),
            300 => ::std::option::Option::Some(PBAPIType::IsPremium),
            400 => ::std::option::Option::Some(PBAPIType::ReportPage),
            500 => ::std::option::Option::Some(PBAPIType::FetchBatchTask),
            501 => ::std::option::Option::Some(PBAPIType::UpdateBatchTask),
            510 => ::std::option::Option::Some(PBAPIType::FetchPendingBatchTaskTargets),
            600 => ::std::option::Option::Some(PBAPIType::ProxiedFetchContent),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBAPIType] = &[
            PBAPIType::PostNotification,
            PBAPIType::Login,
            PBAPIType::Logout,
            PBAPIType::RefreshConnection,
            PBAPIType::ReloadSettings,
            PBAPIType::FetchAppParams,
            PBAPIType::UpdateOneSignalPlayerID,
            PBAPIType::FetchConfig,
            PBAPIType::FetchProducts,
            PBAPIType::ValidateTransaction,
            PBAPIType::FetchVIPProducts,
            PBAPIType::BuyVIPProduct,
            PBAPIType::FetchUserPurchaseHistory,
            PBAPIType::VerifySubscription,
            PBAPIType::VerifySubscriptionAndroid,
            PBAPIType::FetchGifts,
            PBAPIType::DoGift,
            PBAPIType::VIPPitch,
            PBAPIType::PostOneSignalNotification,
            PBAPIType::FetchUserSettings,
            PBAPIType::PostUserSettings,
            PBAPIType::DispatchTask,
            PBAPIType::PostTask,
            PBAPIType::SpawnTask,
            PBAPIType::PostTaskCapability,
            PBAPIType::FetchTaskProgress,
            PBAPIType::FetchCountData,
            PBAPIType::FetchAccountListData,
            PBAPIType::FetchMostEngagingMedias,
            PBAPIType::FetchSpotlightData,
            PBAPIType::FetchHistoryCounts,
            PBAPIType::FetchAccountRelations,
            PBAPIType::FetchProfileViewers,
            PBAPIType::FetchEngagedMedias,
            PBAPIType::FetchAccountStories,
            PBAPIType::FetchStoryViewers,
            PBAPIType::PostTextNotification,
            PBAPIType::PostChangeNotifcation,
            PBAPIType::PostCountDataNotification,
            PBAPIType::PostPendingBatchTaskTargetDelta,
            PBAPIType::PostBatchTaskCompleteNotification,
            PBAPIType::TransferExistingServerBatchTasksToClient,
            PBAPIType::ValidateSubscription,
            PBAPIType::IsPremium,
            PBAPIType::ReportPage,
            PBAPIType::FetchBatchTask,
            PBAPIType::UpdateBatchTask,
            PBAPIType::FetchPendingBatchTaskTargets,
            PBAPIType::ProxiedFetchContent,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBAPIType>("PBAPIType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBAPIType {
}

impl ::std::default::Default for PBAPIType {
    fn default() -> Self {
        PBAPIType::PostNotification
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAPIType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBErrorCode {
    Success = 0,
    UnknownError = 1,
    ParamError = 2,
    AuthError = 3,
    NotExist = 4,
    Disabled = 5,
    ConnectionClosed = 6,
    NotImplemented = 7,
    TooManyRequests = 8,
    Unavailable = 9,
    Redirected = 10,
}

impl ::protobuf::ProtobufEnum for PBErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBErrorCode> {
        match value {
            0 => ::std::option::Option::Some(PBErrorCode::Success),
            1 => ::std::option::Option::Some(PBErrorCode::UnknownError),
            2 => ::std::option::Option::Some(PBErrorCode::ParamError),
            3 => ::std::option::Option::Some(PBErrorCode::AuthError),
            4 => ::std::option::Option::Some(PBErrorCode::NotExist),
            5 => ::std::option::Option::Some(PBErrorCode::Disabled),
            6 => ::std::option::Option::Some(PBErrorCode::ConnectionClosed),
            7 => ::std::option::Option::Some(PBErrorCode::NotImplemented),
            8 => ::std::option::Option::Some(PBErrorCode::TooManyRequests),
            9 => ::std::option::Option::Some(PBErrorCode::Unavailable),
            10 => ::std::option::Option::Some(PBErrorCode::Redirected),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBErrorCode] = &[
            PBErrorCode::Success,
            PBErrorCode::UnknownError,
            PBErrorCode::ParamError,
            PBErrorCode::AuthError,
            PBErrorCode::NotExist,
            PBErrorCode::Disabled,
            PBErrorCode::ConnectionClosed,
            PBErrorCode::NotImplemented,
            PBErrorCode::TooManyRequests,
            PBErrorCode::Unavailable,
            PBErrorCode::Redirected,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBErrorCode>("PBErrorCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBErrorCode {
}

impl ::std::default::Default for PBErrorCode {
    fn default() -> Self {
        PBErrorCode::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for PBErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBSocialPlatformType {
    Instagram = 0,
}

impl ::protobuf::ProtobufEnum for PBSocialPlatformType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBSocialPlatformType> {
        match value {
            0 => ::std::option::Option::Some(PBSocialPlatformType::Instagram),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBSocialPlatformType] = &[
            PBSocialPlatformType::Instagram,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBSocialPlatformType>("PBSocialPlatformType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBSocialPlatformType {
}

impl ::std::default::Default for PBSocialPlatformType {
    fn default() -> Self {
        PBSocialPlatformType::Instagram
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSocialPlatformType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBAppType {
    SanTi = 0,
    FollowersPlus = 1,
    IGtrack = 2,
}

impl ::protobuf::ProtobufEnum for PBAppType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBAppType> {
        match value {
            0 => ::std::option::Option::Some(PBAppType::SanTi),
            1 => ::std::option::Option::Some(PBAppType::FollowersPlus),
            2 => ::std::option::Option::Some(PBAppType::IGtrack),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBAppType] = &[
            PBAppType::SanTi,
            PBAppType::FollowersPlus,
            PBAppType::IGtrack,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBAppType>("PBAppType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBAppType {
}

impl ::std::default::Default for PBAppType {
    fn default() -> Self {
        PBAppType::SanTi
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAppType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBVerifySubscriptionResult {
    notPurchased = 0,
    subscribed = 1,
    expired = 2,
    receiptError = 3,
}

impl ::protobuf::ProtobufEnum for PBVerifySubscriptionResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBVerifySubscriptionResult> {
        match value {
            0 => ::std::option::Option::Some(PBVerifySubscriptionResult::notPurchased),
            1 => ::std::option::Option::Some(PBVerifySubscriptionResult::subscribed),
            2 => ::std::option::Option::Some(PBVerifySubscriptionResult::expired),
            3 => ::std::option::Option::Some(PBVerifySubscriptionResult::receiptError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBVerifySubscriptionResult] = &[
            PBVerifySubscriptionResult::notPurchased,
            PBVerifySubscriptionResult::subscribed,
            PBVerifySubscriptionResult::expired,
            PBVerifySubscriptionResult::receiptError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBVerifySubscriptionResult>("PBVerifySubscriptionResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBVerifySubscriptionResult {
}

impl ::std::default::Default for PBVerifySubscriptionResult {
    fn default() -> Self {
        PBVerifySubscriptionResult::notPurchased
    }
}

impl ::protobuf::reflect::ProtobufValue for PBVerifySubscriptionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBLoginType {
    PBLoginType_App = 0,
    PBLoginType_Bot = 1,
    PBLoginType_Bridge = 2,
    PBLoginType_BatchTask = 3,
    PBLoginType_ProxiedFetch = 4,
}

impl ::protobuf::ProtobufEnum for PBLoginType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBLoginType> {
        match value {
            0 => ::std::option::Option::Some(PBLoginType::PBLoginType_App),
            1 => ::std::option::Option::Some(PBLoginType::PBLoginType_Bot),
            2 => ::std::option::Option::Some(PBLoginType::PBLoginType_Bridge),
            3 => ::std::option::Option::Some(PBLoginType::PBLoginType_BatchTask),
            4 => ::std::option::Option::Some(PBLoginType::PBLoginType_ProxiedFetch),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBLoginType] = &[
            PBLoginType::PBLoginType_App,
            PBLoginType::PBLoginType_Bot,
            PBLoginType::PBLoginType_Bridge,
            PBLoginType::PBLoginType_BatchTask,
            PBLoginType::PBLoginType_ProxiedFetch,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBLoginType>("PBLoginType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBLoginType {
}

impl ::std::default::Default for PBLoginType {
    fn default() -> Self {
        PBLoginType::PBLoginType_App
    }
}

impl ::protobuf::reflect::ProtobufValue for PBLoginType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BillingCycle {
    weekly = 0,
    oneMonth = 1,
    twoMonth = 2,
    threeMonth = 3,
    halfYearly = 4,
    yearly = 5,
    lifetime = 6,
}

impl ::protobuf::ProtobufEnum for BillingCycle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BillingCycle> {
        match value {
            0 => ::std::option::Option::Some(BillingCycle::weekly),
            1 => ::std::option::Option::Some(BillingCycle::oneMonth),
            2 => ::std::option::Option::Some(BillingCycle::twoMonth),
            3 => ::std::option::Option::Some(BillingCycle::threeMonth),
            4 => ::std::option::Option::Some(BillingCycle::halfYearly),
            5 => ::std::option::Option::Some(BillingCycle::yearly),
            6 => ::std::option::Option::Some(BillingCycle::lifetime),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BillingCycle] = &[
            BillingCycle::weekly,
            BillingCycle::oneMonth,
            BillingCycle::twoMonth,
            BillingCycle::threeMonth,
            BillingCycle::halfYearly,
            BillingCycle::yearly,
            BillingCycle::lifetime,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BillingCycle>("BillingCycle", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BillingCycle {
}

impl ::std::default::Default for BillingCycle {
    fn default() -> Self {
        BillingCycle::weekly
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingCycle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IntroductoryOfferPaymentOption {
    freeTrial = 0,
    payAsYouGo = 1,
    payUpFront = 2,
}

impl ::protobuf::ProtobufEnum for IntroductoryOfferPaymentOption {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IntroductoryOfferPaymentOption> {
        match value {
            0 => ::std::option::Option::Some(IntroductoryOfferPaymentOption::freeTrial),
            1 => ::std::option::Option::Some(IntroductoryOfferPaymentOption::payAsYouGo),
            2 => ::std::option::Option::Some(IntroductoryOfferPaymentOption::payUpFront),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IntroductoryOfferPaymentOption] = &[
            IntroductoryOfferPaymentOption::freeTrial,
            IntroductoryOfferPaymentOption::payAsYouGo,
            IntroductoryOfferPaymentOption::payUpFront,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IntroductoryOfferPaymentOption>("IntroductoryOfferPaymentOption", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IntroductoryOfferPaymentOption {
}

impl ::std::default::Default for IntroductoryOfferPaymentOption {
    fn default() -> Self {
        IntroductoryOfferPaymentOption::freeTrial
    }
}

impl ::protobuf::reflect::ProtobufValue for IntroductoryOfferPaymentOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBAccountLoginType {
    InstagramLogin = 0,
    FacebookLogin = 1,
}

impl ::protobuf::ProtobufEnum for PBAccountLoginType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBAccountLoginType> {
        match value {
            0 => ::std::option::Option::Some(PBAccountLoginType::InstagramLogin),
            1 => ::std::option::Option::Some(PBAccountLoginType::FacebookLogin),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBAccountLoginType] = &[
            PBAccountLoginType::InstagramLogin,
            PBAccountLoginType::FacebookLogin,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBAccountLoginType>("PBAccountLoginType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBAccountLoginType {
}

impl ::std::default::Default for PBAccountLoginType {
    fn default() -> Self {
        PBAccountLoginType::InstagramLogin
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAccountLoginType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBMediaType {
    PBMediaType_None = 0,
    PBMediaType_Photo = 1,
    PBMediaType_Video = 2,
    PBMediaType_Carousel = 8,
}

impl ::protobuf::ProtobufEnum for PBMediaType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBMediaType> {
        match value {
            0 => ::std::option::Option::Some(PBMediaType::PBMediaType_None),
            1 => ::std::option::Option::Some(PBMediaType::PBMediaType_Photo),
            2 => ::std::option::Option::Some(PBMediaType::PBMediaType_Video),
            8 => ::std::option::Option::Some(PBMediaType::PBMediaType_Carousel),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBMediaType] = &[
            PBMediaType::PBMediaType_None,
            PBMediaType::PBMediaType_Photo,
            PBMediaType::PBMediaType_Video,
            PBMediaType::PBMediaType_Carousel,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBMediaType>("PBMediaType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBMediaType {
}

impl ::std::default::Default for PBMediaType {
    fn default() -> Self {
        PBMediaType::PBMediaType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMediaType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBTaskType {
    PBTaskType_Noop = 0,
    PBTaskType_FetchAccountInfo = 1,
    PBTaskType_FetchMediaLikes = 2,
    PBTaskType_FetchMediaComments = 3,
    PBTaskType_FetchAccountFollowings = 4,
    PBTaskType_FetchAccountFollowers = 5,
    PBTaskType_FetchAccountMedias = 6,
    PBTaskType_FetchAccountLikedMedias = 7,
    PBTaskType_FetchAccountBlockings = 8,
    PBTaskType_FetchAccountRelation = 9,
    PBTaskType_FetchAccountActivities = 10,
    PBTaskType_FetchAccountStories = 11,
    PBTaskType_FetchMediaInfo = 12,
    PBTaskType_RefreshAccountInfluentialFollowers = 100,
}

impl ::protobuf::ProtobufEnum for PBTaskType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBTaskType> {
        match value {
            0 => ::std::option::Option::Some(PBTaskType::PBTaskType_Noop),
            1 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountInfo),
            2 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchMediaLikes),
            3 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchMediaComments),
            4 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountFollowings),
            5 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountFollowers),
            6 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountMedias),
            7 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountLikedMedias),
            8 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountBlockings),
            9 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountRelation),
            10 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountActivities),
            11 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchAccountStories),
            12 => ::std::option::Option::Some(PBTaskType::PBTaskType_FetchMediaInfo),
            100 => ::std::option::Option::Some(PBTaskType::PBTaskType_RefreshAccountInfluentialFollowers),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBTaskType] = &[
            PBTaskType::PBTaskType_Noop,
            PBTaskType::PBTaskType_FetchAccountInfo,
            PBTaskType::PBTaskType_FetchMediaLikes,
            PBTaskType::PBTaskType_FetchMediaComments,
            PBTaskType::PBTaskType_FetchAccountFollowings,
            PBTaskType::PBTaskType_FetchAccountFollowers,
            PBTaskType::PBTaskType_FetchAccountMedias,
            PBTaskType::PBTaskType_FetchAccountLikedMedias,
            PBTaskType::PBTaskType_FetchAccountBlockings,
            PBTaskType::PBTaskType_FetchAccountRelation,
            PBTaskType::PBTaskType_FetchAccountActivities,
            PBTaskType::PBTaskType_FetchAccountStories,
            PBTaskType::PBTaskType_FetchMediaInfo,
            PBTaskType::PBTaskType_RefreshAccountInfluentialFollowers,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBTaskType>("PBTaskType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBTaskType {
}

impl ::std::default::Default for PBTaskType {
    fn default() -> Self {
        PBTaskType::PBTaskType_Noop
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBTaskState {
    PBTaskState_Pending = 0,
    PBTaskState_Success = 1,
    PBTaskState_Failure = 2,
}

impl ::protobuf::ProtobufEnum for PBTaskState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBTaskState> {
        match value {
            0 => ::std::option::Option::Some(PBTaskState::PBTaskState_Pending),
            1 => ::std::option::Option::Some(PBTaskState::PBTaskState_Success),
            2 => ::std::option::Option::Some(PBTaskState::PBTaskState_Failure),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBTaskState] = &[
            PBTaskState::PBTaskState_Pending,
            PBTaskState::PBTaskState_Success,
            PBTaskState::PBTaskState_Failure,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBTaskState>("PBTaskState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBTaskState {
}

impl ::std::default::Default for PBTaskState {
    fn default() -> Self {
        PBTaskState::PBTaskState_Pending
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBTaskFailureAction {
    PBTaskFailureAction_DispatchToOther = 0,
    PBTaskFailureAction_DispatchToSelf = 1,
    PBTaskFailureAction_DeleteTask = 2,
}

impl ::protobuf::ProtobufEnum for PBTaskFailureAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBTaskFailureAction> {
        match value {
            0 => ::std::option::Option::Some(PBTaskFailureAction::PBTaskFailureAction_DispatchToOther),
            1 => ::std::option::Option::Some(PBTaskFailureAction::PBTaskFailureAction_DispatchToSelf),
            2 => ::std::option::Option::Some(PBTaskFailureAction::PBTaskFailureAction_DeleteTask),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBTaskFailureAction] = &[
            PBTaskFailureAction::PBTaskFailureAction_DispatchToOther,
            PBTaskFailureAction::PBTaskFailureAction_DispatchToSelf,
            PBTaskFailureAction::PBTaskFailureAction_DeleteTask,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBTaskFailureAction>("PBTaskFailureAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBTaskFailureAction {
}

impl ::std::default::Default for PBTaskFailureAction {
    fn default() -> Self {
        PBTaskFailureAction::PBTaskFailureAction_DispatchToOther
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskFailureAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBActivityType {
    PBActivityType_Null = 0,
    PBActivityType_Like = 1,
    PBActivityType_Comment = 2,
    PBActivityType_Follow = 3,
}

impl ::protobuf::ProtobufEnum for PBActivityType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBActivityType> {
        match value {
            0 => ::std::option::Option::Some(PBActivityType::PBActivityType_Null),
            1 => ::std::option::Option::Some(PBActivityType::PBActivityType_Like),
            2 => ::std::option::Option::Some(PBActivityType::PBActivityType_Comment),
            3 => ::std::option::Option::Some(PBActivityType::PBActivityType_Follow),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBActivityType] = &[
            PBActivityType::PBActivityType_Null,
            PBActivityType::PBActivityType_Like,
            PBActivityType::PBActivityType_Comment,
            PBActivityType::PBActivityType_Follow,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBActivityType>("PBActivityType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBActivityType {
}

impl ::std::default::Default for PBActivityType {
    fn default() -> Self {
        PBActivityType::PBActivityType_Null
    }
}

impl ::protobuf::reflect::ProtobufValue for PBActivityType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBSpawnTaskStatus {
    PBSpawnTaskStatus_OK = 0,
    PBSpawnTaskStatus_InProgress = 1,
    PBSpawnTaskStatus_Error = 2,
}

impl ::protobuf::ProtobufEnum for PBSpawnTaskStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBSpawnTaskStatus> {
        match value {
            0 => ::std::option::Option::Some(PBSpawnTaskStatus::PBSpawnTaskStatus_OK),
            1 => ::std::option::Option::Some(PBSpawnTaskStatus::PBSpawnTaskStatus_InProgress),
            2 => ::std::option::Option::Some(PBSpawnTaskStatus::PBSpawnTaskStatus_Error),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBSpawnTaskStatus] = &[
            PBSpawnTaskStatus::PBSpawnTaskStatus_OK,
            PBSpawnTaskStatus::PBSpawnTaskStatus_InProgress,
            PBSpawnTaskStatus::PBSpawnTaskStatus_Error,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBSpawnTaskStatus>("PBSpawnTaskStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBSpawnTaskStatus {
}

impl ::std::default::Default for PBSpawnTaskStatus {
    fn default() -> Self {
        PBSpawnTaskStatus::PBSpawnTaskStatus_OK
    }
}

impl ::protobuf::reflect::ProtobufValue for PBSpawnTaskStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBTaskProgressType {
    PBTaskProgressType_None = 0,
    PBTaskProgressType_FollowingList = 1,
    PBTaskProgressType_FollowingInfo = 2,
    PBTaskProgressType_FollowerList = 3,
    PBTaskProgressType_FollowerInfo = 4,
    PBTaskProgressType_MediaList = 5,
    PBTaskProgressType_MediaLike = 6,
    PBTaskProgressType_MediaComment = 7,
    PBTaskProgressType_LikedMedia = 8,
    PBTaskProgressType_BlockingList = 9,
}

impl ::protobuf::ProtobufEnum for PBTaskProgressType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBTaskProgressType> {
        match value {
            0 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_None),
            1 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_FollowingList),
            2 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_FollowingInfo),
            3 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_FollowerList),
            4 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_FollowerInfo),
            5 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_MediaList),
            6 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_MediaLike),
            7 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_MediaComment),
            8 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_LikedMedia),
            9 => ::std::option::Option::Some(PBTaskProgressType::PBTaskProgressType_BlockingList),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBTaskProgressType] = &[
            PBTaskProgressType::PBTaskProgressType_None,
            PBTaskProgressType::PBTaskProgressType_FollowingList,
            PBTaskProgressType::PBTaskProgressType_FollowingInfo,
            PBTaskProgressType::PBTaskProgressType_FollowerList,
            PBTaskProgressType::PBTaskProgressType_FollowerInfo,
            PBTaskProgressType::PBTaskProgressType_MediaList,
            PBTaskProgressType::PBTaskProgressType_MediaLike,
            PBTaskProgressType::PBTaskProgressType_MediaComment,
            PBTaskProgressType::PBTaskProgressType_LikedMedia,
            PBTaskProgressType::PBTaskProgressType_BlockingList,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBTaskProgressType>("PBTaskProgressType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBTaskProgressType {
}

impl ::std::default::Default for PBTaskProgressType {
    fn default() -> Self {
        PBTaskProgressType::PBTaskProgressType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBTaskProgressType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBCountDataType {
    PBCountDataType_None = 0,
    PBCountDataType_TotalLikes = 1,
    PBCountDataType_MutualFollowing = 2,
    PBCountDataType_NotFollowingMeBack = 3,
    PBCountDataType_ImNotFollowingBack = 4,
    PBCountDataType_TotalComments = 5,
    PBCountDataType_TotalPhotos = 6,
    PBCountDataType_TotalVideos = 7,
    PBCountDataType_TotalCarousels = 8,
    PBCountDataType_TotalPhotoLikes = 9,
    PBCountDataType_TotalVideoLikes = 10,
    PBCountDataType_TotalCarouselLikes = 11,
    PBCountDataType_TotalPhotoComments = 12,
    PBCountDataType_TotalVideoComments = 13,
    PBCountDataType_TotalCarouselComments = 14,
    PBCountDataType_TotalMedias = 15,
    PBCountDataType_TotalUnlikesAndUnComments = 16,
    PBCountDataType_TotalBlockings = 17,
    PBCountDataType_MediaMaxLikes = 18,
    PBCountDataType_MediaMaxComments = 19,
    PBCountDataType_CommentedAccounts = 20,
    PBCountDataType_UnfollowedFromMutualFollowings = 21,
    PBCountDataType_CurrentLostFollowers = 22,
    PBCountDataType_StoryViewers = 23,
    PBCountDataType_TrackedStories = 24,
    PBCountDataType_ProfileViewers = 25,
}

impl ::protobuf::ProtobufEnum for PBCountDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBCountDataType> {
        match value {
            0 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_None),
            1 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalLikes),
            2 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_MutualFollowing),
            3 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_NotFollowingMeBack),
            4 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_ImNotFollowingBack),
            5 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalComments),
            6 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalPhotos),
            7 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalVideos),
            8 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalCarousels),
            9 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalPhotoLikes),
            10 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalVideoLikes),
            11 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalCarouselLikes),
            12 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalPhotoComments),
            13 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalVideoComments),
            14 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalCarouselComments),
            15 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalMedias),
            16 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalUnlikesAndUnComments),
            17 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TotalBlockings),
            18 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_MediaMaxLikes),
            19 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_MediaMaxComments),
            20 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_CommentedAccounts),
            21 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_UnfollowedFromMutualFollowings),
            22 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_CurrentLostFollowers),
            23 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_StoryViewers),
            24 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_TrackedStories),
            25 => ::std::option::Option::Some(PBCountDataType::PBCountDataType_ProfileViewers),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBCountDataType] = &[
            PBCountDataType::PBCountDataType_None,
            PBCountDataType::PBCountDataType_TotalLikes,
            PBCountDataType::PBCountDataType_MutualFollowing,
            PBCountDataType::PBCountDataType_NotFollowingMeBack,
            PBCountDataType::PBCountDataType_ImNotFollowingBack,
            PBCountDataType::PBCountDataType_TotalComments,
            PBCountDataType::PBCountDataType_TotalPhotos,
            PBCountDataType::PBCountDataType_TotalVideos,
            PBCountDataType::PBCountDataType_TotalCarousels,
            PBCountDataType::PBCountDataType_TotalPhotoLikes,
            PBCountDataType::PBCountDataType_TotalVideoLikes,
            PBCountDataType::PBCountDataType_TotalCarouselLikes,
            PBCountDataType::PBCountDataType_TotalPhotoComments,
            PBCountDataType::PBCountDataType_TotalVideoComments,
            PBCountDataType::PBCountDataType_TotalCarouselComments,
            PBCountDataType::PBCountDataType_TotalMedias,
            PBCountDataType::PBCountDataType_TotalUnlikesAndUnComments,
            PBCountDataType::PBCountDataType_TotalBlockings,
            PBCountDataType::PBCountDataType_MediaMaxLikes,
            PBCountDataType::PBCountDataType_MediaMaxComments,
            PBCountDataType::PBCountDataType_CommentedAccounts,
            PBCountDataType::PBCountDataType_UnfollowedFromMutualFollowings,
            PBCountDataType::PBCountDataType_CurrentLostFollowers,
            PBCountDataType::PBCountDataType_StoryViewers,
            PBCountDataType::PBCountDataType_TrackedStories,
            PBCountDataType::PBCountDataType_ProfileViewers,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBCountDataType>("PBCountDataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBCountDataType {
}

impl ::std::default::Default for PBCountDataType {
    fn default() -> Self {
        PBCountDataType::PBCountDataType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBCountDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBRelationship {
    PBRelationship_Null = 0,
    PBRelationship_Follow = 1,
    PBRelationship_Block = 2,
    PBRelationship_Requested = 3,
    PBRelationship_NoRelation = 4,
}

impl ::protobuf::ProtobufEnum for PBRelationship {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBRelationship> {
        match value {
            0 => ::std::option::Option::Some(PBRelationship::PBRelationship_Null),
            1 => ::std::option::Option::Some(PBRelationship::PBRelationship_Follow),
            2 => ::std::option::Option::Some(PBRelationship::PBRelationship_Block),
            3 => ::std::option::Option::Some(PBRelationship::PBRelationship_Requested),
            4 => ::std::option::Option::Some(PBRelationship::PBRelationship_NoRelation),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBRelationship] = &[
            PBRelationship::PBRelationship_Null,
            PBRelationship::PBRelationship_Follow,
            PBRelationship::PBRelationship_Block,
            PBRelationship::PBRelationship_Requested,
            PBRelationship::PBRelationship_NoRelation,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBRelationship>("PBRelationship", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBRelationship {
}

impl ::std::default::Default for PBRelationship {
    fn default() -> Self {
        PBRelationship::PBRelationship_Null
    }
}

impl ::protobuf::reflect::ProtobufValue for PBRelationship {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBRelationshipToMedia {
    PBRelationshipToMedia_Null = 0,
    PBRelationshipToMedia_Like = 1,
    PBRelationshipToMedia_Comment = 2,
}

impl ::protobuf::ProtobufEnum for PBRelationshipToMedia {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBRelationshipToMedia> {
        match value {
            0 => ::std::option::Option::Some(PBRelationshipToMedia::PBRelationshipToMedia_Null),
            1 => ::std::option::Option::Some(PBRelationshipToMedia::PBRelationshipToMedia_Like),
            2 => ::std::option::Option::Some(PBRelationshipToMedia::PBRelationshipToMedia_Comment),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBRelationshipToMedia] = &[
            PBRelationshipToMedia::PBRelationshipToMedia_Null,
            PBRelationshipToMedia::PBRelationshipToMedia_Like,
            PBRelationshipToMedia::PBRelationshipToMedia_Comment,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBRelationshipToMedia>("PBRelationshipToMedia", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBRelationshipToMedia {
}

impl ::std::default::Default for PBRelationshipToMedia {
    fn default() -> Self {
        PBRelationshipToMedia::PBRelationshipToMedia_Null
    }
}

impl ::protobuf::reflect::ProtobufValue for PBRelationshipToMedia {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBAccountListDataType {
    PBAccountListDataType_None = 0,
    PBAccountListDataType_MostLoyal = 1,
    PBAccountListDataType_MostFriendly = 2,
    PBAccountListDataType_MostTalkative = 3,
    PBAccountListDataType_MutualFollowing = 4,
    PBAccountListDataType_NoLikeGiven = 5,
    PBAccountListDataType_NoCommentLeft = 6,
    PBAccountListDataType_NoCommentOrLikes = 7,
    PBAccountListDataType_BlockingMe = 8,
    PBAccountListDataType_LikedNotFollowing = 9,
    PBAccountListDataType_NotFollowingMeBack = 10,
    PBAccountListDataType_ImNotFollowingBack = 11,
    PBAccountListDataType_SecretAdmirers = 12,
    PBAccountListDataType_InfluentialFollowers = 13,
    PBAccountListDataType_GainedFollowers = 14,
    PBAccountListDataType_LostFollowers = 15,
    PBAccountListDataType_ProfileViewers = 16,
    PBAccountListDataType_FavouriteUsers = 17,
    PBAccountListDataType_EarliestFollowers = 18,
    PBAccountListDataType_LatestFollowers = 19,
    PBAccountListDataType_Unlike = 20,
    PBAccountListDataType_Uncomment = 21,
    PBAccountListDataType_MyUnFollowed = 22,
    PBAccountListDataType_WhoAdmiresMe = 23,
    PBAccountListDataType_UnfollowedFromMutualFollowings = 24,
    PBAccountListDataType_StoryViewersAll = 25,
    PBAccountListDataType_AllLostFollowers = 26,
    PBAccountListDataType_LostFollowersReplicant = 27,
    PBAccountListDataType_StoryViewersNotFollowing = 28,
    PBAccountListDataType_StoryViewersIDontFollow = 29,
    PBAccountListDataType_TrackedStories = 30,
}

impl ::protobuf::ProtobufEnum for PBAccountListDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBAccountListDataType> {
        match value {
            0 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_None),
            1 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_MostLoyal),
            2 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_MostFriendly),
            3 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_MostTalkative),
            4 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_MutualFollowing),
            5 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_NoLikeGiven),
            6 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_NoCommentLeft),
            7 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_NoCommentOrLikes),
            8 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_BlockingMe),
            9 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_LikedNotFollowing),
            10 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_NotFollowingMeBack),
            11 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_ImNotFollowingBack),
            12 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_SecretAdmirers),
            13 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_InfluentialFollowers),
            14 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_GainedFollowers),
            15 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_LostFollowers),
            16 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_ProfileViewers),
            17 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_FavouriteUsers),
            18 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_EarliestFollowers),
            19 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_LatestFollowers),
            20 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_Unlike),
            21 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_Uncomment),
            22 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_MyUnFollowed),
            23 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_WhoAdmiresMe),
            24 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_UnfollowedFromMutualFollowings),
            25 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_StoryViewersAll),
            26 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_AllLostFollowers),
            27 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_LostFollowersReplicant),
            28 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_StoryViewersNotFollowing),
            29 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_StoryViewersIDontFollow),
            30 => ::std::option::Option::Some(PBAccountListDataType::PBAccountListDataType_TrackedStories),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBAccountListDataType] = &[
            PBAccountListDataType::PBAccountListDataType_None,
            PBAccountListDataType::PBAccountListDataType_MostLoyal,
            PBAccountListDataType::PBAccountListDataType_MostFriendly,
            PBAccountListDataType::PBAccountListDataType_MostTalkative,
            PBAccountListDataType::PBAccountListDataType_MutualFollowing,
            PBAccountListDataType::PBAccountListDataType_NoLikeGiven,
            PBAccountListDataType::PBAccountListDataType_NoCommentLeft,
            PBAccountListDataType::PBAccountListDataType_NoCommentOrLikes,
            PBAccountListDataType::PBAccountListDataType_BlockingMe,
            PBAccountListDataType::PBAccountListDataType_LikedNotFollowing,
            PBAccountListDataType::PBAccountListDataType_NotFollowingMeBack,
            PBAccountListDataType::PBAccountListDataType_ImNotFollowingBack,
            PBAccountListDataType::PBAccountListDataType_SecretAdmirers,
            PBAccountListDataType::PBAccountListDataType_InfluentialFollowers,
            PBAccountListDataType::PBAccountListDataType_GainedFollowers,
            PBAccountListDataType::PBAccountListDataType_LostFollowers,
            PBAccountListDataType::PBAccountListDataType_ProfileViewers,
            PBAccountListDataType::PBAccountListDataType_FavouriteUsers,
            PBAccountListDataType::PBAccountListDataType_EarliestFollowers,
            PBAccountListDataType::PBAccountListDataType_LatestFollowers,
            PBAccountListDataType::PBAccountListDataType_Unlike,
            PBAccountListDataType::PBAccountListDataType_Uncomment,
            PBAccountListDataType::PBAccountListDataType_MyUnFollowed,
            PBAccountListDataType::PBAccountListDataType_WhoAdmiresMe,
            PBAccountListDataType::PBAccountListDataType_UnfollowedFromMutualFollowings,
            PBAccountListDataType::PBAccountListDataType_StoryViewersAll,
            PBAccountListDataType::PBAccountListDataType_AllLostFollowers,
            PBAccountListDataType::PBAccountListDataType_LostFollowersReplicant,
            PBAccountListDataType::PBAccountListDataType_StoryViewersNotFollowing,
            PBAccountListDataType::PBAccountListDataType_StoryViewersIDontFollow,
            PBAccountListDataType::PBAccountListDataType_TrackedStories,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBAccountListDataType>("PBAccountListDataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBAccountListDataType {
}

impl ::std::default::Default for PBAccountListDataType {
    fn default() -> Self {
        PBAccountListDataType::PBAccountListDataType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBAccountListDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBMediaEngagingType {
    EngagingType_All = 0,
    EngagingType_Like = 1,
    EngagingType_Comment = 2,
}

impl ::protobuf::ProtobufEnum for PBMediaEngagingType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBMediaEngagingType> {
        match value {
            0 => ::std::option::Option::Some(PBMediaEngagingType::EngagingType_All),
            1 => ::std::option::Option::Some(PBMediaEngagingType::EngagingType_Like),
            2 => ::std::option::Option::Some(PBMediaEngagingType::EngagingType_Comment),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBMediaEngagingType] = &[
            PBMediaEngagingType::EngagingType_All,
            PBMediaEngagingType::EngagingType_Like,
            PBMediaEngagingType::EngagingType_Comment,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBMediaEngagingType>("PBMediaEngagingType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBMediaEngagingType {
}

impl ::std::default::Default for PBMediaEngagingType {
    fn default() -> Self {
        PBMediaEngagingType::EngagingType_All
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMediaEngagingType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBFetchHistoryCountType {
    PBFetchHistoryCountType_Follower = 0,
    PBFetchHistoryCountType_Following = 1,
    PBFetchHistoryCountType_Media = 2,
    PBFetchHistoryCountType_MediaLikes = 3,
    PBFetchHistoryCountType_MediaComments = 4,
}

impl ::protobuf::ProtobufEnum for PBFetchHistoryCountType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBFetchHistoryCountType> {
        match value {
            0 => ::std::option::Option::Some(PBFetchHistoryCountType::PBFetchHistoryCountType_Follower),
            1 => ::std::option::Option::Some(PBFetchHistoryCountType::PBFetchHistoryCountType_Following),
            2 => ::std::option::Option::Some(PBFetchHistoryCountType::PBFetchHistoryCountType_Media),
            3 => ::std::option::Option::Some(PBFetchHistoryCountType::PBFetchHistoryCountType_MediaLikes),
            4 => ::std::option::Option::Some(PBFetchHistoryCountType::PBFetchHistoryCountType_MediaComments),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBFetchHistoryCountType] = &[
            PBFetchHistoryCountType::PBFetchHistoryCountType_Follower,
            PBFetchHistoryCountType::PBFetchHistoryCountType_Following,
            PBFetchHistoryCountType::PBFetchHistoryCountType_Media,
            PBFetchHistoryCountType::PBFetchHistoryCountType_MediaLikes,
            PBFetchHistoryCountType::PBFetchHistoryCountType_MediaComments,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBFetchHistoryCountType>("PBFetchHistoryCountType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBFetchHistoryCountType {
}

impl ::std::default::Default for PBFetchHistoryCountType {
    fn default() -> Self {
        PBFetchHistoryCountType::PBFetchHistoryCountType_Follower
    }
}

impl ::protobuf::reflect::ProtobufValue for PBFetchHistoryCountType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBChangeType {
    PBChangeType_None = 0,
    PBChangeType_ProfileView = 1,
    PBChangeType_Blocking = 2,
    PBChangeType_Unfollow = 3,
    PBChangeType_Unlike = 4,
    PBChangeType_Uncomment = 5,
    PBChangeType_Admires = 6,
    PBChangeType_StoryViewer = 7,
}

impl ::protobuf::ProtobufEnum for PBChangeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBChangeType> {
        match value {
            0 => ::std::option::Option::Some(PBChangeType::PBChangeType_None),
            1 => ::std::option::Option::Some(PBChangeType::PBChangeType_ProfileView),
            2 => ::std::option::Option::Some(PBChangeType::PBChangeType_Blocking),
            3 => ::std::option::Option::Some(PBChangeType::PBChangeType_Unfollow),
            4 => ::std::option::Option::Some(PBChangeType::PBChangeType_Unlike),
            5 => ::std::option::Option::Some(PBChangeType::PBChangeType_Uncomment),
            6 => ::std::option::Option::Some(PBChangeType::PBChangeType_Admires),
            7 => ::std::option::Option::Some(PBChangeType::PBChangeType_StoryViewer),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBChangeType] = &[
            PBChangeType::PBChangeType_None,
            PBChangeType::PBChangeType_ProfileView,
            PBChangeType::PBChangeType_Blocking,
            PBChangeType::PBChangeType_Unfollow,
            PBChangeType::PBChangeType_Unlike,
            PBChangeType::PBChangeType_Uncomment,
            PBChangeType::PBChangeType_Admires,
            PBChangeType::PBChangeType_StoryViewer,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBChangeType>("PBChangeType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBChangeType {
}

impl ::std::default::Default for PBChangeType {
    fn default() -> Self {
        PBChangeType::PBChangeType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBChangeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBBatchTaskType {
    PBBatchTaskType_None = 0,
    PBBatchTaskType_Follow = 1,
    PBBatchTaskType_Unfollow = 2,
}

impl ::protobuf::ProtobufEnum for PBBatchTaskType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBBatchTaskType> {
        match value {
            0 => ::std::option::Option::Some(PBBatchTaskType::PBBatchTaskType_None),
            1 => ::std::option::Option::Some(PBBatchTaskType::PBBatchTaskType_Follow),
            2 => ::std::option::Option::Some(PBBatchTaskType::PBBatchTaskType_Unfollow),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBBatchTaskType] = &[
            PBBatchTaskType::PBBatchTaskType_None,
            PBBatchTaskType::PBBatchTaskType_Follow,
            PBBatchTaskType::PBBatchTaskType_Unfollow,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBBatchTaskType>("PBBatchTaskType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBBatchTaskType {
}

impl ::std::default::Default for PBBatchTaskType {
    fn default() -> Self {
        PBBatchTaskType::PBBatchTaskType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBBatchTaskType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBBatchTaskStatus {
    PBBatchTaskStatus_Pending = 0,
    PBBatchTaskStatus_Finished = 1,
    PBBatchTaskStatus_FeedbackRequired = 2,
    PBBatchTaskStatus_MaxReached = 3,
}

impl ::protobuf::ProtobufEnum for PBBatchTaskStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBBatchTaskStatus> {
        match value {
            0 => ::std::option::Option::Some(PBBatchTaskStatus::PBBatchTaskStatus_Pending),
            1 => ::std::option::Option::Some(PBBatchTaskStatus::PBBatchTaskStatus_Finished),
            2 => ::std::option::Option::Some(PBBatchTaskStatus::PBBatchTaskStatus_FeedbackRequired),
            3 => ::std::option::Option::Some(PBBatchTaskStatus::PBBatchTaskStatus_MaxReached),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBBatchTaskStatus] = &[
            PBBatchTaskStatus::PBBatchTaskStatus_Pending,
            PBBatchTaskStatus::PBBatchTaskStatus_Finished,
            PBBatchTaskStatus::PBBatchTaskStatus_FeedbackRequired,
            PBBatchTaskStatus::PBBatchTaskStatus_MaxReached,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBBatchTaskStatus>("PBBatchTaskStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBBatchTaskStatus {
}

impl ::std::default::Default for PBBatchTaskStatus {
    fn default() -> Self {
        PBBatchTaskStatus::PBBatchTaskStatus_Pending
    }
}

impl ::protobuf::reflect::ProtobufValue for PBBatchTaskStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBUpdateBatchTaskType {
    PBUpdateBatchTaskType_None = 0,
    PBUpdateBatchTaskType_Add = 1,
    PBUpdateBatchTaskType_Del = 2,
    PBUpdateBatchTaskType_Cancel = 3,
}

impl ::protobuf::ProtobufEnum for PBUpdateBatchTaskType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBUpdateBatchTaskType> {
        match value {
            0 => ::std::option::Option::Some(PBUpdateBatchTaskType::PBUpdateBatchTaskType_None),
            1 => ::std::option::Option::Some(PBUpdateBatchTaskType::PBUpdateBatchTaskType_Add),
            2 => ::std::option::Option::Some(PBUpdateBatchTaskType::PBUpdateBatchTaskType_Del),
            3 => ::std::option::Option::Some(PBUpdateBatchTaskType::PBUpdateBatchTaskType_Cancel),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBUpdateBatchTaskType] = &[
            PBUpdateBatchTaskType::PBUpdateBatchTaskType_None,
            PBUpdateBatchTaskType::PBUpdateBatchTaskType_Add,
            PBUpdateBatchTaskType::PBUpdateBatchTaskType_Del,
            PBUpdateBatchTaskType::PBUpdateBatchTaskType_Cancel,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBUpdateBatchTaskType>("PBUpdateBatchTaskType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBUpdateBatchTaskType {
}

impl ::std::default::Default for PBUpdateBatchTaskType {
    fn default() -> Self {
        PBUpdateBatchTaskType::PBUpdateBatchTaskType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBUpdateBatchTaskType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBPostPendingBatchTaskTargetDeltaType {
    PBPostPendingBatchTaskTargetDeltaType_None = 0,
    PBPostPendingBatchTaskTargetDeltaType_Add = 1,
    PBPostPendingBatchTaskTargetDeltaType_Del = 2,
}

impl ::protobuf::ProtobufEnum for PBPostPendingBatchTaskTargetDeltaType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBPostPendingBatchTaskTargetDeltaType> {
        match value {
            0 => ::std::option::Option::Some(PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None),
            1 => ::std::option::Option::Some(PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_Add),
            2 => ::std::option::Option::Some(PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_Del),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBPostPendingBatchTaskTargetDeltaType] = &[
            PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None,
            PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_Add,
            PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_Del,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBPostPendingBatchTaskTargetDeltaType>("PBPostPendingBatchTaskTargetDeltaType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBPostPendingBatchTaskTargetDeltaType {
}

impl ::std::default::Default for PBPostPendingBatchTaskTargetDeltaType {
    fn default() -> Self {
        PBPostPendingBatchTaskTargetDeltaType::PBPostPendingBatchTaskTargetDeltaType_None
    }
}

impl ::protobuf::reflect::ProtobufValue for PBPostPendingBatchTaskTargetDeltaType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PBStoryViewerType {
    PBStoryViewerType_All = 0,
    PBStoryViewerType_NotFollowing = 1,
    PBStoryViewerType_IDontFollow = 2,
}

impl ::protobuf::ProtobufEnum for PBStoryViewerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PBStoryViewerType> {
        match value {
            0 => ::std::option::Option::Some(PBStoryViewerType::PBStoryViewerType_All),
            1 => ::std::option::Option::Some(PBStoryViewerType::PBStoryViewerType_NotFollowing),
            2 => ::std::option::Option::Some(PBStoryViewerType::PBStoryViewerType_IDontFollow),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PBStoryViewerType] = &[
            PBStoryViewerType::PBStoryViewerType_All,
            PBStoryViewerType::PBStoryViewerType_NotFollowing,
            PBStoryViewerType::PBStoryViewerType_IDontFollow,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PBStoryViewerType>("PBStoryViewerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PBStoryViewerType {
}

impl ::std::default::Default for PBStoryViewerType {
    fn default() -> Self {
        PBStoryViewerType::PBStoryViewerType_All
    }
}

impl ::protobuf::reflect::ProtobufValue for PBStoryViewerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13followersPlus.proto\"m\n\x0bPBMessageID\x12$\n\x07apiType\x18\x01\
    \x20\x01(\x0e2\n.PBAPITypeR\x07apiType\x12\x18\n\x05index\x18\x02\x20\
    \x01(\x03R\x05indexB\x02\x18\x01\x12\x1e\n\ndialogUUID\x18\x03\x20\x01(\
    \tR\ndialogUUID\"\xa9\x01\n\nPBIdentity\x12A\n\x10socialPlatformID\x18\
    \x01\x20\x01(\x0e2\x15.PBSocialPlatformTypeR\x10socialPlatformID\x12\x20\
    \n\x05appID\x18\x02\x20\x01(\x0e2\n.PBAppTypeR\x05appID\x12\x18\n\x07use\
    rSID\x18\x03\x20\x01(\x03R\x07userSID\x12\x1c\n\taccountID\x18\x04\x20\
    \x01(\tR\taccountID\"\x92\x02\n\tPBMessage\x12*\n\tmessageID\x18\x01\x20\
    \x01(\x0b2\x0c.PBMessageIDR\tmessageID\x12\x20\n\x0baccessToken\x18\x02\
    \x20\x01(\tR\x0baccessToken\x12*\n\terrorCode\x18\x03\x20\x01(\x0e2\x0c.\
    PBErrorCodeR\terrorCode\x12\x18\n\x07payload\x18\x04\x20\x01(\x0cR\x07pa\
    yload\x12'\n\x08identity\x18\x05\x20\x01(\x0b2\x0b.PBIdentityR\x08identi\
    ty\x12\"\n\x0cerrorMessage\x18\x06\x20\x01(\tR\x0cerrorMessage\x12$\n\rt\
    oBeContinued\x18\x07\x20\x01(\x08R\rtoBeContinued\"\xaa\x01\n\x0ePBNotif\
    ication\x124\n\x0fnotificationAPI\x18\x01\x20\x01(\x0e2\n.PBAPITypeR\x0f\
    notificationAPI\x12\x1e\n\nobjectData\x18\x02\x20\x01(\x0cR\nobjectData\
    \x12\x1c\n\tbroadcast\x18\x03\x20\x01(\x08R\tbroadcast\x12$\n\rmustDeliv\
    ered\x18\x04\x20\x01(\x08R\rmustDelivered\"X\n\x14PBFetchConfigRequest\
    \x12\x1e\n\nappVersion\x18\x01\x20\x01(\tR\nappVersion\x12\x20\n\x0bappB\
    undleID\x18\x02\x20\x01(\tR\x0bappBundleID\"\xa7\x01\n\rFeatureConfig\
    \x12*\n\x04type\x18\x01\x20\x01(\x0e2\x16.PBAccountListDataTypeR\x04type\
    \x12\x1a\n\x08isActive\x18\x02\x20\x01(\x08R\x08isActive\x12\x1c\n\tisVI\
    POnly\x18\x03\x20\x01(\x08R\tisVIPOnly\x120\n\x13unlockableByWatchAd\x18\
    \x04\x20\x01(\x08R\x13unlockableByWatchAd\"\xdc\x01\n\x12PBFetchConfigRe\
    ply\x127\n\x06params\x18\x01\x20\x03(\x0b2\x1f.PBFetchConfigReply.Params\
    EntryR\x06params\x12&\n\x08products\x18\x02\x20\x03(\x0b2\n.PBProductR\
    \x08products\x12*\n\x08features\x18\x03\x20\x03(\x0b2\x0e.FeatureConfigR\
    \x08features\x1a9\n\x0bParamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"9\n\
    \x17PBFetchAppParamsRequest\x12\x1e\n\nappVersion\x18\x01\x20\x01(\tR\na\
    ppVersion\"\x8e\x01\n\x15PBFetchAppParamsReply\x12:\n\x06params\x18\x01\
    \x20\x03(\x0b2\".PBFetchAppParamsReply.ParamsEntryR\x06params\x1a9\n\x0b\
    ParamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"P\n\x20PBUpdateOneSignalPlaye\
    rIDRequest\x12,\n\x11oneSignalPlayerID\x18\x01\x20\x01(\tR\x11oneSignalP\
    layerID\"\x20\n\x1ePBUpdateOneSignalPlayerIDReply\"?\n\x17PBReloadSettin\
    gsRequest\x12$\n\radminUsername\x18\x01\x20\x01(\tR\radminUsername\"\x17\
    \n\x15PBReloadSettingsReply\"\x99\x01\n\rPBSubcription\x12\x1c\n\tproduc\
    tID\x18\x01\x20\x01(\tR\tproductID\x12\"\n\x0cpurchaseDate\x18\x02\x20\
    \x01(\x03R\x0cpurchaseDate\x12\x20\n\x0bexpiresDate\x18\x03\x20\x01(\x03\
    R\x0bexpiresDate\x12$\n\risTrialPeriod\x18\x04\x20\x01(\x08R\risTrialPer\
    iod\"\xcb\x02\n\rPBTransaction\x12$\n\x07product\x18\x01\x20\x01(\x0b2\n\
    .PBProductR\x07product\x12$\n\rtransactionID\x18\x02\x20\x01(\tR\rtransa\
    ctionID\x12\x18\n\x07receipt\x18\x03\x20\x01(\tR\x07receipt\x12\x14\n\
    \x05valid\x18\x04\x20\x01(\x08R\x05valid\x12*\n\x10alreadyProcessed\x18\
    \x05\x20\x01(\x08R\x10alreadyProcessed\x12\x1e\n\njsonParams\x18\x06\x20\
    \x01(\tR\njsonParams\x12\x16\n\x06status\x18\x07\x20\x01(\x03R\x06status\
    \x12\x1a\n\x08hasTrial\x18\x08\x20\x01(\x08R\x08hasTrial\x12>\n\x12activ\
    eSubscription\x18\t\x20\x01(\x0b2\x0e.PBSubcriptionR\x12activeSubscripti\
    on\"P\n\x1cPBValidateTransactionRequest\x120\n\x0btransaction\x18\x01\
    \x20\x01(\x0b2\x0e.PBTransactionR\x0btransaction\"v\n\x1aPBValidateTrans\
    actionReply\x122\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x0e.PBTransacti\
    onR\x0ctransactions\x12$\n\x07product\x18\x02\x20\x01(\x0b2\n.PBProductR\
    \x07product\"7\n\x1bPBVerifySubscriptionRequest\x12\x18\n\x07receipt\x18\
    \x01\x20\x01(\x0cR\x07receipt\"\x8f\x02\n\x19PBVerifySubscriptionReply\
    \x123\n\x06result\x18\x01\x20\x01(\x0e2\x1b.PBVerifySubscriptionResultR\
    \x06result\x12(\n\x0fexpiryTimestamp\x18\x02\x20\x01(\x03R\x0fexpiryTime\
    stamp\x12$\n\risInFreeTrial\x18\x03\x20\x01(\x08R\risInFreeTrial\x121\n\
    \x0cbillingCycle\x18\x04\x20\x01(\x0e2\r.BillingCycleR\x0cbillingCycle\
    \x12\x1c\n\tisSandbox\x18\x05\x20\x01(\x08R\tisSandbox\x12\x1c\n\tproduc\
    tID\x18\x06\x20\x01(\tR\tproductID\"\xa1\x02\n\"PBVerifySubscriptionAndr\
    oidRequest\x12J\n\tpurchases\x18\x01\x20\x03(\x0b2,.PBVerifySubscription\
    AndroidRequest.PurchaseR\tpurchases\x1a\xae\x01\n\x08Purchase\x12\x18\n\
    \x07orderID\x18\x01\x20\x01(\tR\x07orderID\x12\x20\n\x0bpackageName\x18\
    \x02\x20\x01(\tR\x0bpackageName\x12\x1c\n\tproductID\x18\x03\x20\x01(\tR\
    \tproductID\x12\"\n\x0cpurchaseTime\x18\x04\x20\x01(\x03R\x0cpurchaseTim\
    e\x12$\n\rpurchaseToken\x18\x05\x20\x01(\tR\rpurchaseToken\"\x96\x02\n\
    \x20PBVerifySubscriptionAndroidReply\x123\n\x06result\x18\x01\x20\x01(\
    \x0e2\x1b.PBVerifySubscriptionResultR\x06result\x12(\n\x0fexpiryTimestam\
    p\x18\x02\x20\x01(\x03R\x0fexpiryTimestamp\x12$\n\risInFreeTrial\x18\x03\
    \x20\x01(\x08R\risInFreeTrial\x121\n\x0cbillingCycle\x18\x04\x20\x01(\
    \x0e2\r.BillingCycleR\x0cbillingCycle\x12\x1c\n\tisSandbox\x18\x05\x20\
    \x01(\x08R\tisSandbox\x12\x1c\n\tproductID\x18\x06\x20\x01(\tR\tproductI\
    D\"Y\n!PBFetchUserPurchaseHistoryRequest\x124\n\x15accountIDOfTargetUser\
    \x18\x01\x20\x01(\tR\x15accountIDOfTargetUser\"|\n\x12PBUserPurchaseUnit\
    \x12\x1c\n\tproductID\x18\x01\x20\x01(\tR\tproductID\x12\x1c\n\ttimestam\
    p\x18\x02\x20\x01(\x03R\ttimestamp\x12\x14\n\x05coins\x18\x03\x20\x01(\
    \x03R\x05coins\x12\x14\n\x05price\x18\x04\x20\x01(\x03R\x05price\"b\n\
    \x1fPBFetchUserPurchaseHistoryReply\x12)\n\x05units\x18\x01\x20\x01(\x0b\
    2\x13.PBUserPurchaseUnitR\x05units\x12\x14\n\x05coins\x18\x02\x20\x01(\
    \x03R\x05coins\"\xab\x01\n\x1bPBPostOneSignalNotification\x120\n\x13noti\
    ficationMessage\x18\x01\x20\x01(\tR\x13notificationMessage\x12\x1e\n\njs\
    onParams\x18\x02\x20\x01(\tR\njsonParams\x12:\n\x18targetOneSignalPlayer\
    IDs\x18\x03\x20\x03(\tR\x18targetOneSignalPlayerIDs\"\x1c\n\x1aPBFetchUs\
    erSettingsRequest\"\xac\x01\n\x18PBFetchUserSettingsReply\x12O\n\x0cuser\
    Settings\x18\x01\x20\x03(\x0b2+.PBFetchUserSettingsReply.UserSettingsEnt\
    ryR\x0cuserSettings\x1a?\n\x11UserSettingsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xae\x01\n\x19PBPostUserSettingsRequest\x12P\n\x0cuserSettings\
    \x18\x01\x20\x03(\x0b2,.PBPostUserSettingsRequest.UserSettingsEntryR\x0c\
    userSettings\x1a?\n\x11UserSettingsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\x19\n\x17PBPostUserSettingsReply\"J\n\x0cPBPagination\x12\x1e\n\n\
    pageNumber\x18\x01\x20\x01(\x03R\npageNumber\x12\x1a\n\x08pageSize\x18\
    \x02\x20\x01(\x03R\x08pageSize\"\xb4\x02\n\x0ePBLoginRequest\x12\x1e\n\n\
    appVersion\x18\x01\x20\x01(\tR\nappVersion\x12\x20\n\x0bcountryName\x18\
    \x02\x20\x01(\tR\x0bcountryName\x12\x20\n\x0bcountryCode\x18\x03\x20\x01\
    (\tR\x0bcountryCode\x12$\n\rpreferredLang\x18\x04\x20\x01(\tR\rpreferred\
    Lang\x12\x12\n\x04idfa\x18\x05\x20\x01(\tR\x04idfa\x12\x1a\n\x08timezone\
    \x18\x06\x20\x01(\x03R\x08timezone\x12$\n\x07account\x18\x07\x20\x01(\
    \x0b2\n.PBAccountR\x07account\x12*\n\tloginType\x18\x08\x20\x01(\x0e2\
    \x0c.PBLoginTypeR\tloginType\x12\x16\n\x06cookie\x18\t\x20\x01(\tR\x06co\
    okie\"F\n\x0cPBLoginReply\x12\x1a\n\x08createTs\x18\x01\x20\x01(\x03R\
    \x08createTs\x12\x1a\n\x08isOldVIP\x18\x02\x20\x01(\x08R\x08isOldVIP\"\
    \x11\n\x0fPBLogoutRequest\"\x0f\n\rPBLogoutReply\"\x8e\x01\n\x1aPBRefres\
    hConnectionRequest\x12$\n\x07account\x18\x01\x20\x01(\x0b2\n.PBAccountR\
    \x07account\x12*\n\tloginType\x18\x02\x20\x01(\x0e2\x0c.PBLoginTypeR\tlo\
    ginType\x12\x1e\n\nappVersion\x18\x03\x20\x01(\tR\nappVersion\"R\n\x18PB\
    RefreshConnectionReply\x12\x1a\n\x08createTs\x18\x01\x20\x01(\x03R\x08cr\
    eateTs\x12\x1a\n\x08isOldVIP\x18\x02\x20\x01(\x08R\x08isOldVIP\"\xa2\x01\
    \n\x11IntroductoryOffer\x12E\n\rpaymentOption\x18\x01\x20\x01(\x0e2\x1f.\
    IntroductoryOfferPaymentOptionR\rpaymentOption\x12&\n\x0edurationInDays\
    \x18\x02\x20\x01(\x03R\x0edurationInDays\x12\x1e\n\npriceInUSD\x18\x03\
    \x20\x01(\x01R\npriceInUSD\"\x12\n\x10PromotionalOffer\"\xb6\x02\n\tPBPr\
    oduct\x12\x1c\n\tproductID\x18\x01\x20\x01(\tR\tproductID\x12\x18\n\x05p\
    rice\x18\x02\x20\x01(\x03R\x05priceB\x02\x18\x01\x12\x1a\n\x06months\x18\
    \x03\x20\x01(\x03R\x06monthsB\x02\x18\x01\x121\n\x0cbillingCycle\x18\x04\
    \x20\x01(\x0e2\r.BillingCycleR\x0cbillingCycle\x12.\n\x12standardPriceIn\
    USD\x18\x05\x20\x01(\x01R\x12standardPriceInUSD\x120\n\x13discountDescri\
    ption\x18\x06\x20\x01(\x03R\x13discountDescription\x12@\n\x11introductor\
    yOffer\x18\x07\x20\x01(\x0b2\x12.IntroductoryOfferR\x11introductoryOffer\
    \"8\n\x16PBFetchProductsRequest\x12\x1e\n\nappVersion\x18\x01\x20\x01(\t\
    R\nappVersion\">\n\x14PBFetchProductsReply\x12&\n\x08products\x18\x01\
    \x20\x03(\x0b2\n.PBProductR\x08products\"\x8b\x08\n\tPBAccount\x12\x1c\n\
    \taccountID\x18\x01\x20\x01(\tR\taccountID\x12\x1a\n\x08username\x18\x02\
    \x20\x01(\tR\x08username\x12\x1a\n\x08password\x18\x03\x20\x01(\tR\x08pa\
    ssword\x12*\n\x10isPrivateAccount\x18\x04\x20\x01(\x08R\x10isPrivateAcco\
    unt\x12\x1e\n\nmediaCount\x18\x05\x20\x01(\x03R\nmediaCount\x12&\n\x0efo\
    llowingCount\x18\x06\x20\x01(\x03R\x0efollowingCount\x12$\n\rfollowerCou\
    nt\x18\x07\x20\x01(\x03R\rfollowerCount\x12\x1a\n\x08fullName\x18\x08\
    \x20\x01(\tR\x08fullName\x12(\n\x0favatarURLString\x18\t\x20\x01(\tR\x0f\
    avatarURLString\x12\x16\n\x06gender\x18\n\x20\x01(\x03R\x06gender\x12\"\
    \n\x0cemailAddress\x18\x0b\x20\x01(\tR\x0cemailAddress\x12\x1c\n\tbiogra\
    phy\x18\x0c\x20\x01(\tR\tbiography\x12*\n\x10websiteURLString\x18\r\x20\
    \x01(\tR\x10websiteURLString\x12\x20\n\x0bcountryCode\x18\x0e\x20\x01(\t\
    R\x0bcountryCode\x12'\n\x08location\x18\x0f\x20\x01(\x0b2\x0b.PBLocation\
    R\x08location\x12M\n\x19relationshipToThisAccount\x18\x10\x20\x01(\x0e2\
    \x0f.PBRelationshipR\x19relationshipToThisAccount\x12,\n\x0crecentMedias\
    \x18\x11\x20\x03(\x0b2\x08.PBMediaR\x0crecentMedias\x12Q\n\x1brelationsh\
    ipFromThisAccount\x18\x12\x20\x01(\x0e2\x0f.PBRelationshipR\x1brelations\
    hipFromThisAccount\x12\x20\n\x0bphoneNumber\x18\x13\x20\x01(\tR\x0bphone\
    Number\x124\n\x15needToUpdateBasicInfo\x18\x14\x20\x01(\x08R\x15needToUp\
    dateBasicInfo\x12.\n\x12needToUpdateMedias\x18\x15\x20\x01(\x08R\x12need\
    ToUpdateMedias\x12\x1e\n\ncharmValue\x18\x16\x20\x01(\x01R\ncharmValue\
    \x12>\n\x1ahasAnonymousProfilePicture\x18\x17\x20\x01(\x08R\x1ahasAnonym\
    ousProfilePicture\x12?\n\x10accountLoginType\x18\x18\x20\x01(\x0e2\x13.P\
    BAccountLoginTypeR\x10accountLoginType\"t\n\nPBLocation\x12\x1a\n\x08lat\
    itude\x18\x01\x20\x01(\x01R\x08latitude\x12\x1c\n\tlongitude\x18\x02\x20\
    \x01(\x01R\tlongitude\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\
    \x18\n\x07address\x18\x04\x20\x01(\tR\x07address\"\xa7\x06\n\x07PBMedia\
    \x12\x18\n\x07mediaID\x18\x01\x20\x01(\tR\x07mediaID\x12*\n\tmediaType\
    \x18\x02\x20\x01(\x0e2\x0c.PBMediaTypeR\tmediaType\x12'\n\x08location\
    \x18\x03\x20\x01(\x0b2\x0b.PBLocationR\x08location\x12\x1c\n\tlikeCount\
    \x18\x04\x20\x01(\x03R\tlikeCount\x12\"\n\x0ccommentCount\x18\x05\x20\
    \x01(\x03R\x0ccommentCount\x12\x1e\n\ncreateTime\x18\x06\x20\x01(\x03R\n\
    createTime\x12\x20\n\x05owner\x18\x07\x20\x01(\x0b2\n.PBAccountR\x05owne\
    r\x12A\n\x13relationshipToOwner\x18\x08\x20\x01(\x0e2\x0f.PBRelationship\
    R\x13relationshipToOwner\x124\n\x0faccountsInMedia\x18\t\x20\x03(\x0b2\n\
    .PBAccountR\x0faccountsInMedia\x12\x12\n\x04text\x18\n\x20\x01(\tR\x04te\
    xt\x12\x16\n\x06filter\x18\x0b\x20\x01(\tR\x06filter\x12\x12\n\x04tags\
    \x18\x0c\x20\x03(\tR\x04tags\x12A\n\x10imageURLVersions\x18\r\x20\x03(\
    \x0b2\x15.PBMedia.PBURLVersionR\x10imageURLVersions\x12A\n\x10videoURLVe\
    rsions\x18\x0e\x20\x03(\x0b2\x15.PBMedia.PBURLVersionR\x10videoURLVersio\
    ns\x124\n\x0fpreviewComments\x18\x0f\x20\x03(\x0b2\n.PBCommentR\x0fprevi\
    ewComments\x12\x1c\n\tmediaCode\x18\x10\x20\x01(\tR\tmediaCode\x12\x1c\n\
    \tviewCount\x18\x11\x20\x01(\x03R\tviewCount\x1ax\n\x0cPBURLVersion\x12\
    \x14\n\x05width\x18\x01\x20\x01(\x03R\x05width\x12\x16\n\x06height\x18\
    \x02\x20\x01(\x03R\x06height\x12\x1c\n\turlString\x18\x03\x20\x01(\tR\tu\
    rlString\x12\x1c\n\tvideoType\x18\x04\x20\x01(\x03R\tvideoType\"\x89\x01\
    \n\tPBComment\x12\x1c\n\tcommentID\x18\x01\x20\x01(\tR\tcommentID\x12\
    \x20\n\x0bcommentTime\x18\x02\x20\x01(\x03R\x0bcommentTime\x12\x12\n\x04\
    text\x18\x03\x20\x01(\tR\x04text\x12(\n\tcommenter\x18\x04\x20\x01(\x0b2\
    \n.PBAccountR\tcommenter\"c\n\x1dPBTaskContentFetchAccountInfo\x12\x1c\n\
    \taccountID\x18\x01\x20\x01(\tR\taccountID\x12$\n\x07account\x18\x02\x20\
    \x01(\x0b2\n.PBAccountR\x07account\"\x9d\x01\n\x1fPBTaskContentFetchAcco\
    untMedias\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x12\x16\n\
    \x06cursor\x18\x02\x20\x01(\tR\x06cursor\x12\x20\n\x06medias\x18\x03\x20\
    \x03(\x0b2\x08.PBMediaR\x06medias\x12\"\n\x0ccurrentCount\x18\x04\x20\
    \x01(\x03R\x0ccurrentCount\"\xf1\x01\n\x1dPBTaskContentFetchMediaLikers\
    \x12\x18\n\x07mediaID\x18\x01\x20\x01(\tR\x07mediaID\x12\x16\n\x06cursor\
    \x18\x02\x20\x01(\tR\x06cursor\x12\"\n\x06likers\x18\x03\x20\x03(\x0b2\n\
    .PBAccountR\x06likers\x12\"\n\x0ccurrentCount\x18\x04\x20\x01(\x03R\x0cc\
    urrentCount\x12\x1e\n\ntotalCount\x18\x05\x20\x01(\x03R\ntotalCount\x12\
    \x1c\n\tmediaCode\x18\x06\x20\x01(\tR\tmediaCode\x12\x18\n\x07ownerID\
    \x18\x07\x20\x01(\tR\x07ownerID\"\xf7\x01\n\x1fPBTaskContentFetchMediaCo\
    mments\x12\x18\n\x07mediaID\x18\x01\x20\x01(\tR\x07mediaID\x12\x16\n\x06\
    cursor\x18\x02\x20\x01(\tR\x06cursor\x12&\n\x08comments\x18\x03\x20\x03(\
    \x0b2\n.PBCommentR\x08comments\x12\"\n\x0ccurrentCount\x18\x04\x20\x01(\
    \x03R\x0ccurrentCount\x12\x1e\n\ntotalCount\x18\x05\x20\x01(\x03R\ntotal\
    Count\x12\x1c\n\tmediaCode\x18\x06\x20\x01(\tR\tmediaCode\x12\x18\n\x07o\
    wnerID\x18\x07\x20\x01(\tR\x07ownerID\"\xd4\x01\n\"PBTaskContentFetchAcc\
    ountFollowers\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x12\
    \x16\n\x06cursor\x18\x02\x20\x01(\tR\x06cursor\x12(\n\tfollowers\x18\x03\
    \x20\x03(\x0b2\n.PBAccountR\tfollowers\x12\"\n\x0ccurrentCount\x18\x04\
    \x20\x01(\x03R\x0ccurrentCount\x12*\n\x10withExtendedInfo\x18\x05\x20\
    \x01(\x08R\x10withExtendedInfo\"\xa2\x01\n$PBTaskContentFetchAccountLike\
    dMedias\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x12\x16\n\
    \x06cursor\x18\x02\x20\x01(\tR\x06cursor\x12\x20\n\x06medias\x18\x03\x20\
    \x03(\x0b2\x08.PBMediaR\x06medias\x12\"\n\x0ccurrentCount\x18\x04\x20\
    \x01(\x03R\x0ccurrentCount\"\xd7\x01\n#PBTaskContentFetchAccountFollowin\
    gs\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x12\x16\n\x06curs\
    or\x18\x02\x20\x01(\tR\x06cursor\x12*\n\nfollowings\x18\x03\x20\x03(\x0b\
    2\n.PBAccountR\nfollowings\x12\"\n\x0ccurrentCount\x18\x04\x20\x01(\x03R\
    \x0ccurrentCount\x12*\n\x10withExtendedInfo\x18\x05\x20\x01(\x08R\x10wit\
    hExtendedInfo\"\xa2\x02\n\"PBTaskContentFetchAccountBlockings\x12\x1c\n\
    \taccountID\x18\x01\x20\x01(\tR\taccountID\x12\x16\n\x06cursor\x18\x02\
    \x20\x01(\tR\x06cursor\x12N\n\tblockings\x18\x03\x20\x03(\x0b20.PBTaskCo\
    ntentFetchAccountBlockings.BlockingInfoR\tblockings\x12\"\n\x0ccurrentCo\
    unt\x18\x04\x20\x01(\x03R\x0ccurrentCount\x1aR\n\x0cBlockingInfo\x12$\n\
    \x07account\x18\x01\x20\x01(\x0b2\n.PBAccountR\x07account\x12\x1c\n\tblo\
    ckTime\x18\x02\x20\x01(\x03R\tblockTime\"\xa4\x01\n!PBTaksContentFetchAc\
    countRelation\x12(\n\x0fsourceAccountID\x18\x01\x20\x01(\tR\x0fsourceAcc\
    ountID\x12(\n\x0ftargetAccountID\x18\x02\x20\x01(\tR\x0ftargetAccountID\
    \x12+\n\x08relation\x18\x03\x20\x01(\x0e2\x0f.PBRelationshipR\x08relatio\
    n\"\xdc\x02\n#PBTaskContentFetchAccountActivities\x12\x1c\n\taccountID\
    \x18\x01\x20\x01(\tR\taccountID\x12&\n\x0estartTimestamp\x18\x02\x20\x01\
    (\x03R\x0estartTimestamp\x12M\n\nactivities\x18\x03\x20\x03(\x0b2-.PBTas\
    kContentFetchAccountActivities.ActivityR\nactivities\x1a\x9f\x01\n\x08Ac\
    tivity\x12#\n\x04type\x18\x01\x20\x01(\x0e2\x0f.PBActivityTypeR\x04type\
    \x120\n\rtargetAccount\x18\x02\x20\x01(\x0b2\n.PBAccountR\rtargetAccount\
    \x12\x1e\n\x05media\x18\x03\x20\x01(\x0b2\x08.PBMediaR\x05media\x12\x1c\
    \n\ttimestamp\x18\x04\x20\x01(\x03R\ttimestamp\"\xe0\x01\n\x20PBTaksCont\
    entFetchAccountStories\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccount\
    ID\x12H\n\x07stories\x18\x02\x20\x03(\x0b2..PBTaksContentFetchAccountSto\
    ries.StoryElementR\x07stories\x1aT\n\x0cStoryElement\x12\x1e\n\x05story\
    \x18\x01\x20\x01(\x0b2\x08.PBMediaR\x05story\x12$\n\x07viewers\x18\x02\
    \x20\x03(\x0b2\n.PBAccountR\x07viewers\"=\n\x1bPBTaskContentFetchMediaIn\
    fo\x12\x1e\n\x05media\x18\x01\x20\x01(\x0b2\x08.PBMediaR\x05media\"\xa0\
    \x0b\n\x06PBTask\x12'\n\x08taskType\x18\x01\x20\x01(\x0e2\x0b.PBTaskType\
    R\x08taskType\x12\x16\n\x06taskID\x18\x02\x20\x01(\x04R\x06taskID\x12*\n\
    \ttaskState\x18\x03\x20\x01(\x0e2\x0c.PBTaskStateR\ttaskState\x12:\n\rfa\
    ilureAction\x18\x04\x20\x01(\x0e2\x14.PBTaskFailureActionR\rfailureActio\
    n\x12Z\n\x17contentFetchAccountInfo\x18\x05\x20\x01(\x0b2\x1e.PBTaskCont\
    entFetchAccountInfoH\0R\x17contentFetchAccountInfo\x12Z\n\x17contentFetc\
    hMediaLikers\x18\x06\x20\x01(\x0b2\x1e.PBTaskContentFetchMediaLikersH\0R\
    \x17contentFetchMediaLikers\x12`\n\x19contentFetchMediaComments\x18\x07\
    \x20\x01(\x0b2\x20.PBTaskContentFetchMediaCommentsH\0R\x19contentFetchMe\
    diaComments\x12^\n\x16contentFetchFollowings\x18\x08\x20\x01(\x0b2$.PBTa\
    skContentFetchAccountFollowingsH\0R\x16contentFetchFollowings\x12[\n\x15\
    contentFetchFollowers\x18\t\x20\x01(\x0b2#.PBTaskContentFetchAccountFoll\
    owersH\0R\x15contentFetchFollowers\x12`\n\x19contentFetchAccountMedias\
    \x18\n\x20\x01(\x0b2\x20.PBTaskContentFetchAccountMediasH\0R\x19contentF\
    etchAccountMedias\x12a\n\x17contentFetchLikedMedias\x18\x0b\x20\x01(\x0b\
    2%.PBTaskContentFetchAccountLikedMediasH\0R\x17contentFetchLikedMedias\
    \x12[\n\x15contentFetchBlockings\x18\x0c\x20\x01(\x0b2#.PBTaskContentFet\
    chAccountBlockingsH\0R\x15contentFetchBlockings\x12f\n\x1bcontentFetchAc\
    countRelation\x18\r\x20\x01(\x0b2\".PBTaksContentFetchAccountRelationH\0\
    R\x1bcontentFetchAccountRelation\x12l\n\x1dcontentFetchAccountActivities\
    \x18\x0e\x20\x01(\x0b2$.PBTaskContentFetchAccountActivitiesH\0R\x1dconte\
    ntFetchAccountActivities\x12c\n\x1acontentFetchAccountStories\x18\x0f\
    \x20\x01(\x0b2!.PBTaksContentFetchAccountStoriesH\0R\x1acontentFetchAcco\
    untStories\x12T\n\x15contentFetchMediaInfo\x18\x10\x20\x01(\x0b2\x1c.PBT\
    askContentFetchMediaInfoH\0R\x15contentFetchMediaInfo\x12,\n\x11executor\
    AccountID\x18\x1e\x20\x01(\tR\x11executorAccountID\x12&\n\x0eexecutorCoo\
    kie\x18\x1f\x20\x01(\tR\x0eexecutorCookieB\r\n\x0btaskContent\"\xa7\x01\
    \n\x12PBSpawnTaskRequest\x129\n\x07details\x18\x01\x20\x03(\x0b2\x1f.PBS\
    pawnTaskRequest.SpawnDetailR\x07details\x1aV\n\x0bSpawnDetail\x12'\n\x08\
    taskType\x18\x01\x20\x01(\x0e2\x0b.PBTaskTypeR\x08taskType\x12\x1e\n\nfo\
    rceSpawn\x18\x02\x20\x01(\x08R\nforceSpawn\"\xb9\x01\n\x10PBSpawnTaskRep\
    ly\x127\n\x07results\x18\x01\x20\x03(\x0b2\x1d.PBSpawnTaskReply.SpawnRes\
    ultR\x07results\x1al\n\x0bSpawnResult\x12'\n\x08taskType\x18\x01\x20\x01\
    (\x0e2\x0b.PBTaskTypeR\x08taskType\x124\n\x0bspawnStatus\x18\x02\x20\x01\
    (\x0e2\x12.PBSpawnTaskStatusR\x0bspawnStatus\"=\n\x10PBTaskCapability\
    \x12)\n\ttaskTypes\x18\x01\x20\x03(\x0e2\x0b.PBTaskTypeR\ttaskTypes\"\
    \x1c\n\x1aPBFetchTaskProgressRequest\"\x85\x02\n\x18PBFetchTaskProgressR\
    eply\x12F\n\nprogresses\x18\x01\x20\x03(\x0b2&.PBFetchTaskProgressReply.\
    TaskProgressR\nprogresses\x12\"\n\x0cpageProgress\x18\x02\x20\x01(\x03R\
    \x0cpageProgress\x1a}\n\x0cTaskProgress\x12'\n\x04type\x18\x01\x20\x01(\
    \x0e2\x13.PBTaskProgressTypeR\x04type\x12\x1e\n\ntotalCount\x18\x02\x20\
    \x01(\x03R\ntotalCount\x12$\n\rfinishedCount\x18\x03\x20\x01(\x03R\rfini\
    shedCount\"e\n\x17PBFetchCountDataRequest\x12\x1c\n\taccountID\x18\x01\
    \x20\x01(\tR\taccountID\x12,\n\x08dataType\x18\x02\x20\x01(\x0e2\x10.PBC\
    ountDataTypeR\x08dataType\"}\n\x15PBFetchCountDataReply\x12\x14\n\x05cou\
    nt\x18\x01\x20\x01(\x03R\x05count\x12\x18\n\x05delta\x18\x02\x20\x01(\
    \x03R\x05deltaB\x02\x18\x01\x124\n\x15calculationInProgress\x18\x03\x20\
    \x01(\x08R\x15calculationInProgress\"\x9c\x05\n\x14PBAccountListElement\
    \x120\n\rtargetAccount\x18\x01\x20\x01(\x0b2\n.PBAccountR\rtargetAccount\
    \x12;\n\x10outgoingRelation\x18\x02\x20\x01(\x0e2\x0f.PBRelationshipR\
    \x10outgoingRelation\x12;\n\x10incomingRelation\x18\x03\x20\x01(\x0e2\
    \x0f.PBRelationshipR\x10incomingRelation\x12\x1c\n\tlikeCount\x18\x04\
    \x20\x01(\x03R\tlikeCount\x12\"\n\x0ccommentCount\x18\x05\x20\x01(\x03R\
    \x0ccommentCount\x12(\n\rfollowerCount\x18\x06\x20\x01(\x03R\rfollowerCo\
    untB\x02\x18\x01\x12.\n\x12incomingActionTime\x18\x07\x20\x01(\x03R\x12i\
    ncomingActionTime\x12\x1e\n\x05media\x18\x08\x20\x01(\x0b2\x08.PBMediaR\
    \x05media\x12M\n\rrelatedMedias\x18\t\x20\x03(\x0b2'.PBAccountListElemen\
    t.MediaWithRelationR\rrelatedMedias\x124\n\x15needToUpdateRelations\x18\
    \n\x20\x01(\x08R\x15needToUpdateRelations\x12\x18\n\x07content\x18\x0b\
    \x20\x01(\tR\x07content\x12\x14\n\x05score\x18\x0c\x20\x01(\x03R\x05scor\
    e\x1ag\n\x11MediaWithRelation\x12\x1e\n\x05media\x18\x01\x20\x01(\x0b2\
    \x08.PBMediaR\x05media\x122\n\x08relation\x18\x02\x20\x01(\x0e2\x16.PBRe\
    lationshipToMediaR\x08relation\"\x82\x02\n\x1dPBFetchAccountListDataRequ\
    est\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x122\n\x08dataTy\
    pe\x18\x02\x20\x01(\x0e2\x16.PBAccountListDataTypeR\x08dataType\x12-\n\n\
    pagination\x18\x03\x20\x01(\x0b2\r.PBPaginationR\npagination\x12\x1c\n\t\
    startTime\x18\x04\x20\x01(\x03R\tstartTime\x12\x18\n\x07endTime\x18\x05\
    \x20\x01(\x03R\x07endTime\x12(\n\x0fnoRelatedMedias\x18\x06\x20\x01(\x08\
    R\x0fnoRelatedMedias\"\x93\x02\n\x1bPBFetchAccountListDataReply\x12-\n\n\
    pagination\x18\x01\x20\x01(\x0b2\r.PBPaginationR\npagination\x121\n\x08e\
    lements\x18\x02\x20\x03(\x0b2\x15.PBAccountListElementR\x08elements\x124\
    \n\x15calculationInProgress\x18\x03\x20\x01(\x08R\x15calculationInProgre\
    ss\x12&\n\x0etotalDataCount\x18\x04\x20\x01(\x03R\x0etotalDataCount\x12\
    \x1a\n\x08maxScore\x18\x05\x20\x01(\x03R\x08maxScore\x12\x18\n\x07hasNex\
    t\x18\x06\x20\x01(\x08R\x07hasNext\"\xad\x02\n\x20PBFetchMostEngagingMed\
    iasRequest\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x12*\n\tm\
    ediaType\x18\x02\x20\x01(\x0e2\x0c.PBMediaTypeR\tmediaType\x12\x1e\n\nre\
    centDays\x18\x03\x20\x01(\x03R\nrecentDays\x12-\n\npagination\x18\x04\
    \x20\x01(\x0b2\r.PBPaginationR\npagination\x128\n\x0cengagingType\x18\
    \x05\x20\x01(\x0e2\x14.PBMediaEngagingTypeR\x0cengagingType\x12\x1c\n\ts\
    tartTime\x18\x06\x20\x01(\x03R\tstartTime\x12\x18\n\x07endTime\x18\x07\
    \x20\x01(\x03R\x07endTime\"\xa7\x01\n\x1ePBFetchMostEngagingMediasReply\
    \x12-\n\npagination\x18\x01\x20\x01(\x0b2\r.PBPaginationR\npagination\
    \x12\x20\n\x06medias\x18\x02\x20\x03(\x0b2\x08.PBMediaR\x06medias\x124\n\
    \x15calculationInProgress\x18\x03\x20\x01(\x08R\x15calculationInProgress\
    \"\xce\x01\n\x1bPBFetchEngagedMediasRequest\x12\x1c\n\taccountID\x18\x01\
    \x20\x01(\tR\taccountID\x12(\n\x0ftargetAccountID\x18\x02\x20\x01(\tR\
    \x0ftargetAccountID\x128\n\x0cengagingType\x18\x03\x20\x01(\x0e2\x14.PBM\
    ediaEngagingTypeR\x0cengagingType\x12-\n\npagination\x18\x04\x20\x01(\
    \x0b2\r.PBPaginationR\npagination\"\xab\x02\n\x19PBFetchEngagedMediasRep\
    ly\x12-\n\npagination\x18\x01\x20\x01(\x0b2\r.PBPaginationR\npagination\
    \x12?\n\x06medias\x18\x02\x20\x03(\x0b2'.PBFetchEngagedMediasReply.Engag\
    edMediaR\x06medias\x124\n\x15calculationInProgress\x18\x03\x20\x01(\x08R\
    \x15calculationInProgress\x1ah\n\x0cEngagedMedia\x12\x1e\n\x05media\x18\
    \x01\x20\x01(\x0b2\x08.PBMediaR\x05media\x128\n\x0cengagingType\x18\x02\
    \x20\x01(\x0e2\x14.PBMediaEngagingTypeR\x0cengagingType\"e\n\x1bPBFetchS\
    potlightDataRequest\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\
    \x12(\n\x0ftargetAccountID\x18\x02\x20\x01(\tR\x0ftargetAccountID\"\x81\
    \x02\n\x19PBFetchSpotlightDataReply\x12>\n\x1alikeCountFromTargetAccount\
    \x18\x01\x20\x01(\x03R\x1alikeCountFromTargetAccount\x12D\n\x1dcommentCo\
    untFromTargetAccount\x18\x02\x20\x01(\x03R\x1dcommentCountFromTargetAcco\
    unt\x12^\n#mostLikedMediasOwnedByTargetAccount\x18\x03\x20\x03(\x0b2\x08\
    .PBMediaR#mostLikedMediasOwnedByTargetAccountB\x02\x18\x01\"\xa0\x01\n\
    \x1aPBFetchHistoryCountRequest\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\
    \taccountID\x12,\n\x04type\x18\x02\x20\x01(\x0e2\x18.PBFetchHistoryCount\
    TypeR\x04type\x12\x1c\n\tstartTime\x18\x03\x20\x01(\x03R\tstartTime\x12\
    \x18\n\x07endTime\x18\x04\x20\x01(\x03R\x07endTime\"\x8e\x01\n\x18PBFetc\
    hHistoryCountReply\x12;\n\x06counts\x18\x01\x20\x03(\x0b2#.PBFetchHistor\
    yCountReply.CountDataR\x06counts\x1a5\n\tCountData\x12\x14\n\x05count\
    \x18\x01\x20\x01(\x03R\x05count\x12\x12\n\x04time\x18\x02\x20\x01(\x03R\
    \x04time\"j\n\x1ePBFetchAccountRelationsRequest\x12\x1c\n\taccountID\x18\
    \x01\x20\x01(\tR\taccountID\x12*\n\x10targetAccountIDs\x18\x02\x20\x03(\
    \tR\x10targetAccountIDs\"\x9d\x03\n\x1cPBFetchAccountRelationsReply\x12P\
    \n\x0brelationMap\x18\x01\x20\x03(\x0b2..PBFetchAccountRelationsReply.Re\
    lationMapEntryR\x0brelationMap\x1a\xbe\x01\n\x0cRelationData\x12;\n\x10o\
    utgoingRelation\x18\x01\x20\x01(\x0e2\x0f.PBRelationshipR\x10outgoingRel\
    ation\x12;\n\x10incomingRelation\x18\x02\x20\x01(\x0e2\x0f.PBRelationshi\
    pR\x10incomingRelation\x124\n\x15needToUpdateRelations\x18\x03\x20\x01(\
    \x08R\x15needToUpdateRelations\x1aj\n\x10RelationMapEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12@\n\x05value\x18\x02\x20\x01(\x0b2*.PBF\
    etchAccountRelationsReply.RelationDataR\x05value:\x028\x01\"e\n\x16PBPro\
    fileViewerElement\x12-\n\x06viewer\x18\x01\x20\x01(\x0b2\x15.PBAccountLi\
    stElementR\x06viewer\x12\x1c\n\tviewCount\x18\x02\x20\x01(\x03R\tviewCou\
    nt\"\x9e\x01\n\x1cPBFetchProfileViewersRequest\x12\x1c\n\taccountID\x18\
    \x01\x20\x01(\tR\taccountID\x12\x1c\n\tstartTime\x18\x02\x20\x01(\x03R\t\
    startTime\x12\x18\n\x07endTime\x18\x03\x20\x01(\x03R\x07endTime\x12(\n\
    \x0fnoRelatedMedias\x18\x04\x20\x01(\x08R\x0fnoRelatedMedias\"\xc9\x01\n\
    \x1aPBFetchProfileViewersReply\x12D\n\tdataArray\x18\x01\x20\x03(\x0b2&.\
    PBFetchProfileViewersReply.ViewerDataR\tdataArray\x1ae\n\nViewerData\x12\
    \"\n\x0cviewDateTime\x18\x01\x20\x01(\x03R\x0cviewDateTime\x123\n\x08ele\
    ments\x18\x02\x20\x03(\x0b2\x17.PBProfileViewerElementR\x08elements\"H\n\
    \x16PBPostTextNotification\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05tit\
    le\x12\x18\n\x07content\x18\x02\x20\x01(\tR\x07content\"\xcd\x01\n\x18PB\
    PostChangeNotification\x12-\n\nchangeType\x18\x01\x20\x01(\x0e2\r.PBChan\
    geTypeR\nchangeType\x12\x20\n\x0bchangeCount\x18\x02\x20\x01(\x03R\x0bch\
    angeCount\x12$\n\risAccumulated\x18\x03\x20\x01(\x08R\risAccumulated\x12\
    \x1c\n\tsinceTime\x18\x04\x20\x01(\x03R\tsinceTime\x12\x1c\n\taccountID\
    \x18\x05\x20\x01(\tR\taccountID\"\x1f\n\x1dPBValidateSubscriptionRequest\
    \"5\n\x1bPBValidateSubscriptionReply\x12\x16\n\x06status\x18\x01\x20\x01\
    (\x08R\x06status\"B\n\x12PBIsPremiumRequest\x12,\n\x05types\x18\x01\x20\
    \x03(\x0e2\x16.PBAccountListDataTypeR\x05types\"\xa6\x01\n\x10PBIsPremiu\
    mReply\x129\n\x08premiums\x18\x01\x20\x03(\x0b2\x1d.PBIsPremiumReply.Pre\
    miumInfoR\x08premiums\x1aW\n\x0bPremiumInfo\x12*\n\x04type\x18\x01\x20\
    \x01(\x0e2\x16.PBAccountListDataTypeR\x04type\x12\x1c\n\tisPremium\x18\
    \x02\x20\x01(\x08R\tisPremium\"\xc1\x02\n\x13PBReportPageRequest\x126\n\
    \rcountElements\x18\x01\x20\x03(\x0e2\x10.PBCountDataTypeR\rcountElement\
    s\x12:\n\x0clistElements\x18\x02\x20\x03(\x0e2\x16.PBAccountListDataType\
    R\x0clistElements\x12\x16\n\x06urgent\x18\x03\x20\x01(\x08R\x06urgent\
    \x12L\n\x18countExcludeFromProgress\x18\x04\x20\x03(\x0e2\x10.PBCountDat\
    aTypeR\x18countExcludeFromProgress\x12P\n\x17listExcludeFromProgress\x18\
    \x05\x20\x03(\x0e2\x16.PBAccountListDataTypeR\x17listExcludeFromProgress\
    \"a\n\x11PBReportPageReply\x12(\n\x0fspawnedNewTasks\x18\x01\x20\x01(\
    \x08R\x0fspawnedNewTasks\x12\"\n\x0cpageProgress\x18\x02\x20\x01(\x03R\
    \x0cpageProgress\"M\n\x1bPBPostCountDataNotification\x12.\n\tdataTypes\
    \x18\x01\x20\x03(\x0e2\x10.PBCountDataTypeR\tdataTypes\"3\n1PBTransferEx\
    istingServerBatchTasksToClientRequest\"\xd5\x01\n/PBTransferExistingServ\
    erBatchTasksToClientReply\x12N\n\"unfinishedFollowTargetInstagramIDs\x18\
    \x01\x20\x03(\x03R\"unfinishedFollowTargetInstagramIDs\x12R\n$unfinished\
    UnfollowTargetInstagramIDs\x18\x02\x20\x03(\x03R$unfinishedUnfollowTarge\
    tInstagramIDs\"3\n\x17PBFetchBatchTaskRequest\x12\x18\n\x07taskIDs\x18\
    \x01\x20\x03(\x03R\x07taskIDs\"\xe0\x02\n\x12PBBatchTaskSummary\x12\x16\
    \n\x06taskID\x18\x01\x20\x01(\x03R\x06taskID\x12,\n\x08taskType\x18\x02\
    \x20\x01(\x0e2\x10.PBBatchTaskTypeR\x08taskType\x122\n\ntaskStatus\x18\
    \x03\x20\x01(\x0e2\x12.PBBatchTaskStatusR\ntaskStatus\x12*\n\x10totalTar\
    getCount\x18\x04\x20\x01(\x03R\x10totalTargetCount\x120\n\x13finishedTar\
    getCount\x18\x05\x20\x01(\x03R\x13finishedTargetCount\x12\x1c\n\tstartTi\
    me\x18\x06\x20\x01(\x03R\tstartTime\x12\x18\n\x07endTime\x18\x07\x20\x01\
    (\x03R\x07endTime\x12:\n\x12firstTargetAccount\x18\x08\x20\x01(\x0b2\n.P\
    BAccountR\x12firstTargetAccount\"F\n\x15PBFetchBatchTaskReply\x12-\n\x07\
    results\x18\x01\x20\x03(\x0b2\x13.PBBatchTaskSummaryR\x07results\"\xaa\
    \x01\n\x18PBUpdateBatchTaskRequest\x12*\n\x04type\x18\x01\x20\x01(\x0e2\
    \x16.PBUpdateBatchTaskTypeR\x04type\x12,\n\x08taskType\x18\x02\x20\x01(\
    \x0e2\x10.PBBatchTaskTypeR\x08taskType\x12\x16\n\x06taskID\x18\x03\x20\
    \x01(\x03R\x06taskID\x12\x1c\n\ttargetIDs\x18\x04\x20\x03(\x03R\ttargetI\
    Ds\"0\n\x16PBUpdateBatchTaskReply\x12\x16\n\x06taskID\x18\x01\x20\x01(\
    \x03R\x06taskID\"W\n%PBFetchPendingBatchTaskTargetsRequest\x12.\n\ttaskT\
    ypes\x18\x01\x20\x03(\x0e2\x10.PBBatchTaskTypeR\ttaskTypes\"\xf2\x01\n#P\
    BFetchPendingBatchTaskTargetsReply\x12V\n\x07results\x18\x01\x20\x03(\
    \x0b2<.PBFetchPendingBatchTaskTargetsReply.PendingBatchTaskTargetsR\x07r\
    esults\x1as\n\x17PendingBatchTaskTargets\x12,\n\x08taskType\x18\x01\x20\
    \x01(\x0e2\x10.PBBatchTaskTypeR\x08taskType\x12*\n\x10pendingTargetIDs\
    \x18\x02\x20\x03(\x03R\x10pendingTargetIDs\"\xeb\x01\n!PBPostPendingBatc\
    hTaskTargetDelta\x12D\n\tdeltaType\x18\x01\x20\x01(\x0e2&.PBPostPendingB\
    atchTaskTargetDeltaTypeR\tdeltaType\x12,\n\x08taskType\x18\x02\x20\x01(\
    \x0e2\x10.PBBatchTaskTypeR\x08taskType\x12\x16\n\x06taskID\x18\x03\x20\
    \x01(\x03R\x06taskID\x12\x1c\n\taccountID\x18\x04\x20\x01(\tR\taccountID\
    \x12\x1c\n\ttargetIDs\x18\x05\x20\x03(\x03R\ttargetIDs\"\x9b\x02\n#PBPos\
    tBatchTaskCompleteNotification\x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\
    \taccountID\x12\x16\n\x06taskID\x18\x02\x20\x01(\x03R\x06taskID\x12,\n\
    \x08taskType\x18\x03\x20\x01(\x0e2\x10.PBBatchTaskTypeR\x08taskType\x122\
    \n\ntaskStatus\x18\x04\x20\x01(\x0e2\x12.PBBatchTaskStatusR\ntaskStatus\
    \x12*\n\x10totalTargetCount\x18\x05\x20\x01(\x03R\x10totalTargetCount\
    \x120\n\x13finishedTargetCount\x18\x06\x20\x01(\x03R\x13finishedTargetCo\
    unt\"\xd2\x01\n\x15PBProxiedFetchContent\x12\x1f\n\x04type\x18\x01\x20\
    \x01(\x0e2\x0b.PBTaskTypeR\x04type\x12,\n\x11executorAccountID\x18\x02\
    \x20\x01(\tR\x11executorAccountID\x12Z\n\x17contentFetchAccountInfo\x18\
    \x03\x20\x01(\x0b2\x1e.PBTaskContentFetchAccountInfoH\0R\x17contentFetch\
    AccountInfoB\x0e\n\x0cfetchContent\"k\n\x1cPBFetchAccountStoriesRequest\
    \x12\x1c\n\taccountID\x18\x01\x20\x01(\tR\taccountID\x12-\n\npagination\
    \x18\x02\x20\x01(\x0b2\r.PBPaginationR\npagination\"\x89\x01\n\x1aPBFetc\
    hAccountStoriesReply\x12-\n\npagination\x18\x01\x20\x01(\x0b2\r.PBPagina\
    tionR\npagination\x12\"\n\x07stories\x18\x02\x20\x03(\x0b2\x08.PBMediaR\
    \x07stories\x12\x18\n\x07hasNext\x18\x03\x20\x01(\x08R\x07hasNext\"\xab\
    \x01\n\x1aPBFetchStoryViewersRequest\x12\x1c\n\taccountID\x18\x01\x20\
    \x01(\tR\taccountID\x12\x18\n\x07storyID\x18\x02\x20\x01(\tR\x07storyID\
    \x12&\n\x04type\x18\x03\x20\x01(\x0e2\x12.PBStoryViewerTypeR\x04type\x12\
    -\n\npagination\x18\x04\x20\x01(\x0b2\r.PBPaginationR\npagination\"\x94\
    \x01\n\x18PBFetchStoryViewersReply\x12-\n\npagination\x18\x01\x20\x01(\
    \x0b2\r.PBPaginationR\npagination\x12/\n\x07viewers\x18\x02\x20\x03(\x0b\
    2\x15.PBAccountListElementR\x07viewers\x12\x18\n\x07hasNext\x18\x03\x20\
    \x01(\x08R\x07hasNext*\x92\t\n\tPBAPIType\x12\x14\n\x10PostNotification\
    \x10\0\x12\t\n\x05Login\x10\x01\x12\n\n\x06Logout\x10\x02\x12\x15\n\x11R\
    efreshConnection\x10\x03\x12\x12\n\x0eReloadSettings\x10\x04\x12\x12\n\
    \x0eFetchAppParams\x10\x05\x12\x1b\n\x17UpdateOneSignalPlayerID\x10\x06\
    \x12\x0f\n\x0bFetchConfig\x10\x07\x12\x11\n\rFetchProducts\x10\n\x12\x17\
    \n\x13ValidateTransaction\x10\x0b\x12\x14\n\x10FetchVIPProducts\x10\x0c\
    \x12\x11\n\rBuyVIPProduct\x10\r\x12\x1c\n\x18FetchUserPurchaseHistory\
    \x10\x0e\x12\x16\n\x12VerifySubscription\x10\x0f\x12\x1d\n\x19VerifySubs\
    criptionAndroid\x10\x10\x12\x0e\n\nFetchGifts\x10\x14\x12\n\n\x06DoGift\
    \x10\x15\x12\x0c\n\x08VIPPitch\x10\x16\x12\x1d\n\x19PostOneSignalNotific\
    ation\x10\x1d\x12\x15\n\x11FetchUserSettings\x10\x1e\x12\x14\n\x10PostUs\
    erSettings\x10\x1f\x12\x10\n\x0cDispatchTask\x10d\x12\x0c\n\x08PostTask\
    \x10e\x12\r\n\tSpawnTask\x10f\x12\x16\n\x12PostTaskCapability\x10i\x12\
    \x15\n\x11FetchTaskProgress\x10l\x12\x12\n\x0eFetchCountData\x10n\x12\
    \x18\n\x14FetchAccountListData\x10o\x12\x1b\n\x17FetchMostEngagingMedias\
    \x10p\x12\x16\n\x12FetchSpotlightData\x10q\x12\x16\n\x12FetchHistoryCoun\
    ts\x10r\x12\x19\n\x15FetchAccountRelations\x10s\x12\x17\n\x13FetchProfil\
    eViewers\x10t\x12\x16\n\x12FetchEngagedMedias\x10u\x12\x17\n\x13FetchAcc\
    ountStories\x10v\x12\x15\n\x11FetchStoryViewers\x10w\x12\x19\n\x14PostTe\
    xtNotification\x10\x96\x01\x12\x1a\n\x15PostChangeNotifcation\x10\x97\
    \x01\x12\x1e\n\x19PostCountDataNotification\x10\x98\x01\x12$\n\x1fPostPe\
    ndingBatchTaskTargetDelta\x10\x99\x01\x12&\n!PostBatchTaskCompleteNotifi\
    cation\x10\x9a\x01\x12-\n(TransferExistingServerBatchTasksToClient\x10\
    \x9b\x01\x12\x19\n\x14ValidateSubscription\x10\xc8\x01\x12\x0e\n\tIsPrem\
    ium\x10\xac\x02\x12\x0f\n\nReportPage\x10\x90\x03\x12\x13\n\x0eFetchBatc\
    hTask\x10\xf4\x03\x12\x14\n\x0fUpdateBatchTask\x10\xf5\x03\x12!\n\x1cFet\
    chPendingBatchTaskTargets\x10\xfe\x03\x12\x18\n\x13ProxiedFetchContent\
    \x10\xd8\x04*\xc7\x01\n\x0bPBErrorCode\x12\x0b\n\x07Success\x10\0\x12\
    \x10\n\x0cUnknownError\x10\x01\x12\x0e\n\nParamError\x10\x02\x12\r\n\tAu\
    thError\x10\x03\x12\x0c\n\x08NotExist\x10\x04\x12\x0c\n\x08Disabled\x10\
    \x05\x12\x14\n\x10ConnectionClosed\x10\x06\x12\x12\n\x0eNotImplemented\
    \x10\x07\x12\x13\n\x0fTooManyRequests\x10\x08\x12\x0f\n\x0bUnavailable\
    \x10\t\x12\x0e\n\nRedirected\x10\n*%\n\x14PBSocialPlatformType\x12\r\n\t\
    Instagram\x10\0*6\n\tPBAppType\x12\t\n\x05SanTi\x10\0\x12\x11\n\rFollowe\
    rsPlus\x10\x01\x12\x0b\n\x07IGtrack\x10\x02*]\n\x1aPBVerifySubscriptionR\
    esult\x12\x10\n\x0cnotPurchased\x10\0\x12\x0e\n\nsubscribed\x10\x01\x12\
    \x0b\n\x07expired\x10\x02\x12\x10\n\x0creceiptError\x10\x03*\x88\x01\n\
    \x0bPBLoginType\x12\x13\n\x0fPBLoginType_App\x10\0\x12\x13\n\x0fPBLoginT\
    ype_Bot\x10\x01\x12\x16\n\x12PBLoginType_Bridge\x10\x02\x12\x19\n\x15PBL\
    oginType_BatchTask\x10\x03\x12\x1c\n\x18PBLoginType_ProxiedFetch\x10\x04\
    *p\n\x0cBillingCycle\x12\n\n\x06weekly\x10\0\x12\x0c\n\x08oneMonth\x10\
    \x01\x12\x0c\n\x08twoMonth\x10\x02\x12\x0e\n\nthreeMonth\x10\x03\x12\x0e\
    \n\nhalfYearly\x10\x04\x12\n\n\x06yearly\x10\x05\x12\x0c\n\x08lifetime\
    \x10\x06*O\n\x1eIntroductoryOfferPaymentOption\x12\r\n\tfreeTrial\x10\0\
    \x12\x0e\n\npayAsYouGo\x10\x01\x12\x0e\n\npayUpFront\x10\x02*;\n\x12PBAc\
    countLoginType\x12\x12\n\x0eInstagramLogin\x10\0\x12\x11\n\rFacebookLogi\
    n\x10\x01*k\n\x0bPBMediaType\x12\x14\n\x10PBMediaType_None\x10\0\x12\x15\
    \n\x11PBMediaType_Photo\x10\x01\x12\x15\n\x11PBMediaType_Video\x10\x02\
    \x12\x18\n\x14PBMediaType_Carousel\x10\x08*\x85\x04\n\nPBTaskType\x12\
    \x13\n\x0fPBTaskType_Noop\x10\0\x12\x1f\n\x1bPBTaskType_FetchAccountInfo\
    \x10\x01\x12\x1e\n\x1aPBTaskType_FetchMediaLikes\x10\x02\x12!\n\x1dPBTas\
    kType_FetchMediaComments\x10\x03\x12%\n!PBTaskType_FetchAccountFollowing\
    s\x10\x04\x12$\n\x20PBTaskType_FetchAccountFollowers\x10\x05\x12!\n\x1dP\
    BTaskType_FetchAccountMedias\x10\x06\x12&\n\"PBTaskType_FetchAccountLike\
    dMedias\x10\x07\x12$\n\x20PBTaskType_FetchAccountBlockings\x10\x08\x12#\
    \n\x1fPBTaskType_FetchAccountRelation\x10\t\x12%\n!PBTaskType_FetchAccou\
    ntActivities\x10\n\x12\"\n\x1ePBTaskType_FetchAccountStories\x10\x0b\x12\
    \x1d\n\x19PBTaskType_FetchMediaInfo\x10\x0c\x121\n-PBTaskType_RefreshAcc\
    ountInfluentialFollowers\x10d*X\n\x0bPBTaskState\x12\x17\n\x13PBTaskStat\
    e_Pending\x10\0\x12\x17\n\x13PBTaskState_Success\x10\x01\x12\x17\n\x13PB\
    TaskState_Failure\x10\x02*\x8a\x01\n\x13PBTaskFailureAction\x12'\n#PBTas\
    kFailureAction_DispatchToOther\x10\0\x12&\n\"PBTaskFailureAction_Dispatc\
    hToSelf\x10\x01\x12\"\n\x1ePBTaskFailureAction_DeleteTask\x10\x02*y\n\
    \x0ePBActivityType\x12\x17\n\x13PBActivityType_Null\x10\0\x12\x17\n\x13P\
    BActivityType_Like\x10\x01\x12\x1a\n\x16PBActivityType_Comment\x10\x02\
    \x12\x19\n\x15PBActivityType_Follow\x10\x03*l\n\x11PBSpawnTaskStatus\x12\
    \x18\n\x14PBSpawnTaskStatus_OK\x10\0\x12\x20\n\x1cPBSpawnTaskStatus_InPr\
    ogress\x10\x01\x12\x1b\n\x17PBSpawnTaskStatus_Error\x10\x02*\xf8\x02\n\
    \x12PBTaskProgressType\x12\x1b\n\x17PBTaskProgressType_None\x10\0\x12$\n\
    \x20PBTaskProgressType_FollowingList\x10\x01\x12$\n\x20PBTaskProgressTyp\
    e_FollowingInfo\x10\x02\x12#\n\x1fPBTaskProgressType_FollowerList\x10\
    \x03\x12#\n\x1fPBTaskProgressType_FollowerInfo\x10\x04\x12\x20\n\x1cPBTa\
    skProgressType_MediaList\x10\x05\x12\x20\n\x1cPBTaskProgressType_MediaLi\
    ke\x10\x06\x12#\n\x1fPBTaskProgressType_MediaComment\x10\x07\x12!\n\x1dP\
    BTaskProgressType_LikedMedia\x10\x08\x12#\n\x1fPBTaskProgressType_Blocki\
    ngList\x10\t*\xe2\x07\n\x0fPBCountDataType\x12\x18\n\x14PBCountDataType_\
    None\x10\0\x12\x1e\n\x1aPBCountDataType_TotalLikes\x10\x01\x12#\n\x1fPBC\
    ountDataType_MutualFollowing\x10\x02\x12&\n\"PBCountDataType_NotFollowin\
    gMeBack\x10\x03\x12&\n\"PBCountDataType_ImNotFollowingBack\x10\x04\x12!\
    \n\x1dPBCountDataType_TotalComments\x10\x05\x12\x1f\n\x1bPBCountDataType\
    _TotalPhotos\x10\x06\x12\x1f\n\x1bPBCountDataType_TotalVideos\x10\x07\
    \x12\"\n\x1ePBCountDataType_TotalCarousels\x10\x08\x12#\n\x1fPBCountData\
    Type_TotalPhotoLikes\x10\t\x12#\n\x1fPBCountDataType_TotalVideoLikes\x10\
    \n\x12&\n\"PBCountDataType_TotalCarouselLikes\x10\x0b\x12&\n\"PBCountDat\
    aType_TotalPhotoComments\x10\x0c\x12&\n\"PBCountDataType_TotalVideoComme\
    nts\x10\r\x12)\n%PBCountDataType_TotalCarouselComments\x10\x0e\x12\x1f\n\
    \x1bPBCountDataType_TotalMedias\x10\x0f\x12-\n)PBCountDataType_TotalUnli\
    kesAndUnComments\x10\x10\x12\"\n\x1ePBCountDataType_TotalBlockings\x10\
    \x11\x12!\n\x1dPBCountDataType_MediaMaxLikes\x10\x12\x12$\n\x20PBCountDa\
    taType_MediaMaxComments\x10\x13\x12%\n!PBCountDataType_CommentedAccounts\
    \x10\x14\x122\n.PBCountDataType_UnfollowedFromMutualFollowings\x10\x15\
    \x12(\n$PBCountDataType_CurrentLostFollowers\x10\x16\x12\x20\n\x1cPBCoun\
    tDataType_StoryViewers\x10\x17\x12\"\n\x1ePBCountDataType_TrackedStories\
    \x10\x18\x12\"\n\x1ePBCountDataType_ProfileViewers\x10\x19*\x9b\x01\n\
    \x0ePBRelationship\x12\x17\n\x13PBRelationship_Null\x10\0\x12\x19\n\x15P\
    BRelationship_Follow\x10\x01\x12\x18\n\x14PBRelationship_Block\x10\x02\
    \x12\x1c\n\x18PBRelationship_Requested\x10\x03\x12\x1d\n\x19PBRelationsh\
    ip_NoRelation\x10\x04*z\n\x15PBRelationshipToMedia\x12\x1e\n\x1aPBRelati\
    onshipToMedia_Null\x10\0\x12\x1e\n\x1aPBRelationshipToMedia_Like\x10\x01\
    \x12!\n\x1dPBRelationshipToMedia_Comment\x10\x02*\xc8\n\n\x15PBAccountLi\
    stDataType\x12\x1e\n\x1aPBAccountListDataType_None\x10\0\x12#\n\x1fPBAcc\
    ountListDataType_MostLoyal\x10\x01\x12&\n\"PBAccountListDataType_MostFri\
    endly\x10\x02\x12'\n#PBAccountListDataType_MostTalkative\x10\x03\x12)\n%\
    PBAccountListDataType_MutualFollowing\x10\x04\x12%\n!PBAccountListDataTy\
    pe_NoLikeGiven\x10\x05\x12'\n#PBAccountListDataType_NoCommentLeft\x10\
    \x06\x12*\n&PBAccountListDataType_NoCommentOrLikes\x10\x07\x12$\n\x20PBA\
    ccountListDataType_BlockingMe\x10\x08\x12+\n'PBAccountListDataType_Liked\
    NotFollowing\x10\t\x12,\n(PBAccountListDataType_NotFollowingMeBack\x10\n\
    \x12,\n(PBAccountListDataType_ImNotFollowingBack\x10\x0b\x12(\n$PBAccoun\
    tListDataType_SecretAdmirers\x10\x0c\x12.\n*PBAccountListDataType_Influe\
    ntialFollowers\x10\r\x12)\n%PBAccountListDataType_GainedFollowers\x10\
    \x0e\x12'\n#PBAccountListDataType_LostFollowers\x10\x0f\x12(\n$PBAccount\
    ListDataType_ProfileViewers\x10\x10\x12(\n$PBAccountListDataType_Favouri\
    teUsers\x10\x11\x12+\n'PBAccountListDataType_EarliestFollowers\x10\x12\
    \x12)\n%PBAccountListDataType_LatestFollowers\x10\x13\x12\x20\n\x1cPBAcc\
    ountListDataType_Unlike\x10\x14\x12#\n\x1fPBAccountListDataType_Uncommen\
    t\x10\x15\x12&\n\"PBAccountListDataType_MyUnFollowed\x10\x16\x12&\n\"PBA\
    ccountListDataType_WhoAdmiresMe\x10\x17\x128\n4PBAccountListDataType_Unf\
    ollowedFromMutualFollowings\x10\x18\x12)\n%PBAccountListDataType_StoryVi\
    ewersAll\x10\x19\x12*\n&PBAccountListDataType_AllLostFollowers\x10\x1a\
    \x120\n,PBAccountListDataType_LostFollowersReplicant\x10\x1b\x122\n.PBAc\
    countListDataType_StoryViewersNotFollowing\x10\x1c\x121\n-PBAccountListD\
    ataType_StoryViewersIDontFollow\x10\x1d\x12(\n$PBAccountListDataType_Tra\
    ckedStories\x10\x1e*\\\n\x13PBMediaEngagingType\x12\x14\n\x10EngagingTyp\
    e_All\x10\0\x12\x15\n\x11EngagingType_Like\x10\x01\x12\x18\n\x14Engaging\
    Type_Comment\x10\x02*\xdc\x01\n\x17PBFetchHistoryCountType\x12$\n\x20PBF\
    etchHistoryCountType_Follower\x10\0\x12%\n!PBFetchHistoryCountType_Follo\
    wing\x10\x01\x12!\n\x1dPBFetchHistoryCountType_Media\x10\x02\x12&\n\"PBF\
    etchHistoryCountType_MediaLikes\x10\x03\x12)\n%PBFetchHistoryCountType_M\
    ediaComments\x10\x04*\xe6\x01\n\x0cPBChangeType\x12\x15\n\x11PBChangeTyp\
    e_None\x10\0\x12\x1c\n\x18PBChangeType_ProfileView\x10\x01\x12\x19\n\x15\
    PBChangeType_Blocking\x10\x02\x12\x19\n\x15PBChangeType_Unfollow\x10\x03\
    \x12\x17\n\x13PBChangeType_Unlike\x10\x04\x12\x1a\n\x16PBChangeType_Unco\
    mment\x10\x05\x12\x18\n\x14PBChangeType_Admires\x10\x06\x12\x1c\n\x18PBC\
    hangeType_StoryViewer\x10\x07*e\n\x0fPBBatchTaskType\x12\x18\n\x14PBBatc\
    hTaskType_None\x10\0\x12\x1a\n\x16PBBatchTaskType_Follow\x10\x01\x12\x1c\
    \n\x18PBBatchTaskType_Unfollow\x10\x02*\x9c\x01\n\x11PBBatchTaskStatus\
    \x12\x1d\n\x19PBBatchTaskStatus_Pending\x10\0\x12\x1e\n\x1aPBBatchTaskSt\
    atus_Finished\x10\x01\x12&\n\"PBBatchTaskStatus_FeedbackRequired\x10\x02\
    \x12\x20\n\x1cPBBatchTaskStatus_MaxReached\x10\x03*\x97\x01\n\x15PBUpdat\
    eBatchTaskType\x12\x1e\n\x1aPBUpdateBatchTaskType_None\x10\0\x12\x1d\n\
    \x19PBUpdateBatchTaskType_Add\x10\x01\x12\x1d\n\x19PBUpdateBatchTaskType\
    _Del\x10\x02\x12\x20\n\x1cPBUpdateBatchTaskType_Cancel\x10\x03*\xb5\x01\
    \n%PBPostPendingBatchTaskTargetDeltaType\x12.\n*PBPostPendingBatchTaskTa\
    rgetDeltaType_None\x10\0\x12-\n)PBPostPendingBatchTaskTargetDeltaType_Ad\
    d\x10\x01\x12-\n)PBPostPendingBatchTaskTargetDeltaType_Del\x10\x02*u\n\
    \x11PBStoryViewerType\x12\x19\n\x15PBStoryViewerType_All\x10\0\x12\"\n\
    \x1ePBStoryViewerType_NotFollowing\x10\x01\x12!\n\x1dPBStoryViewerType_I\
    DontFollow\x10\x02J\x94\xd0\x02\n\x07\x12\x05\0\0\xa5\n\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\n\n\x02\x05\0\x12\x04\x01\0Q\x01\n\n\n\x03\x05\0\
    \x01\x12\x03\x01\x05\x0e\n)\n\x04\x05\0\x02\0\x12\x03\x04\x04\x19\x1a\
    \x1c\x20Login,\x20connections\x20[0...9]\n\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03\x04\x04\x14\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x04\x17\x18\n\
    \x0b\n\x04\x05\0\x02\x01\x12\x03\x05\x04\x0e\n\x0c\n\x05\x05\0\x02\x01\
    \x01\x12\x03\x05\x04\t\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x05\x0c\r\n\
    \x0b\n\x04\x05\0\x02\x02\x12\x03\x06\x04\x0f\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x06\x04\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x06\r\x0e\n\
    \x0b\n\x04\x05\0\x02\x03\x12\x03\x07\x04\x1a\n\x0c\n\x05\x05\0\x02\x03\
    \x01\x12\x03\x07\x04\x15\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x07\x18\
    \x19\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x08\x04\x17\n\x0c\n\x05\x05\0\x02\
    \x04\x01\x12\x03\x08\x04\x12\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x08\
    \x15\x16\n\x0b\n\x04\x05\0\x02\x05\x12\x03\t\x04\x17\n\x0c\n\x05\x05\0\
    \x02\x05\x01\x12\x03\t\x04\x12\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\t\
    \x15\x16\n*\n\x04\x05\0\x02\x06\x12\x03\n\x04\x20\"\x1d\x20OneSignal\x20\
    Push\x20Notification\n\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\n\x04\x1b\n\
    \x0c\n\x05\x05\0\x02\x06\x02\x12\x03\n\x1e\x1f\n]\n\x04\x05\0\x02\x07\
    \x12\x03\x0b\x04\x14\"P\x20Params,\x20FeatureLists\x20-\x20ON/OFF,\x20PB\
    Product,\x20\xe5\x92\x8c\xe5\x85\xb6\xe4\xbb\x96\xe5\x8f\xaa\xe8\xb7\x9f\
    \xe7\x89\x88\xe6\x9c\xac\xe6\x9c\x89\xe5\x85\xb3\xe7\x9a\x84\xe4\xb8\x9c\
    \xe8\xa5\xbf\n\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x0b\x04\x0f\n\x0c\n\
    \x05\x05\0\x02\x07\x02\x12\x03\x0b\x12\x13\n!\n\x04\x05\0\x02\x08\x12\
    \x03\x0e\x04\x17\x1a\x14\x20Products\x20[10...19]\n\n\x0c\n\x05\x05\0\
    \x02\x08\x01\x12\x03\x0e\x04\x11\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\
    \x0e\x14\x16\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0f\x04\x1d\n\x0c\n\x05\x05\
    \0\x02\t\x01\x12\x03\x0f\x04\x17\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x0f\
    \x1a\x1c\n\x0b\n\x04\x05\0\x02\n\x12\x03\x10\x04\x1a\n\x0c\n\x05\x05\0\
    \x02\n\x01\x12\x03\x10\x04\x14\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x10\
    \x17\x19\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x11\x04\x17\n\x0c\n\x05\x05\0\
    \x02\x0b\x01\x12\x03\x11\x04\x11\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\
    \x11\x14\x16\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x12\x04\"\n\x0c\n\x05\x05\
    \0\x02\x0c\x01\x12\x03\x12\x04\x1c\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\
    \x12\x1f!\n\x0b\n\x04\x05\0\x02\r\x12\x03\x13\x04\x1c\n\x0c\n\x05\x05\0\
    \x02\r\x01\x12\x03\x13\x04\x16\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x13\
    \x19\x1b\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x14\x04#\n\x0c\n\x05\x05\0\
    \x02\x0e\x01\x12\x03\x14\x04\x1d\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\
    \x14\x20\"\n\x1e\n\x04\x05\0\x02\x0f\x12\x03\x17\x04\x14\x1a\x11\x20Gift\
    s\x20[20...29]\n\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x17\x04\x0e\n\x0c\
    \n\x05\x05\0\x02\x0f\x02\x12\x03\x17\x11\x13\n\x0b\n\x04\x05\0\x02\x10\
    \x12\x03\x18\x04\x10\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x18\x04\n\n\
    \x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x18\r\x0f\n\x0b\n\x04\x05\0\x02\x11\
    \x12\x03\x19\x04\x12\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x19\x04\x0c\n\
    \x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x19\x0f\x11\n%\n\x04\x05\0\x02\x12\
    \x12\x03\x1c\x04#\x1a\x18\x20OneSignal\x20notification\n\n\x0c\n\x05\x05\
    \0\x02\x12\x01\x12\x03\x1c\x04\x1d\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\
    \x1c\x20\"\n\x1c\n\x04\x05\0\x02\x13\x12\x03\x1f\x04\x1b\x1a\x0f\x20User\
    \x20Settings\n\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1f\x04\x15\n\x0c\n\
    \x05\x05\0\x02\x13\x02\x12\x03\x1f\x18\x1a\n\x0b\n\x04\x05\0\x02\x14\x12\
    \x03\x20\x04\x1a\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x20\x04\x14\n\x0c\
    \n\x05\x05\0\x02\x14\x02\x12\x03\x20\x17\x19\n\x12\n\x04\x05\0\x02\x15\
    \x12\x03\"\x04\x17\x1a\x05Task\n\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\"\
    \x04\x10\n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\"\x13\x16\n\x0b\n\x04\x05\
    \0\x02\x16\x12\x03#\x04\x13\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03#\x04\
    \x0c\n\x0c\n\x05\x05\0\x02\x16\x02\x12\x03#\x0f\x12\n\x0b\n\x04\x05\0\
    \x02\x17\x12\x03$\x04\x14\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03$\x04\r\n\
    \x0c\n\x05\x05\0\x02\x17\x02\x12\x03$\x10\x13\n/\n\x04\x05\0\x02\x18\x12\
    \x03'\x04\x1d\x1a\"Task\x20Capability:\x20client\x20->\x20server\n\n\x0c\
    \n\x05\x05\0\x02\x18\x01\x12\x03'\x04\x16\n\x0c\n\x05\x05\0\x02\x18\x02\
    \x12\x03'\x19\x1c\n\x1b\n\x04\x05\0\x02\x19\x12\x03*\x04\x1c\x1a\x0eTask\
    \x20Progress\n\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03*\x04\x15\n\x0c\n\
    \x05\x05\0\x02\x19\x02\x12\x03*\x18\x1b\n\x12\n\x04\x05\0\x02\x1a\x12\
    \x03-\x04\x19\x1a\x05Data\n\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03-\x04\
    \x12\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03-\x15\x18\n\x0b\n\x04\x05\0\
    \x02\x1b\x12\x03.\x04\x1f\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03.\x04\x18\
    \n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03.\x1b\x1e\n\x0b\n\x04\x05\0\x02\
    \x1c\x12\x03/\x04\"\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03/\x04\x1b\n\x0c\
    \n\x05\x05\0\x02\x1c\x02\x12\x03/\x1e!\n\x0b\n\x04\x05\0\x02\x1d\x12\x03\
    0\x04\x1d\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x030\x04\x16\n\x0c\n\x05\x05\
    \0\x02\x1d\x02\x12\x030\x19\x1c\n\x0b\n\x04\x05\0\x02\x1e\x12\x031\x04\
    \x1d\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x031\x04\x16\n\x0c\n\x05\x05\0\
    \x02\x1e\x02\x12\x031\x19\x1c\n\x0b\n\x04\x05\0\x02\x1f\x12\x032\x04\x20\
    \n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x032\x04\x19\n\x0c\n\x05\x05\0\x02\
    \x1f\x02\x12\x032\x1c\x1f\n\x0b\n\x04\x05\0\x02\x20\x12\x033\x04\x1e\n\
    \x0c\n\x05\x05\0\x02\x20\x01\x12\x033\x04\x17\n\x0c\n\x05\x05\0\x02\x20\
    \x02\x12\x033\x1a\x1d\n\x0b\n\x04\x05\0\x02!\x12\x034\x04\x1d\n\x0c\n\
    \x05\x05\0\x02!\x01\x12\x034\x04\x16\n\x0c\n\x05\x05\0\x02!\x02\x12\x034\
    \x19\x1c\n\x0b\n\x04\x05\0\x02\"\x12\x035\x04\x1e\n\x0c\n\x05\x05\0\x02\
    \"\x01\x12\x035\x04\x17\n\x0c\n\x05\x05\0\x02\"\x02\x12\x035\x1a\x1d\n\
    \x0b\n\x04\x05\0\x02#\x12\x036\x04\x1c\n\x0c\n\x05\x05\0\x02#\x01\x12\
    \x036\x04\x15\n\x0c\n\x05\x05\0\x02#\x02\x12\x036\x18\x1b\n1\n\x04\x05\0\
    \x02$\x12\x039\x04\x1f\x1a$\x20S2C\x20only\x20Notifications\x20[150...19\
    9]\n\n\x0c\n\x05\x05\0\x02$\x01\x12\x039\x04\x18\n\x0c\n\x05\x05\0\x02$\
    \x02\x12\x039\x1b\x1e\n\x0b\n\x04\x05\0\x02%\x12\x03:\x04\x20\n\x0c\n\
    \x05\x05\0\x02%\x01\x12\x03:\x04\x19\n\x0c\n\x05\x05\0\x02%\x02\x12\x03:\
    \x1c\x1f\n\x0b\n\x04\x05\0\x02&\x12\x03;\x04$\n\x0c\n\x05\x05\0\x02&\x01\
    \x12\x03;\x04\x1d\n\x0c\n\x05\x05\0\x02&\x02\x12\x03;\x20#\n\x0b\n\x04\
    \x05\0\x02'\x12\x03<\x04*\n\x0c\n\x05\x05\0\x02'\x01\x12\x03<\x04#\n\x0c\
    \n\x05\x05\0\x02'\x02\x12\x03<&)\n\x0b\n\x04\x05\0\x02(\x12\x03=\x04,\n\
    \x0c\n\x05\x05\0\x02(\x01\x12\x03=\x04%\n\x0c\n\x05\x05\0\x02(\x02\x12\
    \x03=(+\n\x0b\n\x04\x05\0\x02)\x12\x03>\x043\n\x0c\n\x05\x05\0\x02)\x01\
    \x12\x03>\x04,\n\x0c\n\x05\x05\0\x02)\x02\x12\x03>/2\n\x1a\n\x04\x05\0\
    \x02*\x12\x03A\x04\x1f\x1a\rSubscription\n\n\x0c\n\x05\x05\0\x02*\x01\
    \x12\x03A\x04\x18\n\x0c\n\x05\x05\0\x02*\x02\x12\x03A\x1b\x1e\n\x1b\n\
    \x04\x05\0\x02+\x12\x03D\x04\x14\x1a\x0ePremium\x20check\n\n\x0c\n\x05\
    \x05\0\x02+\x01\x12\x03D\x04\r\n\x0c\n\x05\x05\0\x02+\x02\x12\x03D\x10\
    \x13\n\"\n\x04\x05\0\x02,\x12\x03G\x04\x15\x1a\x15Report\x20page\x20elem\
    ents\n\n\x0c\n\x05\x05\0\x02,\x01\x12\x03G\x04\x0e\n\x0c\n\x05\x05\0\x02\
    ,\x02\x12\x03G\x11\x14\n\x18\n\x04\x05\0\x02-\x12\x03J\x04\x19\x1a\x0bBa\
    tch\x20task\n\n\x0c\n\x05\x05\0\x02-\x01\x12\x03J\x04\x12\n\x0c\n\x05\
    \x05\0\x02-\x02\x12\x03J\x15\x18\n\x0b\n\x04\x05\0\x02.\x12\x03K\x04\x1a\
    \n\x0c\n\x05\x05\0\x02.\x01\x12\x03K\x04\x13\n\x0c\n\x05\x05\0\x02.\x02\
    \x12\x03K\x16\x19\n\x0b\n\x04\x05\0\x02/\x12\x03M\x04'\n\x0c\n\x05\x05\0\
    \x02/\x01\x12\x03M\x04\x20\n\x0c\n\x05\x05\0\x02/\x02\x12\x03M#&\n#\n\
    \x04\x05\0\x020\x12\x03P\x04\x1e\x1a\x16Proxied\x20content\x20fetch\n\n\
    \x0c\n\x05\x05\0\x020\x01\x12\x03P\x04\x17\n\x0c\n\x05\x05\0\x020\x02\
    \x12\x03P\x1a\x1d\n\x9d\x01\n\x02\x05\x01\x12\x04V\0b\x01\x1a\x90\x01///\
    ///////////////////////////////////////////////////////////\n/\x20Genera\
    l\x20Message\n//////////////////////////////////////////////////////////\
    ////\n\n\n\n\x03\x05\x01\x01\x12\x03V\x05\x10\n\x0b\n\x04\x05\x01\x02\0\
    \x12\x03W\x04\x10\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03W\x04\x0b\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03W\x0e\x0f\n\x0b\n\x04\x05\x01\x02\x01\x12\
    \x03X\x04\x15\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03X\x04\x10\n\x0c\n\
    \x05\x05\x01\x02\x01\x02\x12\x03X\x13\x14\n\x0b\n\x04\x05\x01\x02\x02\
    \x12\x03Y\x04\x13\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03Y\x04\x0e\n\x0c\
    \n\x05\x05\x01\x02\x02\x02\x12\x03Y\x11\x12\n\x0b\n\x04\x05\x01\x02\x03\
    \x12\x03Z\x04\x12\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03Z\x04\r\n\x0c\n\
    \x05\x05\x01\x02\x03\x02\x12\x03Z\x10\x11\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03[\x04\x11\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03[\x04\x0c\n\x0c\
    \n\x05\x05\x01\x02\x04\x02\x12\x03[\x0f\x10\n\x0b\n\x04\x05\x01\x02\x05\
    \x12\x03\\\x04\x11\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\\\x04\x0c\n\
    \x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\\\x0f\x10\n\x0b\n\x04\x05\x01\x02\
    \x06\x12\x03]\x04\x19\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03]\x04\x14\n\
    \x0c\n\x05\x05\x01\x02\x06\x02\x12\x03]\x17\x18\n\x0b\n\x04\x05\x01\x02\
    \x07\x12\x03^\x04\x17\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03^\x04\x12\n\
    \x0c\n\x05\x05\x01\x02\x07\x02\x12\x03^\x15\x16\n\x0b\n\x04\x05\x01\x02\
    \x08\x12\x03_\x04\x18\n\x0c\n\x05\x05\x01\x02\x08\x01\x12\x03_\x04\x13\n\
    \x0c\n\x05\x05\x01\x02\x08\x02\x12\x03_\x16\x17\n\x0b\n\x04\x05\x01\x02\
    \t\x12\x03`\x04\x14\n\x0c\n\x05\x05\x01\x02\t\x01\x12\x03`\x04\x0f\n\x0c\
    \n\x05\x05\x01\x02\t\x02\x12\x03`\x12\x13\n\x0b\n\x04\x05\x01\x02\n\x12\
    \x03a\x04\x14\n\x0c\n\x05\x05\x01\x02\n\x01\x12\x03a\x04\x0e\n\x0c\n\x05\
    \x05\x01\x02\n\x02\x12\x03a\x11\x13\n\n\n\x02\x05\x02\x12\x04d\0f\x01\n\
    \n\n\x03\x05\x02\x01\x12\x03d\x05\x19\n\x0b\n\x04\x05\x02\x02\0\x12\x03e\
    \x04\x12\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03e\x04\r\n\x0c\n\x05\x05\
    \x02\x02\0\x02\x12\x03e\x10\x11\n\n\n\x02\x05\x03\x12\x04h\0l\x01\n\n\n\
    \x03\x05\x03\x01\x12\x03h\x05\x0e\n\x1e\n\x04\x05\x03\x02\0\x12\x03i\x04\
    \x0e\"\x11com.fansup.santi\n\n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03i\x04\
    \t\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03i\x0c\r\n&\n\x04\x05\x03\x02\x01\
    \x12\x03j\x04\x16\"\x19com.fansup.followersplus\n\n\x0c\n\x05\x05\x03\
    \x02\x01\x01\x12\x03j\x04\x11\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03j\
    \x14\x15\n\x0b\n\x04\x05\x03\x02\x02\x12\x03k\x04\x10\n\x0c\n\x05\x05\
    \x03\x02\x02\x01\x12\x03k\x04\x0b\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\
    \x03k\x0e\x0f\n;\n\x02\x04\0\x12\x04q\0x\x012/\x20Only\x20common\x20APIs\
    \x20can\x20be\x20defined\x20here\x20[0...29]\n\n\n\n\x03\x04\0\x01\x12\
    \x03q\x08\x13\n\x0b\n\x04\x04\0\x02\0\x12\x03s\x04\x1a\n\x0c\n\x05\x04\0\
    \x02\0\x06\x12\x03s\x04\r\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03s\x0e\x15\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03s\x18\x19\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03t\x04&\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03t\x04\t\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03t\n\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03t\
    \x12\x13\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03t\x14%\n\r\n\x06\x04\0\x02\
    \x01\x08\x03\x12\x03t\x15$\n\x20\n\x04\x04\0\x02\x02\x12\x03w\x04\x1a\
    \x1a\x13\xe4\xbb\xa3\xe6\x9b\xbf\xe8\x80\x81\xe7\x9a\x84\x20index\n\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03w\x04\n\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03w\x0b\x15\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03w\x18\x19\n\n\
    \n\x02\x04\x01\x12\x04z\0\x7f\x01\n\n\n\x03\x04\x01\x01\x12\x03z\x08\x12\
    \n1\n\x04\x04\x01\x02\0\x12\x03{\x04.\"$\x20Instagram\x20/\x20Twitter\
    \x20/\x20Facebook\x20...\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03{\x04\
    \x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03{\x19)\n\x0c\n\x05\x04\x01\x02\
    \0\x03\x12\x03{,-\n\x0b\n\x04\x04\x01\x02\x01\x12\x03|\x04\x18\n\x0c\n\
    \x05\x04\x01\x02\x01\x06\x12\x03|\x04\r\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03|\x0e\x13\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03|\x16\x17\n/\n\
    \x04\x04\x01\x02\x02\x12\x03}\x04\x16\"\"\x20Server\x20generated\x20id,\
    \x20int\x20maxID++\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03}\x04\t\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03}\n\x11\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03}\x14\x15\nC\n\x04\x04\x01\x02\x03\x12\x03~\x04\x19\"6\
    \x20Social\x20platform's\x20username\x20/\x20email\x20/\x20phone\x20numb\
    er...\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03~\x04\n\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03~\x0b\x14\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03~\x17\x18\n\x0c\n\x02\x04\x02\x12\x06\x81\x01\0\x92\x01\x01\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\x81\x01\x08\x11\n\x0c\n\x04\x04\x02\x02\0\x12\
    \x04\x83\x01\x04\x1e\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\x83\x01\x04\x0f\
    \n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x83\x01\x10\x19\n\r\n\x05\x04\x02\
    \x02\0\x03\x12\x04\x83\x01\x1c\x1d\n\x0c\n\x04\x04\x02\x02\x01\x12\x04\
    \x84\x01\x04\x1b\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\x84\x01\x04\n\n\r\
    \n\x05\x04\x02\x02\x01\x01\x12\x04\x84\x01\x0b\x16\n\r\n\x05\x04\x02\x02\
    \x01\x03\x12\x04\x84\x01\x19\x1a\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\x85\
    \x01\x04\x1e\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\x85\x01\x04\x0f\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\x85\x01\x10\x19\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\x85\x01\x1c\x1d\n\x0c\n\x04\x04\x02\x02\x03\x12\x04\x86\
    \x01\x04\x16\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\x86\x01\x04\t\n\r\n\
    \x05\x04\x02\x02\x03\x01\x12\x04\x86\x01\n\x11\n\r\n\x05\x04\x02\x02\x03\
    \x03\x12\x04\x86\x01\x14\x15\n\x0c\n\x04\x04\x02\x02\x04\x12\x04\x87\x01\
    \x04\x1c\n\r\n\x05\x04\x02\x02\x04\x06\x12\x04\x87\x01\x04\x0e\n\r\n\x05\
    \x04\x02\x02\x04\x01\x12\x04\x87\x01\x0f\x17\n\r\n\x05\x04\x02\x02\x04\
    \x03\x12\x04\x87\x01\x1a\x1b\n\x0c\n\x04\x04\x02\x02\x05\x12\x04\x88\x01\
    \x04\x1c\n\r\n\x05\x04\x02\x02\x05\x05\x12\x04\x88\x01\x04\n\n\r\n\x05\
    \x04\x02\x02\x05\x01\x12\x04\x88\x01\x0b\x17\n\r\n\x05\x04\x02\x02\x05\
    \x03\x12\x04\x88\x01\x1a\x1b\n\x9b\x07\n\x04\x04\x02\x02\x06\x12\x04\x91\
    \x01\x04\x1b\x1a\x8c\x07\x20\xe9\xbb\x98\xe8\xae\xa4false\xef\xbc\x8c\
    \xe8\xa1\xa8\xe7\xa4\xba\xe4\xb8\x80\xe9\x97\xae\xe4\xb8\x80\xe7\xad\x94\
    \xef\xbc\x8c\xe5\x85\xbc\xe5\xae\xb9\xe8\x80\x81\xe5\xae\xa2\xe6\x88\xb7\
    \xe7\xab\xaf\xe3\x80\x82\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe8\xae\xbe\
    \xe7\xbd\xae\xe4\xb8\xbatrue\xe6\x97\xb6\xef\xbc\x8c\xe8\xa1\xa8\xe7\xa4\
    \xba\xe5\x8f\x91\xe8\xb5\xb7\xe4\xba\x86\xe4\xb8\x80\xe4\xb8\xaa\xe4\xb8\
    \x80\xe9\x97\xae\xe5\xa4\x9a\xe7\xad\x94\xe7\x9a\x84\xe5\xaf\xb9\xe8\xaf\
    \x9d\xef\xbc\x8c\xe4\xbb\x85\xe6\x96\xb0\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\
    \xaf\xe6\x94\xaf\xe6\x8c\x81\n\x20\xe4\xb8\x8b\xe9\x9d\xa2\xe4\xbb\xa5\
    \x20mutualFollowing\x20\xe4\xb8\xba\xe4\xbe\x8b\xef\xbc\x9a\n\x20\xe6\
    \x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8\xe6\xa3\x80\xe6\xb5\x8b\xe5\x88\xb0\xe5\
    \xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe8\xae\xbe\xe7\xbd\xae\xe4\xba\x86true\
    \xef\xbc\x8c\xe5\x88\x99\xe5\x9b\x9e\xe7\xad\x94\xe6\x97\xb6\xe5\xba\x94\
    \xe8\xaf\xa5\xe5\x8f\x82\xe8\x80\x83calculationInProgress\xef\xbc\x8c\
    \xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe4\xb8\xaa\xe5\x9b\x9e\xe7\xad\x94\
    \xe6\x97\xb6\xe8\xae\xbe\xe7\xbd\xaetoBeContinued=false\n\x20\xe5\xa6\
    \x82\xe6\x9e\x9c\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe8\xae\xbe\xe7\xbd\
    \xae\xe4\xba\x86toBeContinued=false\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\
    \xe8\xaf\xb4\xe6\x98\x8e\xe6\x98\xaf\xe8\x80\x81\xe5\xae\xa2\xe6\x88\xb7\
    \xe7\xab\xaf\xef\xbc\x8c\xe5\x88\x99\xe7\x9b\xb4\xe6\x8e\xa5\xe5\x85\xb3\
    \xe9\x97\xad\xe5\xaf\xb9\xe8\xaf\x9d\xef\xbc\x8c\xe9\x87\x8a\xe6\x94\xbe\
    \xe8\xb5\x84\xe6\xba\x90\xef\xbc\x8c\xe8\xb5\xb0\xe8\x80\x81\xe7\x9a\x84\
    \xe9\x80\x9a\xe4\xbf\xa1\xe6\xa8\xa1\xe5\xbc\x8f\xe3\x80\x82\n\x20\xe5\
    \xa6\x82\xe6\x9e\x9c\xe4\xb8\x80\xe4\xb8\xaa\xe6\xad\xa3\xe5\x9c\xa8\xe5\
    \xb7\xa5\xe4\xbd\x9c\xe4\xb8\xad\xe7\x9a\x84dialog\xef\xbc\x8c\xe5\xae\
    \xa2\xe6\x88\xb7\xe7\xab\xaf\xe7\x94\xb1\xe4\xba\x8e\xe6\x9f\x90\xe4\xba\
    \x9b\xe5\x8e\x9f\xe5\x9b\xa0\xef\xbc\x8c\xe6\xaf\x94\xe5\xa6\x82\xe7\xa6\
    \xbb\xe5\xbc\x80\xe4\xba\x86\xe6\x9f\x90\xe4\xb8\xaa\xe7\x95\x8c\xe9\x9d\
    \xa2\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\x81\xe4\xb8\xbb\xe5\x8a\xa8\xe7\xbb\
    \x88\xe6\xad\xa2\xe5\xaf\xb9\xe8\xaf\x9d\xef\xbc\x8c\xe5\x88\x99\xe4\xbc\
    \x9a\xe5\x8f\x91\xe9\x80\x81\xe4\xb8\x80\xe4\xb8\xaa\xe7\xa9\xba\xe7\x9a\
    \x84PBMessage\xef\xbc\x8c\n\x20messageID\xe4\xb8\xba\xe9\x9c\x80\xe8\xa6\
    \x81\xe7\xbb\x88\xe6\xad\xa2\xe7\x9a\x84dialog\xe7\x9a\x84\xe5\x80\xbc\
    \xef\xbc\x8c\xe5\x85\xb6\xe4\xb8\xad\xe8\xae\xbe\xe7\xbd\xae\xe4\xba\x86\
    toBeContinued=fasle\n\x20\xe5\xa6\x82\xe6\x9e\x9c\xe4\xb8\x80\xe4\xb8\
    \xaa\xe6\xad\xa3\xe5\x9c\xa8\xe5\xb7\xa5\xe4\xbd\x9c\xe4\xb8\xad\xe7\x9a\
    \x84dialog\xef\xbc\x8c\xe7\x94\xb1\xe4\xba\x8e\xe7\xac\xac\xe4\xb8\x89\
    \xe6\x96\xb9\xe7\x9a\x84\xe5\x8e\x9f\xe5\x9b\xa0\xe6\xaf\x94\xe5\xa6\x82\
    \xe7\xbd\x91\xe7\xbb\x9c\xe6\x96\xad\xe5\xbc\x80\xef\xbc\x8c\xe6\x9c\x8d\
    \xe5\x8a\xa1\xe5\x99\xa8\xe9\x9c\x80\xe8\xa6\x81\xe4\xb8\xbb\xe5\x8a\xa8\
    \xe7\xbb\x88\xe6\xad\xa2\xe5\xaf\xb9\xe8\xaf\x9d\xef\xbc\x9b\xe5\xa6\x82\
    \xe6\x9c\x89\xe4\xb8\x9a\xe5\x8a\xa1\xe9\x9c\x80\xe8\xa6\x81\xef\xbc\x8c\
    \xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe5\x9c\xa8\xe9\x87\x8d\xe8\xbf\x9e\
    \xe7\x9a\x84\xe6\x97\xb6\xe5\x80\x99\xe4\xbc\x9a\xe5\x8f\x91\xe8\xb5\xb7\
    \xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\xb0\xe7\x9a\x84dialog\n\n\r\n\x05\x04\
    \x02\x02\x06\x05\x12\x04\x91\x01\x04\x08\n\r\n\x05\x04\x02\x02\x06\x01\
    \x12\x04\x91\x01\t\x16\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\x91\x01\x19\
    \x1a\n\x0c\n\x02\x04\x03\x12\x06\x94\x01\0\x9a\x01\x01\n\x0b\n\x03\x04\
    \x03\x01\x12\x04\x94\x01\x08\x16\n5\n\x04\x04\x03\x02\0\x12\x04\x96\x01\
    \x04\"\"'\x20FetchAccountListData\xef\xbc\x8fFetchCountData\n\n\r\n\x05\
    \x04\x03\x02\0\x06\x12\x04\x96\x01\x04\r\n\r\n\x05\x04\x03\x02\0\x01\x12\
    \x04\x96\x01\x0e\x1d\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x96\x01\x20!\n4\
    \n\x04\x04\x03\x02\x01\x12\x04\x97\x01\x04\x19\"&\x20PBFetchAccountListD\
    ataReply/PBXXX...\n\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\x97\x01\x04\t\
    \n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x97\x01\n\x14\n\r\n\x05\x04\x03\
    \x02\x01\x03\x12\x04\x97\x01\x17\x18\n\x0c\n\x04\x04\x03\x02\x02\x12\x04\
    \x98\x01\x04\x17\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\x98\x01\x04\x08\n\
    \r\n\x05\x04\x03\x02\x02\x01\x12\x04\x98\x01\t\x12\n\r\n\x05\x04\x03\x02\
    \x02\x03\x12\x04\x98\x01\x15\x16\n\x0c\n\x04\x04\x03\x02\x03\x12\x04\x99\
    \x01\x04\x1b\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\x99\x01\x04\x08\n\r\n\
    \x05\x04\x03\x02\x03\x01\x12\x04\x99\x01\t\x16\n\r\n\x05\x04\x03\x02\x03\
    \x03\x12\x04\x99\x01\x19\x1a\n\xa4\x01\n\x02\x04\x04\x12\x06\xa0\x01\0\
    \xa4\x01\x01\x1a\x95\x01////////////////////////////////////////////////\
    //////////////\n/\x20App\x20specific\x20Message\n///////////////////////\
    ///////////////////////////////////////\n\n\x0b\n\x03\x04\x04\x01\x12\
    \x04\xa0\x01\x08\x1c\n\x14\n\x04\x04\x04\x02\0\x12\x04\xa2\x01\x04\x1a\"\
    \x063.2.7\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xa2\x01\x04\n\n\r\n\x05\
    \x04\x04\x02\0\x01\x12\x04\xa2\x01\x0b\x15\n\r\n\x05\x04\x04\x02\0\x03\
    \x12\x04\xa2\x01\x18\x19\nI\n\x04\x04\x04\x02\x01\x12\x04\xa3\x01\x04\
    \x1b\";com.fansup.followersplus,\x20com.fansup.followersplus.android\n\n\
    \r\n\x05\x04\x04\x02\x01\x05\x12\x04\xa3\x01\x04\n\n\r\n\x05\x04\x04\x02\
    \x01\x01\x12\x04\xa3\x01\x0b\x16\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\
    \xa3\x01\x19\x1a\n\x0c\n\x02\x04\x05\x12\x06\xa6\x01\0\xac\x01\x01\n\x0b\
    \n\x03\x04\x05\x01\x12\x04\xa6\x01\x08\x15\n\x0c\n\x04\x04\x05\x02\0\x12\
    \x04\xa8\x01\x04#\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xa8\x01\x04\x19\n\
    \r\n\x05\x04\x05\x02\0\x01\x12\x04\xa8\x01\x1a\x1e\n\r\n\x05\x04\x05\x02\
    \0\x03\x12\x04\xa8\x01!\"\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\xa9\x01\
    \x04\x16\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xa9\x01\x04\x08\n\r\n\x05\
    \x04\x05\x02\x01\x01\x12\x04\xa9\x01\t\x11\n\r\n\x05\x04\x05\x02\x01\x03\
    \x12\x04\xa9\x01\x14\x15\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\xaa\x01\x04\
    \x17\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xaa\x01\x04\x08\n\r\n\x05\x04\
    \x05\x02\x02\x01\x12\x04\xaa\x01\t\x12\n\r\n\x05\x04\x05\x02\x02\x03\x12\
    \x04\xaa\x01\x15\x16\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\xab\x01\x04!\n\
    \r\n\x05\x04\x05\x02\x03\x05\x12\x04\xab\x01\x04\x08\n\r\n\x05\x04\x05\
    \x02\x03\x01\x12\x04\xab\x01\t\x1c\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\
    \xab\x01\x1f\x20\n\x0c\n\x02\x04\x06\x12\x06\xae\x01\0\xb4\x01\x01\n\x0b\
    \n\x03\x04\x06\x01\x12\x04\xae\x01\x08\x1a\n\x0c\n\x04\x04\x06\x02\0\x12\
    \x04\xb0\x01\x04#\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xb0\x01\x04\x17\n\
    \r\n\x05\x04\x06\x02\0\x01\x12\x04\xb0\x01\x18\x1e\n\r\n\x05\x04\x06\x02\
    \0\x03\x12\x04\xb0\x01!\"\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xb2\x01\
    \x04$\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xb2\x01\x04\x0c\n\r\n\x05\
    \x04\x06\x02\x01\x06\x12\x04\xb2\x01\r\x16\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xb2\x01\x17\x1f\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xb2\x01\"\
    #\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xb3\x01\x04(\n\r\n\x05\x04\x06\x02\
    \x02\x04\x12\x04\xb3\x01\x04\x0c\n\r\n\x05\x04\x06\x02\x02\x06\x12\x04\
    \xb3\x01\r\x1a\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xb3\x01\x1b#\n\r\n\
    \x05\x04\x06\x02\x02\x03\x12\x04\xb3\x01&'\n\x0c\n\x02\x04\x07\x12\x06\
    \xb6\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb6\x01\x08\x1f\n\
    \x0c\n\x04\x04\x07\x02\0\x12\x04\xb8\x01\x04\x1a\n\r\n\x05\x04\x07\x02\0\
    \x05\x12\x04\xb8\x01\x04\n\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb8\x01\
    \x0b\x15\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb8\x01\x18\x19\n\x0c\n\x02\
    \x04\x08\x12\x06\xbb\x01\0\xbe\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xbb\x01\x08\x1d\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xbd\x01\x04#\n\r\n\
    \x05\x04\x08\x02\0\x06\x12\x04\xbd\x01\x04\x17\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xbd\x01\x18\x1e\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xbd\x01\
    !\"\n\x0c\n\x02\x04\t\x12\x06\xc0\x01\0\xc3\x01\x01\n\x0b\n\x03\x04\t\
    \x01\x12\x04\xc0\x01\x08(\nL\n\x04\x04\t\x02\0\x12\x04\xc2\x01\x04!\">\
    \x20User\x20id\x20from\x20OneSignal,\x20can\x20be\x20used\x20in\x20`incl\
    ude_player_ids`:\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xc2\x01\x04\n\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xc2\x01\x0b\x1c\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xc2\x01\x1f\x20\n\x0c\n\x02\x04\n\x12\x06\xc5\x01\0\xc8\x01\x01\
    \n\x0b\n\x03\x04\n\x01\x12\x04\xc5\x01\x08&\n\x0c\n\x02\x04\x0b\x12\x06\
    \xca\x01\0\xcd\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xca\x01\x08\x1f\n\
    \x0c\n\x04\x04\x0b\x02\0\x12\x04\xcc\x01\x04\x1d\n\r\n\x05\x04\x0b\x02\0\
    \x05\x12\x04\xcc\x01\x04\n\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xcc\x01\
    \x0b\x18\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xcc\x01\x1b\x1c\n\x0c\n\x02\
    \x04\x0c\x12\x06\xcf\x01\0\xd2\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \xcf\x01\x08\x1d\n\x98\x01\n\x02\x04\r\x12\x06\xd8\x01\0\xde\x01\x012\
    \x89\x01//////////////////////////////////////////////////////////////\n\
    /\x20Products\n/////////////////////////////////////////////////////////\
    /////\n\n\x0b\n\x03\x04\r\x01\x12\x04\xd8\x01\x08\x15\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\xda\x01\x04\x19\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xda\x01\
    \x04\n\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xda\x01\x0b\x14\n\r\n\x05\x04\r\
    \x02\0\x03\x12\x04\xda\x01\x17\x18\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xdb\
    \x01\x04\x1b\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xdb\x01\x04\t\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\xdb\x01\n\x16\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\xdb\x01\x19\x1a\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xdc\x01\x04\x1a\n\
    \r\n\x05\x04\r\x02\x02\x05\x12\x04\xdc\x01\x04\t\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\xdc\x01\n\x15\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xdc\x01\
    \x18\x19\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xdd\x01\x04\x1b\n\r\n\x05\x04\
    \r\x02\x03\x05\x12\x04\xdd\x01\x04\x08\n\r\n\x05\x04\r\x02\x03\x01\x12\
    \x04\xdd\x01\t\x16\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xdd\x01\x19\x1a\n\
    \x0c\n\x02\x04\x0e\x12\x06\xe0\x01\0\xf1\x01\x01\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xe0\x01\x08\x15\nl\n\x04\x04\x0e\x02\0\x12\x04\xe2\x01\x04\x1a\
    \"^\x20The\x20client\x20will\x20only\x20set\x20productID,\x20but\x20when\
    \x20return\x20from\x20the\x20server,\x20it\x20must\x20set\x20all\x20fiel\
    ds.\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xe2\x01\x04\r\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\xe2\x01\x0e\x15\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\xe2\x01\x18\x19\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xe3\x01\x04\x1d\
    \n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xe3\x01\x04\n\n\r\n\x05\x04\x0e\
    \x02\x01\x01\x12\x04\xe3\x01\x0b\x18\n\r\n\x05\x04\x0e\x02\x01\x03\x12\
    \x04\xe3\x01\x1b\x1c\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xe4\x01\x04\x17\
    \n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xe4\x01\x04\n\n\r\n\x05\x04\x0e\
    \x02\x02\x01\x12\x04\xe4\x01\x0b\x12\n\r\n\x05\x04\x0e\x02\x02\x03\x12\
    \x04\xe4\x01\x15\x16\n\x20\n\x04\x04\x0e\x02\x03\x12\x04\xe7\x01\x04\x13\
    \x1a\x12\x20Filled\x20by\x20server\n\n\r\n\x05\x04\x0e\x02\x03\x05\x12\
    \x04\xe7\x01\x04\x08\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xe7\x01\t\x0e\
    \n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xe7\x01\x11\x12\n\x0c\n\x04\x04\
    \x0e\x02\x04\x12\x04\xe8\x01\x04\x1e\n\r\n\x05\x04\x0e\x02\x04\x05\x12\
    \x04\xe8\x01\x04\x08\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xe8\x01\t\x19\
    \n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xe8\x01\x1c\x1d\n)\n\x04\x04\x0e\
    \x02\x05\x12\x04\xea\x01\x04\x1a\"\x1b\x20coupon/promotion/bonus...\n\n\
    \r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xea\x01\x04\n\n\r\n\x05\x04\x0e\x02\
    \x05\x01\x12\x04\xea\x01\x0b\x15\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\
    \xea\x01\x18\x19\n6\n\x04\x04\x0e\x02\x06\x12\x04\xec\x01\x04\x15\"(rece\
    ipt\x20verify\x20status\x20returned\x20by\x20Apple\n\n\r\n\x05\x04\x0e\
    \x02\x06\x05\x12\x04\xec\x01\x04\t\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\
    \xec\x01\n\x10\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xec\x01\x13\x14\n\
    \x0c\n\x04\x04\x0e\x02\x07\x12\x04\xee\x01\x04\x16\n\r\n\x05\x04\x0e\x02\
    \x07\x05\x12\x04\xee\x01\x04\x08\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\
    \xee\x01\t\x11\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xee\x01\x14\x15\n\
    \x0c\n\x04\x04\x0e\x02\x08\x12\x04\xf0\x01\x04)\n\r\n\x05\x04\x0e\x02\
    \x08\x06\x12\x04\xf0\x01\x04\x11\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\
    \xf0\x01\x12$\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\xf0\x01'(\n\x0c\n\
    \x02\x04\x0f\x12\x06\xf3\x01\0\xf6\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\xf3\x01\x08$\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xf5\x01\x04\"\n\r\n\
    \x05\x04\x0f\x02\0\x06\x12\x04\xf5\x01\x04\x11\n\r\n\x05\x04\x0f\x02\0\
    \x01\x12\x04\xf5\x01\x12\x1d\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf5\x01\
    \x20!\n\x0c\n\x02\x04\x10\x12\x06\xf8\x01\0\xfc\x01\x01\n\x0b\n\x03\x04\
    \x10\x01\x12\x04\xf8\x01\x08\"\n;\n\x04\x04\x10\x02\0\x12\x04\xfa\x01\
    \x04,\"-\x20There\x20may\x20be\x20several\x20transactions\x20succeeded\n\
    \n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xfa\x01\x04\x0c\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xfa\x01\r\x1a\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xfa\
    \x01\x1b'\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xfa\x01*+\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xfb\x01\x04\x1a\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xfb\x01\x04\r\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xfb\x01\x0e\x15\
    \n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xfb\x01\x18\x19\nH\n\x02\x04\x11\
    \x12\x06\xff\x01\0\x82\x02\x01\x1a:/\x20Refactor\x20using\x20https://git\
    hub.com/bizz84/SwiftyStoreKit\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xff\x01\
    \x08#\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x81\x02\x04\x16\n\r\n\x05\x04\
    \x11\x02\0\x05\x12\x04\x81\x02\x04\t\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\
    \x81\x02\n\x11\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x81\x02\x14\x15\n\x0c\
    \n\x02\x05\x04\x12\x06\x84\x02\0\x8a\x02\x01\n\x0b\n\x03\x05\x04\x01\x12\
    \x04\x84\x02\x05\x1f\n1\n\x04\x05\x04\x02\0\x12\x04\x86\x02\x04\x15\"#\
    \x20\xe4\xbb\x8e\xe6\xb2\xa1\xe8\x8a\xb1\xe8\xbf\x87\xe9\x92\xb1\xef\xbc\
    \x8c\xe4\xb9\x9f\xe6\xb2\xa1\xe8\xaf\x95\xe7\x94\xa8\xe8\xbf\x87\n\n\r\n\
    \x05\x05\x04\x02\0\x01\x12\x04\x86\x02\x04\x10\n\r\n\x05\x05\x04\x02\0\
    \x02\x12\x04\x86\x02\x13\x14\n\x1c\n\x04\x05\x04\x02\x01\x12\x04\x87\x02\
    \x04\x13\"\x0e\x20\xe5\xbd\x93\xe5\x89\x8d\xe6\x98\xafVIP\n\n\r\n\x05\
    \x05\x04\x02\x01\x01\x12\x04\x87\x02\x04\x0e\n\r\n\x05\x05\x04\x02\x01\
    \x02\x12\x04\x87\x02\x11\x12\nR\n\x04\x05\x04\x02\x02\x12\x04\x88\x02\
    \x04\x10\"D\x20\xe4\xb9\x8b\xe5\x89\x8d\xe8\xae\xa2\xe9\x98\x85\xe8\xbf\
    \x87\xef\xbc\x88\xe5\x8c\x85\xe6\x8b\xac\xe8\xaf\x95\xe7\x94\xa8\xe7\x9a\
    \x84\xe5\xbd\xa2\xe5\xbc\x8f\xef\xbc\x89\xef\xbc\x8c\xe7\x8e\xb0\xe5\x9c\
    \xa8\xe6\xb2\xa1\xe6\x9c\x89\xe8\xae\xa2\xe9\x98\x85\xe4\xba\x86\n\n\r\n\
    \x05\x05\x04\x02\x02\x01\x12\x04\x88\x02\x04\x0b\n\r\n\x05\x05\x04\x02\
    \x02\x02\x12\x04\x88\x02\x0e\x0f\n\x13\n\x04\x05\x04\x02\x03\x12\x04\x89\
    \x02\x04\x15\"\x05\x20...\n\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\x89\
    \x02\x04\x10\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\x89\x02\x13\x14\n\x0c\
    \n\x02\x04\x12\x12\x06\x8c\x02\0\x94\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\x8c\x02\x08!\n\x81\x01\n\x04\x04\x12\x02\0\x12\x04\x8e\x02\x04*\"s\
    \x20\xe5\x8f\xaa\xe6\x9c\x89\xe8\xbf\x99\xe9\x87\x8c\xe7\xad\x89\xe4\xba\
    \x8esubscribed\xef\xbc\x8c\xe4\xb8\x8b\xe9\x9d\xa2\x20\x20expiryTimestam\
    p,\x20isInFreeTrial,\x20billingCycle,\x20productID\x20\xe5\xad\x97\xe6\
    \xae\xb5\xe6\x89\x8d\xe6\x9c\x89\xe6\x84\x8f\xe4\xb9\x89\n\n\r\n\x05\x04\
    \x12\x02\0\x06\x12\x04\x8e\x02\x04\x1e\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\x8e\x02\x1f%\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x8e\x02()\n\x0c\n\
    \x04\x04\x12\x02\x01\x12\x04\x8f\x02\x04\x1e\n\r\n\x05\x04\x12\x02\x01\
    \x05\x12\x04\x8f\x02\x04\t\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x8f\x02\
    \n\x19\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x8f\x02\x1c\x1d\n(\n\x04\
    \x04\x12\x02\x02\x12\x04\x90\x02\x04\x1b\"\x1a\x20\xe8\xaf\x95\xe7\x94\
    \xa8\xe6\x9c\x9f\xe8\xae\xa8\xe5\xa5\xbd\xe5\xae\xa2\xe6\x88\xb7\xe7\x94\
    \xa8\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\x90\x02\x04\x08\n\r\n\x05\
    \x04\x12\x02\x02\x01\x12\x04\x90\x02\t\x16\n\r\n\x05\x04\x12\x02\x02\x03\
    \x12\x04\x90\x02\x19\x1a\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\x91\x02\x04\
    \"\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\x91\x02\x04\x10\n\r\n\x05\x04\
    \x12\x02\x03\x01\x12\x04\x91\x02\x11\x1d\n\r\n\x05\x04\x12\x02\x03\x03\
    \x12\x04\x91\x02\x20!\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\x92\x02\x04\
    \x17\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\x92\x02\x04\x08\n\r\n\x05\x04\
    \x12\x02\x04\x01\x12\x04\x92\x02\t\x12\n\r\n\x05\x04\x12\x02\x04\x03\x12\
    \x04\x92\x02\x15\x16\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\x93\x02\x04\x19\
    \n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\x93\x02\x04\n\n\r\n\x05\x04\x12\
    \x02\x05\x01\x12\x04\x93\x02\x0b\x14\n\r\n\x05\x04\x12\x02\x05\x03\x12\
    \x04\x93\x02\x17\x18\n\x0c\n\x02\x04\x13\x12\x06\x96\x02\0\xa0\x02\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\x96\x02\x08*\n\x0e\n\x04\x04\x13\x03\0\
    \x12\x06\x98\x02\x04\x9e\x02\x05\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\x98\
    \x02\x0c\x14\n\x0e\n\x06\x04\x13\x03\0\x02\0\x12\x04\x99\x02\x08\x1b\n\
    \x0f\n\x07\x04\x13\x03\0\x02\0\x05\x12\x04\x99\x02\x08\x0e\n\x0f\n\x07\
    \x04\x13\x03\0\x02\0\x01\x12\x04\x99\x02\x0f\x16\n\x0f\n\x07\x04\x13\x03\
    \0\x02\0\x03\x12\x04\x99\x02\x19\x1a\n\x0e\n\x06\x04\x13\x03\0\x02\x01\
    \x12\x04\x9a\x02\x08\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x05\x12\x04\
    \x9a\x02\x08\x0e\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x01\x12\x04\x9a\x02\
    \x0f\x1a\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x03\x12\x04\x9a\x02\x1d\x1e\n\
    \x0e\n\x06\x04\x13\x03\0\x02\x02\x12\x04\x9b\x02\x08\x1d\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x02\x05\x12\x04\x9b\x02\x08\x0e\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x02\x01\x12\x04\x9b\x02\x0f\x18\n\x0f\n\x07\x04\x13\x03\0\x02\x02\
    \x03\x12\x04\x9b\x02\x1b\x1c\n\x0e\n\x06\x04\x13\x03\0\x02\x03\x12\x04\
    \x9c\x02\x08\x1f\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x05\x12\x04\x9c\x02\
    \x08\r\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x01\x12\x04\x9c\x02\x0e\x1a\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x03\x03\x12\x04\x9c\x02\x1d\x1e\n\x0e\n\x06\
    \x04\x13\x03\0\x02\x04\x12\x04\x9d\x02\x08!\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x04\x05\x12\x04\x9d\x02\x08\x0e\n\x0f\n\x07\x04\x13\x03\0\x02\x04\
    \x01\x12\x04\x9d\x02\x0f\x1c\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x03\x12\
    \x04\x9d\x02\x1f\x20\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x9f\x02\x04$\n\r\
    \n\x05\x04\x13\x02\0\x04\x12\x04\x9f\x02\x04\x0c\n\r\n\x05\x04\x13\x02\0\
    \x06\x12\x04\x9f\x02\r\x15\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x9f\x02\
    \x16\x1f\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x9f\x02\"#\n\x0c\n\x02\x04\
    \x14\x12\x06\xa2\x02\0\xaa\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xa2\
    \x02\x08(\n\x81\x01\n\x04\x04\x14\x02\0\x12\x04\xa4\x02\x04*\"s\x20\xe5\
    \x8f\xaa\xe6\x9c\x89\xe8\xbf\x99\xe9\x87\x8c\xe7\xad\x89\xe4\xba\x8esubs\
    cribed\xef\xbc\x8c\xe4\xb8\x8b\xe9\x9d\xa2\x20\x20expiryTimestamp,\x20is\
    InFreeTrial,\x20billingCycle,\x20productID\x20\xe5\xad\x97\xe6\xae\xb5\
    \xe6\x89\x8d\xe6\x9c\x89\xe6\x84\x8f\xe4\xb9\x89\n\n\r\n\x05\x04\x14\x02\
    \0\x06\x12\x04\xa4\x02\x04\x1e\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xa4\
    \x02\x1f%\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa4\x02()\n\x0c\n\x04\x04\
    \x14\x02\x01\x12\x04\xa5\x02\x04\x1e\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\xa5\x02\x04\t\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xa5\x02\n\x19\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\xa5\x02\x1c\x1d\n(\n\x04\x04\x14\
    \x02\x02\x12\x04\xa6\x02\x04\x1b\"\x1a\x20\xe8\xaf\x95\xe7\x94\xa8\xe6\
    \x9c\x9f\xe8\xae\xa8\xe5\xa5\xbd\xe5\xae\xa2\xe6\x88\xb7\xe7\x94\xa8\n\n\
    \r\n\x05\x04\x14\x02\x02\x05\x12\x04\xa6\x02\x04\x08\n\r\n\x05\x04\x14\
    \x02\x02\x01\x12\x04\xa6\x02\t\x16\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \xa6\x02\x19\x1a\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xa7\x02\x04\"\n\r\n\
    \x05\x04\x14\x02\x03\x06\x12\x04\xa7\x02\x04\x10\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xa7\x02\x11\x1d\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\
    \xa7\x02\x20!\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xa8\x02\x04\x17\n\r\n\
    \x05\x04\x14\x02\x04\x05\x12\x04\xa8\x02\x04\x08\n\r\n\x05\x04\x14\x02\
    \x04\x01\x12\x04\xa8\x02\t\x12\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xa8\
    \x02\x15\x16\n\x0c\n\x04\x04\x14\x02\x05\x12\x04\xa9\x02\x04\x19\n\r\n\
    \x05\x04\x14\x02\x05\x05\x12\x04\xa9\x02\x04\n\n\r\n\x05\x04\x14\x02\x05\
    \x01\x12\x04\xa9\x02\x0b\x14\n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\xa9\
    \x02\x17\x18\n\x0c\n\x02\x04\x15\x12\x06\xac\x02\0\xaf\x02\x01\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xac\x02\x08)\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xae\x02\x04%\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xae\x02\x04\n\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\xae\x02\x0b\x20\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\xae\x02#$\n\x0c\n\x02\x04\x16\x12\x06\xb1\x02\0\xb7\x02\x01\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\xb1\x02\x08\x1a\n\x0c\n\x04\x04\x16\x02\
    \0\x12\x04\xb3\x02\x04\x19\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xb3\x02\
    \x04\n\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb3\x02\x0b\x14\n\r\n\x05\x04\
    \x16\x02\0\x03\x12\x04\xb3\x02\x17\x18\n\x0c\n\x04\x04\x16\x02\x01\x12\
    \x04\xb4\x02\x04\x18\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xb4\x02\x04\t\
    \n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xb4\x02\n\x13\n\r\n\x05\x04\x16\
    \x02\x01\x03\x12\x04\xb4\x02\x16\x17\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\
    \xb5\x02\x04\x14\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xb5\x02\x04\t\n\r\
    \n\x05\x04\x16\x02\x02\x01\x12\x04\xb5\x02\n\x0f\n\r\n\x05\x04\x16\x02\
    \x02\x03\x12\x04\xb5\x02\x12\x13\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\xb6\
    \x02\x04\x14\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xb6\x02\x04\t\n\r\n\
    \x05\x04\x16\x02\x03\x01\x12\x04\xb6\x02\n\x0f\n\r\n\x05\x04\x16\x02\x03\
    \x03\x12\x04\xb6\x02\x12\x13\n\x0c\n\x02\x04\x17\x12\x06\xb9\x02\0\xbd\
    \x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xb9\x02\x08'\n\x0c\n\x04\x04\
    \x17\x02\0\x12\x04\xbb\x02\x04!\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xbb\
    \x02\x04\x16\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xbb\x02\x17\x1c\n\r\n\
    \x05\x04\x17\x02\0\x03\x12\x04\xbb\x02\x1f\x20\n\x0c\n\x04\x04\x17\x02\
    \x01\x12\x04\xbc\x02\x04\x14\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xbc\
    \x02\x04\t\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xbc\x02\n\x0f\n\r\n\x05\
    \x04\x17\x02\x01\x03\x12\x04\xbc\x02\x12\x13\n\x0c\n\x02\x04\x18\x12\x06\
    \xbf\x02\0\xc4\x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xbf\x02\x08#\n\
    \x0c\n\x04\x04\x18\x02\0\x12\x04\xc1\x02\x04#\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xc1\x02\x04\n\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc1\x02\
    \x0b\x1e\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc1\x02!\"\n\x0c\n\x04\x04\
    \x18\x02\x01\x12\x04\xc2\x02\x04\x1a\n\r\n\x05\x04\x18\x02\x01\x05\x12\
    \x04\xc2\x02\x04\n\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc2\x02\x0b\x15\
    \n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc2\x02\x18\x19\n\x0c\n\x04\x04\
    \x18\x02\x02\x12\x04\xc3\x02\x041\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\
    \xc3\x02\x04\x0c\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xc3\x02\r\x13\n\r\
    \n\x05\x04\x18\x02\x02\x01\x12\x04\xc3\x02\x14,\n\r\n\x05\x04\x18\x02\
    \x02\x03\x12\x04\xc3\x02/0\n\x0c\n\x02\x04\x19\x12\x06\xc6\x02\0\xc9\x02\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xc6\x02\x08\"\n\x0c\n\x02\x04\x1a\
    \x12\x06\xcb\x02\0\xce\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xcb\x02\
    \x08\x20\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xcd\x02\x04)\n\r\n\x05\x04\
    \x1a\x02\0\x06\x12\x04\xcd\x02\x04\x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\xcd\x02\x18$\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xcd\x02'(\n\x0c\n\
    \x02\x04\x1b\x12\x06\xd0\x02\0\xd3\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xd0\x02\x08!\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xd2\x02\x04)\n\r\n\
    \x05\x04\x1b\x02\0\x06\x12\x04\xd2\x02\x04\x17\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xd2\x02\x18$\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xd2\x02'(\
    \n\x0c\n\x02\x04\x1c\x12\x06\xd5\x02\0\xd8\x02\x01\n\x0b\n\x03\x04\x1c\
    \x01\x12\x04\xd5\x02\x08\x1f\n\x19\n\x02\x04\x1d\x12\x06\xdc\x02\0\xe0\
    \x02\x012\x0b\x20[101-199]\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xdc\x02\x08\
    \x14\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xde\x02\x04\x19\n\r\n\x05\x04\x1d\
    \x02\0\x05\x12\x04\xde\x02\x04\t\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xde\
    \x02\n\x14\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xde\x02\x17\x18\n\x0c\n\
    \x04\x04\x1d\x02\x01\x12\x04\xdf\x02\x04\x17\n\r\n\x05\x04\x1d\x02\x01\
    \x05\x12\x04\xdf\x02\x04\t\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xdf\x02\
    \n\x12\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xdf\x02\x15\x16\n\xa4\x01\n\
    \x02\x05\x05\x12\x06\xe5\x02\0\xec\x02\x01\x1a\x95\x01//////////////////\
    ////////////////////////////////////////////\n/\x20App\x20unified\x20Mes\
    sages\n//////////////////////////////////////////////////////////////\n\
    \n\x0b\n\x03\x05\x05\x01\x12\x04\xe5\x02\x05\x10\n\x0c\n\x04\x05\x05\x02\
    \0\x12\x04\xe7\x02\x04\x18\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xe7\x02\
    \x04\x13\n\r\n\x05\x05\x05\x02\0\x02\x12\x04\xe7\x02\x16\x17\n\x0c\n\x04\
    \x05\x05\x02\x01\x12\x04\xe8\x02\x04\x18\n\r\n\x05\x05\x05\x02\x01\x01\
    \x12\x04\xe8\x02\x04\x13\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xe8\x02\
    \x16\x17\n\x0c\n\x04\x05\x05\x02\x02\x12\x04\xe9\x02\x04\x1b\n\r\n\x05\
    \x05\x05\x02\x02\x01\x12\x04\xe9\x02\x04\x16\n\r\n\x05\x05\x05\x02\x02\
    \x02\x12\x04\xe9\x02\x19\x1a\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\xea\x02\
    \x04\x1e\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\xea\x02\x04\x19\n\r\n\x05\
    \x05\x05\x02\x03\x02\x12\x04\xea\x02\x1c\x1d\n\x0c\n\x04\x05\x05\x02\x04\
    \x12\x04\xeb\x02\x04!\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\xeb\x02\x04\
    \x1c\n\r\n\x05\x05\x05\x02\x04\x02\x12\x04\xeb\x02\x1f\x20\n\x0c\n\x02\
    \x04\x1e\x12\x06\xee\x02\0\xf9\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \xee\x02\x08\x16\n\x15\n\x04\x04\x1e\x02\0\x12\x04\xf0\x02\x04\x1a\"\x07\
    \x201.0.0\n\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xf0\x02\x04\n\n\r\n\x05\
    \x04\x1e\x02\0\x01\x12\x04\xf0\x02\x0b\x15\n\r\n\x05\x04\x1e\x02\0\x03\
    \x12\x04\xf0\x02\x18\x19\n\x1d\n\x04\x04\x1e\x02\x01\x12\x04\xf1\x02\x04\
    \x1b\"\x0f\x20United\x20States\n\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\
    \xf1\x02\x04\n\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf1\x02\x0b\x16\n\r\
    \n\x05\x04\x1e\x02\x01\x03\x12\x04\xf1\x02\x19\x1a\n\x12\n\x04\x04\x1e\
    \x02\x02\x12\x04\xf2\x02\x04\x1b\"\x04\x20US\n\n\r\n\x05\x04\x1e\x02\x02\
    \x05\x12\x04\xf2\x02\x04\n\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xf2\x02\
    \x0b\x16\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xf2\x02\x19\x1a\n\x15\n\
    \x04\x04\x1e\x02\x03\x12\x04\xf3\x02\x04\x1d\"\x07\x20en-US\n\n\r\n\x05\
    \x04\x1e\x02\x03\x05\x12\x04\xf3\x02\x04\n\n\r\n\x05\x04\x1e\x02\x03\x01\
    \x12\x04\xf3\x02\x0b\x18\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xf3\x02\
    \x1b\x1c\n4\n\x04\x04\x1e\x02\x04\x12\x04\xf4\x02\x04\x14\"&\x20E036BBB7\
    -76DC-46CE-AA62-55CF182C5FAD\n\n\r\n\x05\x04\x1e\x02\x04\x05\x12\x04\xf4\
    \x02\x04\n\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\xf4\x02\x0b\x0f\n\r\n\
    \x05\x04\x1e\x02\x04\x03\x12\x04\xf4\x02\x12\x13\n\x1b\n\x04\x04\x1e\x02\
    \x05\x12\x04\xf5\x02\x04\x17\"\r\x208,\x20East\x208th\n\n\r\n\x05\x04\
    \x1e\x02\x05\x05\x12\x04\xf5\x02\x04\t\n\r\n\x05\x04\x1e\x02\x05\x01\x12\
    \x04\xf5\x02\n\x12\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xf5\x02\x15\x16\
    \n#\n\x04\x04\x1e\x02\x06\x12\x04\xf6\x02\x04\x1a\"\x15\x20account\x20in\
    formation\n\n\r\n\x05\x04\x1e\x02\x06\x06\x12\x04\xf6\x02\x04\r\n\r\n\
    \x05\x04\x1e\x02\x06\x01\x12\x04\xf6\x02\x0e\x15\n\r\n\x05\x04\x1e\x02\
    \x06\x03\x12\x04\xf6\x02\x18\x19\n\x0c\n\x04\x04\x1e\x02\x07\x12\x04\xf7\
    \x02\x04\x1e\n\r\n\x05\x04\x1e\x02\x07\x06\x12\x04\xf7\x02\x04\x0f\n\r\n\
    \x05\x04\x1e\x02\x07\x01\x12\x04\xf7\x02\x10\x19\n\r\n\x05\x04\x1e\x02\
    \x07\x03\x12\x04\xf7\x02\x1c\x1d\n\x0c\n\x04\x04\x1e\x02\x08\x12\x04\xf8\
    \x02\x04\x16\n\r\n\x05\x04\x1e\x02\x08\x05\x12\x04\xf8\x02\x04\n\n\r\n\
    \x05\x04\x1e\x02\x08\x01\x12\x04\xf8\x02\x0b\x11\n\r\n\x05\x04\x1e\x02\
    \x08\x03\x12\x04\xf8\x02\x14\x15\n\x0c\n\x02\x04\x1f\x12\x06\xfb\x02\0\
    \xff\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xfb\x02\x08\x14\n\x0c\n\x04\
    \x04\x1f\x02\0\x12\x04\xfd\x02\x04\x17\n\r\n\x05\x04\x1f\x02\0\x05\x12\
    \x04\xfd\x02\x04\t\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xfd\x02\n\x12\n\r\
    \n\x05\x04\x1f\x02\0\x03\x12\x04\xfd\x02\x15\x16\n\x0c\n\x04\x04\x1f\x02\
    \x01\x12\x04\xfe\x02\x04\x16\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xfe\
    \x02\x04\x08\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xfe\x02\t\x11\n\r\n\
    \x05\x04\x1f\x02\x01\x03\x12\x04\xfe\x02\x14\x15\n\x0c\n\x02\x04\x20\x12\
    \x06\x81\x03\0\x84\x03\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x81\x03\x08\
    \x17\n\x0c\n\x02\x04!\x12\x06\x86\x03\0\x89\x03\x01\n\x0b\n\x03\x04!\x01\
    \x12\x04\x86\x03\x08\x15\n\x0c\n\x02\x04\"\x12\x06\x8b\x03\0\x90\x03\x01\
    \n\x0b\n\x03\x04\"\x01\x12\x04\x8b\x03\x08\"\n\x0c\n\x04\x04\"\x02\0\x12\
    \x04\x8d\x03\x04\x1a\n\r\n\x05\x04\"\x02\0\x06\x12\x04\x8d\x03\x04\r\n\r\
    \n\x05\x04\"\x02\0\x01\x12\x04\x8d\x03\x0e\x15\n\r\n\x05\x04\"\x02\0\x03\
    \x12\x04\x8d\x03\x18\x19\n\x0c\n\x04\x04\"\x02\x01\x12\x04\x8e\x03\x04\
    \x1e\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\x8e\x03\x04\x0f\n\r\n\x05\x04\"\
    \x02\x01\x01\x12\x04\x8e\x03\x10\x19\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\
    \x8e\x03\x1c\x1d\n\x0c\n\x04\x04\"\x02\x02\x12\x04\x8f\x03\x04\x1a\n\r\n\
    \x05\x04\"\x02\x02\x05\x12\x04\x8f\x03\x04\n\n\r\n\x05\x04\"\x02\x02\x01\
    \x12\x04\x8f\x03\x0b\x15\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x8f\x03\x18\
    \x19\n\x0c\n\x02\x04#\x12\x06\x92\x03\0\x96\x03\x01\n\x0b\n\x03\x04#\x01\
    \x12\x04\x92\x03\x08\x20\n\x0c\n\x04\x04#\x02\0\x12\x04\x94\x03\x04\x17\
    \n\r\n\x05\x04#\x02\0\x05\x12\x04\x94\x03\x04\t\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\x94\x03\n\x12\n\r\n\x05\x04#\x02\0\x03\x12\x04\x94\x03\x15\x16\
    \n\x0c\n\x04\x04#\x02\x01\x12\x04\x95\x03\x04\x16\n\r\n\x05\x04#\x02\x01\
    \x05\x12\x04\x95\x03\x04\x08\n\r\n\x05\x04#\x02\x01\x01\x12\x04\x95\x03\
    \t\x11\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x95\x03\x14\x15\n\xd9\x01\n\
    \x02\x05\x06\x12\x06\x9d\x03\0\xa6\x03\x012\xca\x01/////////////////////\
    /////////////////////////////////////////\n/\x20Products\n//////////////\
    ////////////////////////////////////////////////\n\x20Check\x20out:\x20h\
    ttps://developer.apple.com/app-store/subscriptions/\n\n\x0b\n\x03\x05\
    \x06\x01\x12\x04\x9d\x03\x05\x11\n\x0c\n\x04\x05\x06\x02\0\x12\x04\x9f\
    \x03\x04\x0f\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\x9f\x03\x04\n\n\r\n\x05\
    \x05\x06\x02\0\x02\x12\x04\x9f\x03\r\x0e\n\x0c\n\x04\x05\x06\x02\x01\x12\
    \x04\xa0\x03\x04\x11\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xa0\x03\x04\
    \x0c\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\xa0\x03\x0f\x10\n\x0c\n\x04\
    \x05\x06\x02\x02\x12\x04\xa1\x03\x04\x11\n\r\n\x05\x05\x06\x02\x02\x01\
    \x12\x04\xa1\x03\x04\x0c\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\xa1\x03\
    \x0f\x10\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\xa2\x03\x04\x13\n\r\n\x05\
    \x05\x06\x02\x03\x01\x12\x04\xa2\x03\x04\x0e\n\r\n\x05\x05\x06\x02\x03\
    \x02\x12\x04\xa2\x03\x11\x12\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\xa3\x03\
    \x04\x13\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xa3\x03\x04\x0e\n\r\n\x05\
    \x05\x06\x02\x04\x02\x12\x04\xa3\x03\x11\x12\n\x0c\n\x04\x05\x06\x02\x05\
    \x12\x04\xa4\x03\x04\x0f\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\xa4\x03\
    \x04\n\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xa4\x03\r\x0e\n/\n\x04\x05\
    \x06\x02\x06\x12\x04\xa5\x03\x04\x11\"!\x20Can\x20be\x20used\x20for\x20n\
    on-consumables\n\n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\xa5\x03\x04\x0c\n\
    \r\n\x05\x05\x06\x02\x06\x02\x12\x04\xa5\x03\x0f\x10\n\x0c\n\x02\x05\x07\
    \x12\x06\xa8\x03\0\xad\x03\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\xa8\x03\
    \x05#\n%\n\x04\x05\x07\x02\0\x12\x04\xaa\x03\x04\x12\"\x17\x20Normally\
    \x20we\x20use\x20this.\n\n\r\n\x05\x05\x07\x02\0\x01\x12\x04\xaa\x03\x04\
    \r\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\xaa\x03\x10\x11\n\x0c\n\x04\x05\
    \x07\x02\x01\x12\x04\xab\x03\x04\x13\n\r\n\x05\x05\x07\x02\x01\x01\x12\
    \x04\xab\x03\x04\x0e\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\xab\x03\x11\
    \x12\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\xac\x03\x04\x13\n\r\n\x05\x05\
    \x07\x02\x02\x01\x12\x04\xac\x03\x04\x0e\n\r\n\x05\x05\x07\x02\x02\x02\
    \x12\x04\xac\x03\x11\x12\n\x0c\n\x02\x04$\x12\x06\xaf\x03\0\xb4\x03\x01\
    \n\x0b\n\x03\x04$\x01\x12\x04\xaf\x03\x08\x19\n\x0c\n\x04\x04$\x02\0\x12\
    \x04\xb1\x03\x045\n\r\n\x05\x04$\x02\0\x06\x12\x04\xb1\x03\x04\"\n\r\n\
    \x05\x04$\x02\0\x01\x12\x04\xb1\x03#0\n\r\n\x05\x04$\x02\0\x03\x12\x04\
    \xb1\x0334\nF\n\x04\x04$\x02\x01\x12\x04\xb2\x03\x04\x1d\"8\x20To\x20exp\
    ress\x201\x20month\x20=\x2030,\x20half\x20year\x20=\x20180,\x201\x20year\
    \x20=\x20365\n\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xb2\x03\x04\t\n\r\n\
    \x05\x04$\x02\x01\x01\x12\x04\xb2\x03\n\x18\n\r\n\x05\x04$\x02\x01\x03\
    \x12\x04\xb2\x03\x1b\x1c\n\x0c\n\x04\x04$\x02\x02\x12\x04\xb3\x03\x04\
    \x1a\n\r\n\x05\x04$\x02\x02\x05\x12\x04\xb3\x03\x04\n\n\r\n\x05\x04$\x02\
    \x02\x01\x12\x04\xb3\x03\x0b\x15\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xb3\
    \x03\x18\x19\n\x0c\n\x02\x04%\x12\x06\xb6\x03\0\xb9\x03\x01\n\x0b\n\x03\
    \x04%\x01\x12\x04\xb6\x03\x08\x18\n\xb3\x01\n\x02\x04&\x12\x06\xbd\x03\0\
    \xc7\x03\x01\x1a\xa4\x01\x20PBProduct\x20must\x20fully\x20reflects\x20th\
    e\x20setting\x20in\x20ITC\x20and\x20in\x20sync\n\x20To\x20support\x20old\
    \x20versions\x20of\x20F+,\x20all\x20fields\x20including\x20`deprecated`\
    \x20must\x20be\x20filled\x20with\x20correct\x20values.\n\n\x0b\n\x03\x04\
    &\x01\x12\x04\xbd\x03\x08\x11\n\x0c\n\x04\x04&\x02\0\x12\x04\xbf\x03\x04\
    \x19\n\r\n\x05\x04&\x02\0\x05\x12\x04\xbf\x03\x04\n\n\r\n\x05\x04&\x02\0\
    \x01\x12\x04\xbf\x03\x0b\x14\n\r\n\x05\x04&\x02\0\x03\x12\x04\xbf\x03\
    \x17\x18\n\x0c\n\x04\x04&\x02\x01\x12\x04\xc0\x03\x04&\n\r\n\x05\x04&\
    \x02\x01\x05\x12\x04\xc0\x03\x04\t\n\r\n\x05\x04&\x02\x01\x01\x12\x04\
    \xc0\x03\n\x0f\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc0\x03\x12\x13\n\r\n\
    \x05\x04&\x02\x01\x08\x12\x04\xc0\x03\x14%\n\x0e\n\x06\x04&\x02\x01\x08\
    \x03\x12\x04\xc0\x03\x15$\n\x0c\n\x04\x04&\x02\x02\x12\x04\xc1\x03\x04'\
    \n\r\n\x05\x04&\x02\x02\x05\x12\x04\xc1\x03\x04\t\n\r\n\x05\x04&\x02\x02\
    \x01\x12\x04\xc1\x03\n\x10\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xc1\x03\
    \x13\x14\n\r\n\x05\x04&\x02\x02\x08\x12\x04\xc1\x03\x15&\n\x0e\n\x06\x04\
    &\x02\x02\x08\x03\x12\x04\xc1\x03\x16%\n\x0c\n\x04\x04&\x02\x03\x12\x04\
    \xc2\x03\x04\"\n\r\n\x05\x04&\x02\x03\x06\x12\x04\xc2\x03\x04\x10\n\r\n\
    \x05\x04&\x02\x03\x01\x12\x04\xc2\x03\x11\x1d\n\r\n\x05\x04&\x02\x03\x03\
    \x12\x04\xc2\x03\x20!\n\x14\n\x04\x04&\x02\x04\x12\x04\xc3\x03\x04\"\"\
    \x06$4.99\n\n\r\n\x05\x04&\x02\x04\x05\x12\x04\xc3\x03\x04\n\n\r\n\x05\
    \x04&\x02\x04\x01\x12\x04\xc3\x03\x0b\x1d\n\r\n\x05\x04&\x02\x04\x03\x12\
    \x04\xc3\x03\x20!\nL\n\x04\x04&\x02\x05\x12\x04\xc4\x03\x04\"\">70\x20me\
    ans\x2070%\x20OFF.\x20We\x20hard\x20code\x20this\x20to\x20make\x20it\x20\
    more\x20flexible.\n\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xc4\x03\x04\t\n\r\
    \n\x05\x04&\x02\x05\x01\x12\x04\xc4\x03\n\x1d\n\r\n\x05\x04&\x02\x05\x03\
    \x12\x04\xc4\x03\x20!\n\x0c\n\x04\x04&\x02\x06\x12\x04\xc6\x03\x04,\n\r\
    \n\x05\x04&\x02\x06\x06\x12\x04\xc6\x03\x04\x15\n\r\n\x05\x04&\x02\x06\
    \x01\x12\x04\xc6\x03\x16'\n\r\n\x05\x04&\x02\x06\x03\x12\x04\xc6\x03*+\n\
    \x0c\n\x02\x04'\x12\x06\xc9\x03\0\xcc\x03\x01\n\x0b\n\x03\x04'\x01\x12\
    \x04\xc9\x03\x08\x1e\n\x0c\n\x04\x04'\x02\0\x12\x04\xcb\x03\x04\x1a\n\r\
    \n\x05\x04'\x02\0\x05\x12\x04\xcb\x03\x04\n\n\r\n\x05\x04'\x02\0\x01\x12\
    \x04\xcb\x03\x0b\x15\n\r\n\x05\x04'\x02\0\x03\x12\x04\xcb\x03\x18\x19\n\
    \x0c\n\x02\x04(\x12\x06\xce\x03\0\xd1\x03\x01\n\x0b\n\x03\x04(\x01\x12\
    \x04\xce\x03\x08\x1c\n\x0c\n\x04\x04(\x02\0\x12\x04\xd0\x03\x04$\n\r\n\
    \x05\x04(\x02\0\x04\x12\x04\xd0\x03\x04\x0c\n\r\n\x05\x04(\x02\0\x06\x12\
    \x04\xd0\x03\r\x16\n\r\n\x05\x04(\x02\0\x01\x12\x04\xd0\x03\x17\x1f\n\r\
    \n\x05\x04(\x02\0\x03\x12\x04\xd0\x03\"#\n\x9a\x01\n\x02\x04)\x12\x06\
    \xd6\x03\0\xfd\x03\x01\x1a\x8b\x01//////////////////////////////////////\
    ////////////////////////\n/\x20Basic\x20Data\n//////////////////////////\
    ////////////////////////////////////\n\n\x0b\n\x03\x04)\x01\x12\x04\xd6\
    \x03\x08\x11\n\x0c\n\x04\x04)\x02\0\x12\x04\xd8\x03\x04\x19\n\r\n\x05\
    \x04)\x02\0\x05\x12\x04\xd8\x03\x04\n\n\r\n\x05\x04)\x02\0\x01\x12\x04\
    \xd8\x03\x0b\x14\n\r\n\x05\x04)\x02\0\x03\x12\x04\xd8\x03\x17\x18\n\x0c\
    \n\x04\x04)\x02\x01\x12\x04\xd9\x03\x04\x18\n\r\n\x05\x04)\x02\x01\x05\
    \x12\x04\xd9\x03\x04\n\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xd9\x03\x0b\
    \x13\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xd9\x03\x16\x17\n\x0c\n\x04\x04)\
    \x02\x02\x12\x04\xda\x03\x04\x18\n\r\n\x05\x04)\x02\x02\x05\x12\x04\xda\
    \x03\x04\n\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xda\x03\x0b\x13\n\r\n\x05\
    \x04)\x02\x02\x03\x12\x04\xda\x03\x16\x17\n\x0c\n\x04\x04)\x02\x03\x12\
    \x04\xdc\x03\x04\x1e\n\r\n\x05\x04)\x02\x03\x05\x12\x04\xdc\x03\x04\x08\
    \n\r\n\x05\x04)\x02\x03\x01\x12\x04\xdc\x03\t\x19\n\r\n\x05\x04)\x02\x03\
    \x03\x12\x04\xdc\x03\x1c\x1d\n\x0c\n\x04\x04)\x02\x04\x12\x04\xde\x03\
    \x04\x19\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xde\x03\x04\t\n\r\n\x05\x04)\
    \x02\x04\x01\x12\x04\xde\x03\n\x14\n\r\n\x05\x04)\x02\x04\x03\x12\x04\
    \xde\x03\x17\x18\n\x0c\n\x04\x04)\x02\x05\x12\x04\xdf\x03\x04\x1d\n\r\n\
    \x05\x04)\x02\x05\x05\x12\x04\xdf\x03\x04\t\n\r\n\x05\x04)\x02\x05\x01\
    \x12\x04\xdf\x03\n\x18\n\r\n\x05\x04)\x02\x05\x03\x12\x04\xdf\x03\x1b\
    \x1c\n\x0c\n\x04\x04)\x02\x06\x12\x04\xe0\x03\x04\x1c\n\r\n\x05\x04)\x02\
    \x06\x05\x12\x04\xe0\x03\x04\t\n\r\n\x05\x04)\x02\x06\x01\x12\x04\xe0\
    \x03\n\x17\n\r\n\x05\x04)\x02\x06\x03\x12\x04\xe0\x03\x1a\x1b\n\x0c\n\
    \x04\x04)\x02\x07\x12\x04\xe2\x03\x04\x18\n\r\n\x05\x04)\x02\x07\x05\x12\
    \x04\xe2\x03\x04\n\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xe2\x03\x0b\x13\n\
    \r\n\x05\x04)\x02\x07\x03\x12\x04\xe2\x03\x16\x17\n\x0c\n\x04\x04)\x02\
    \x08\x12\x04\xe3\x03\x04\x1f\n\r\n\x05\x04)\x02\x08\x05\x12\x04\xe3\x03\
    \x04\n\n\r\n\x05\x04)\x02\x08\x01\x12\x04\xe3\x03\x0b\x1a\n\r\n\x05\x04)\
    \x02\x08\x03\x12\x04\xe3\x03\x1d\x1e\n\x0c\n\x04\x04)\x02\t\x12\x04\xe5\
    \x03\x04\x16\n\r\n\x05\x04)\x02\t\x05\x12\x04\xe5\x03\x04\t\n\r\n\x05\
    \x04)\x02\t\x01\x12\x04\xe5\x03\n\x10\n\r\n\x05\x04)\x02\t\x03\x12\x04\
    \xe5\x03\x13\x15\n\x0c\n\x04\x04)\x02\n\x12\x04\xe6\x03\x04\x1d\n\r\n\
    \x05\x04)\x02\n\x05\x12\x04\xe6\x03\x04\n\n\r\n\x05\x04)\x02\n\x01\x12\
    \x04\xe6\x03\x0b\x17\n\r\n\x05\x04)\x02\n\x03\x12\x04\xe6\x03\x1a\x1c\n\
    \x0c\n\x04\x04)\x02\x0b\x12\x04\xe7\x03\x04\x1a\n\r\n\x05\x04)\x02\x0b\
    \x05\x12\x04\xe7\x03\x04\n\n\r\n\x05\x04)\x02\x0b\x01\x12\x04\xe7\x03\
    \x0b\x14\n\r\n\x05\x04)\x02\x0b\x03\x12\x04\xe7\x03\x17\x19\n\x0c\n\x04\
    \x04)\x02\x0c\x12\x04\xe8\x03\x04!\n\r\n\x05\x04)\x02\x0c\x05\x12\x04\
    \xe8\x03\x04\n\n\r\n\x05\x04)\x02\x0c\x01\x12\x04\xe8\x03\x0b\x1b\n\r\n\
    \x05\x04)\x02\x0c\x03\x12\x04\xe8\x03\x1e\x20\n\x0c\n\x04\x04)\x02\r\x12\
    \x04\xea\x03\x04\x1c\n\r\n\x05\x04)\x02\r\x05\x12\x04\xea\x03\x04\n\n\r\
    \n\x05\x04)\x02\r\x01\x12\x04\xea\x03\x0b\x16\n\r\n\x05\x04)\x02\r\x03\
    \x12\x04\xea\x03\x19\x1b\n\x0c\n\x04\x04)\x02\x0e\x12\x04\xeb\x03\x04\
    \x1d\n\r\n\x05\x04)\x02\x0e\x06\x12\x04\xeb\x03\x04\x0e\n\r\n\x05\x04)\
    \x02\x0e\x01\x12\x04\xeb\x03\x0f\x17\n\r\n\x05\x04)\x02\x0e\x03\x12\x04\
    \xeb\x03\x1a\x1c\n\x0c\n\x04\x04)\x02\x0f\x12\x04\xed\x03\x042\n\r\n\x05\
    \x04)\x02\x0f\x06\x12\x04\xed\x03\x04\x12\n\r\n\x05\x04)\x02\x0f\x01\x12\
    \x04\xed\x03\x13,\n\r\n\x05\x04)\x02\x0f\x03\x12\x04\xed\x03/1\n\x0c\n\
    \x04\x04)\x02\x10\x12\x04\xef\x03\x04'\n\r\n\x05\x04)\x02\x10\x04\x12\
    \x04\xef\x03\x04\x0c\n\r\n\x05\x04)\x02\x10\x06\x12\x04\xef\x03\r\x14\n\
    \r\n\x05\x04)\x02\x10\x01\x12\x04\xef\x03\x15!\n\r\n\x05\x04)\x02\x10\
    \x03\x12\x04\xef\x03$&\n\x0c\n\x04\x04)\x02\x11\x12\x04\xf1\x03\x044\n\r\
    \n\x05\x04)\x02\x11\x06\x12\x04\xf1\x03\x04\x12\n\r\n\x05\x04)\x02\x11\
    \x01\x12\x04\xf1\x03\x13.\n\r\n\x05\x04)\x02\x11\x03\x12\x04\xf1\x0313\n\
    \x0c\n\x04\x04)\x02\x12\x12\x04\xf3\x03\x04\x1c\n\r\n\x05\x04)\x02\x12\
    \x05\x12\x04\xf3\x03\x04\n\n\r\n\x05\x04)\x02\x12\x01\x12\x04\xf3\x03\
    \x0b\x16\n\r\n\x05\x04)\x02\x12\x03\x12\x04\xf3\x03\x19\x1b\n\x0c\n\x04\
    \x04)\x02\x13\x12\x04\xf5\x03\x04$\n\r\n\x05\x04)\x02\x13\x05\x12\x04\
    \xf5\x03\x04\x08\n\r\n\x05\x04)\x02\x13\x01\x12\x04\xf5\x03\t\x1e\n\r\n\
    \x05\x04)\x02\x13\x03\x12\x04\xf5\x03!#\n\x0c\n\x04\x04)\x02\x14\x12\x04\
    \xf6\x03\x04!\n\r\n\x05\x04)\x02\x14\x05\x12\x04\xf6\x03\x04\x08\n\r\n\
    \x05\x04)\x02\x14\x01\x12\x04\xf6\x03\t\x1b\n\r\n\x05\x04)\x02\x14\x03\
    \x12\x04\xf6\x03\x1e\x20\n\x0c\n\x04\x04)\x02\x15\x12\x04\xf8\x03\x04\
    \x1b\n\r\n\x05\x04)\x02\x15\x05\x12\x04\xf8\x03\x04\n\n\r\n\x05\x04)\x02\
    \x15\x01\x12\x04\xf8\x03\x0b\x15\n\r\n\x05\x04)\x02\x15\x03\x12\x04\xf8\
    \x03\x18\x1a\n\x0c\n\x04\x04)\x02\x16\x12\x04\xfa\x03\x04)\n\r\n\x05\x04\
    )\x02\x16\x05\x12\x04\xfa\x03\x04\x08\n\r\n\x05\x04)\x02\x16\x01\x12\x04\
    \xfa\x03\t#\n\r\n\x05\x04)\x02\x16\x03\x12\x04\xfa\x03&(\n\x0c\n\x04\x04\
    )\x02\x17\x12\x04\xfc\x03\x04-\n\r\n\x05\x04)\x02\x17\x06\x12\x04\xfc\
    \x03\x04\x16\n\r\n\x05\x04)\x02\x17\x01\x12\x04\xfc\x03\x17'\n\r\n\x05\
    \x04)\x02\x17\x03\x12\x04\xfc\x03*,\n\x0c\n\x02\x05\x08\x12\x06\xff\x03\
    \0\x83\x04\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\xff\x03\x05\x17\n\x0c\n\
    \x04\x05\x08\x02\0\x12\x04\x81\x04\x04\x17\n\r\n\x05\x05\x08\x02\0\x01\
    \x12\x04\x81\x04\x04\x12\n\r\n\x05\x05\x08\x02\0\x02\x12\x04\x81\x04\x15\
    \x16\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\x82\x04\x04\x16\n\r\n\x05\x05\
    \x08\x02\x01\x01\x12\x04\x82\x04\x04\x11\n\r\n\x05\x05\x08\x02\x01\x02\
    \x12\x04\x82\x04\x14\x15\n\x0c\n\x02\x04*\x12\x06\x85\x04\0\x8c\x04\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\x85\x04\x08\x12\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\x87\x04\x04\x18\n\r\n\x05\x04*\x02\0\x05\x12\x04\x87\x04\x04\n\n\r\
    \n\x05\x04*\x02\0\x01\x12\x04\x87\x04\x0b\x13\n\r\n\x05\x04*\x02\0\x03\
    \x12\x04\x87\x04\x16\x17\n\x0c\n\x04\x04*\x02\x01\x12\x04\x88\x04\x04\
    \x19\n\r\n\x05\x04*\x02\x01\x05\x12\x04\x88\x04\x04\n\n\r\n\x05\x04*\x02\
    \x01\x01\x12\x04\x88\x04\x0b\x14\n\r\n\x05\x04*\x02\x01\x03\x12\x04\x88\
    \x04\x17\x18\n\x0c\n\x04\x04*\x02\x02\x12\x04\x8a\x04\x04\x14\n\r\n\x05\
    \x04*\x02\x02\x05\x12\x04\x8a\x04\x04\n\n\r\n\x05\x04*\x02\x02\x01\x12\
    \x04\x8a\x04\x0b\x0f\n\r\n\x05\x04*\x02\x02\x03\x12\x04\x8a\x04\x12\x13\
    \n\x0c\n\x04\x04*\x02\x03\x12\x04\x8b\x04\x04\x17\n\r\n\x05\x04*\x02\x03\
    \x05\x12\x04\x8b\x04\x04\n\n\r\n\x05\x04*\x02\x03\x01\x12\x04\x8b\x04\
    \x0b\x12\n\r\n\x05\x04*\x02\x03\x03\x12\x04\x8b\x04\x15\x16\n\x0c\n\x02\
    \x05\t\x12\x06\x8e\x04\0\x94\x04\x01\n\x0b\n\x03\x05\t\x01\x12\x04\x8e\
    \x04\x05\x10\n\x0c\n\x04\x05\t\x02\0\x12\x04\x90\x04\x04\x19\n\r\n\x05\
    \x05\t\x02\0\x01\x12\x04\x90\x04\x04\x14\n\r\n\x05\x05\t\x02\0\x02\x12\
    \x04\x90\x04\x17\x18\n\x0c\n\x04\x05\t\x02\x01\x12\x04\x91\x04\x04\x1a\n\
    \r\n\x05\x05\t\x02\x01\x01\x12\x04\x91\x04\x04\x15\n\r\n\x05\x05\t\x02\
    \x01\x02\x12\x04\x91\x04\x18\x19\n\x0c\n\x04\x05\t\x02\x02\x12\x04\x92\
    \x04\x04\x1a\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\x92\x04\x04\x15\n\r\n\
    \x05\x05\t\x02\x02\x02\x12\x04\x92\x04\x18\x19\n\x0c\n\x04\x05\t\x02\x03\
    \x12\x04\x93\x04\x04\x1d\n\r\n\x05\x05\t\x02\x03\x01\x12\x04\x93\x04\x04\
    \x18\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\x93\x04\x1b\x1c\n\x0c\n\x02\x04\
    +\x12\x06\x96\x04\0\xb6\x04\x01\n\x0b\n\x03\x04+\x01\x12\x04\x96\x04\x08\
    \x0f\n\x0e\n\x04\x04+\x03\0\x12\x06\x98\x04\x04\x9f\x04\x05\n\r\n\x05\
    \x04+\x03\0\x01\x12\x04\x98\x04\x0c\x18\n\x0e\n\x06\x04+\x03\0\x02\0\x12\
    \x04\x9a\x04\x08\x18\n\x0f\n\x07\x04+\x03\0\x02\0\x05\x12\x04\x9a\x04\
    \x08\r\n\x0f\n\x07\x04+\x03\0\x02\0\x01\x12\x04\x9a\x04\x0e\x13\n\x0f\n\
    \x07\x04+\x03\0\x02\0\x03\x12\x04\x9a\x04\x16\x17\n\x0e\n\x06\x04+\x03\0\
    \x02\x01\x12\x04\x9b\x04\x08\x19\n\x0f\n\x07\x04+\x03\0\x02\x01\x05\x12\
    \x04\x9b\x04\x08\r\n\x0f\n\x07\x04+\x03\0\x02\x01\x01\x12\x04\x9b\x04\
    \x0e\x14\n\x0f\n\x07\x04+\x03\0\x02\x01\x03\x12\x04\x9b\x04\x17\x18\n\
    \x0e\n\x06\x04+\x03\0\x02\x02\x12\x04\x9c\x04\x08\x1d\n\x0f\n\x07\x04+\
    \x03\0\x02\x02\x05\x12\x04\x9c\x04\x08\x0e\n\x0f\n\x07\x04+\x03\0\x02\
    \x02\x01\x12\x04\x9c\x04\x0f\x18\n\x0f\n\x07\x04+\x03\0\x02\x02\x03\x12\
    \x04\x9c\x04\x1b\x1c\nF\n\x06\x04+\x03\0\x02\x03\x12\x04\x9e\x04\x08\x1c\
    \"6\x20Unsure\x20what\x20it\x20is,\x20may\x20be\x20related\x20to\x20vide\
    o\x20encoding.\n\n\x0f\n\x07\x04+\x03\0\x02\x03\x05\x12\x04\x9e\x04\x08\
    \r\n\x0f\n\x07\x04+\x03\0\x02\x03\x01\x12\x04\x9e\x04\x0e\x17\n\x0f\n\
    \x07\x04+\x03\0\x02\x03\x03\x12\x04\x9e\x04\x1a\x1b\n\x0c\n\x04\x04+\x02\
    \0\x12\x04\xa1\x04\x04\x17\n\r\n\x05\x04+\x02\0\x05\x12\x04\xa1\x04\x04\
    \n\n\r\n\x05\x04+\x02\0\x01\x12\x04\xa1\x04\x0b\x12\n\r\n\x05\x04+\x02\0\
    \x03\x12\x04\xa1\x04\x15\x16\n\x0c\n\x04\x04+\x02\x01\x12\x04\xa2\x04\
    \x04\x1e\n\r\n\x05\x04+\x02\x01\x06\x12\x04\xa2\x04\x04\x0f\n\r\n\x05\
    \x04+\x02\x01\x01\x12\x04\xa2\x04\x10\x19\n\r\n\x05\x04+\x02\x01\x03\x12\
    \x04\xa2\x04\x1c\x1d\n\x0c\n\x04\x04+\x02\x02\x12\x04\xa4\x04\x04\x1c\n\
    \r\n\x05\x04+\x02\x02\x06\x12\x04\xa4\x04\x04\x0e\n\r\n\x05\x04+\x02\x02\
    \x01\x12\x04\xa4\x04\x0f\x17\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xa4\x04\
    \x1a\x1b\n\x0c\n\x04\x04+\x02\x03\x12\x04\xa5\x04\x04\x18\n\r\n\x05\x04+\
    \x02\x03\x05\x12\x04\xa5\x04\x04\t\n\r\n\x05\x04+\x02\x03\x01\x12\x04\
    \xa5\x04\n\x13\n\r\n\x05\x04+\x02\x03\x03\x12\x04\xa5\x04\x16\x17\n\x0c\
    \n\x04\x04+\x02\x04\x12\x04\xa6\x04\x04\x1b\n\r\n\x05\x04+\x02\x04\x05\
    \x12\x04\xa6\x04\x04\t\n\r\n\x05\x04+\x02\x04\x01\x12\x04\xa6\x04\n\x16\
    \n\r\n\x05\x04+\x02\x04\x03\x12\x04\xa6\x04\x19\x1a\n\x0c\n\x04\x04+\x02\
    \x05\x12\x04\xa7\x04\x04\x19\n\r\n\x05\x04+\x02\x05\x05\x12\x04\xa7\x04\
    \x04\t\n\r\n\x05\x04+\x02\x05\x01\x12\x04\xa7\x04\n\x14\n\r\n\x05\x04+\
    \x02\x05\x03\x12\x04\xa7\x04\x17\x18\n\x0c\n\x04\x04+\x02\x06\x12\x04\
    \xa9\x04\x04\x18\n\r\n\x05\x04+\x02\x06\x06\x12\x04\xa9\x04\x04\r\n\r\n\
    \x05\x04+\x02\x06\x01\x12\x04\xa9\x04\x0e\x13\n\r\n\x05\x04+\x02\x06\x03\
    \x12\x04\xa9\x04\x16\x17\n\x0c\n\x04\x04+\x02\x07\x12\x04\xaa\x04\x04+\n\
    \r\n\x05\x04+\x02\x07\x06\x12\x04\xaa\x04\x04\x12\n\r\n\x05\x04+\x02\x07\
    \x01\x12\x04\xaa\x04\x13&\n\r\n\x05\x04+\x02\x07\x03\x12\x04\xaa\x04)*\n\
    \x0c\n\x04\x04+\x02\x08\x12\x04\xab\x04\x04+\n\r\n\x05\x04+\x02\x08\x04\
    \x12\x04\xab\x04\x04\x0c\n\r\n\x05\x04+\x02\x08\x06\x12\x04\xab\x04\r\
    \x16\n\r\n\x05\x04+\x02\x08\x01\x12\x04\xab\x04\x17&\n\r\n\x05\x04+\x02\
    \x08\x03\x12\x04\xab\x04)*\n\x0c\n\x04\x04+\x02\t\x12\x04\xac\x04\x04\
    \x15\n\r\n\x05\x04+\x02\t\x05\x12\x04\xac\x04\x04\n\n\r\n\x05\x04+\x02\t\
    \x01\x12\x04\xac\x04\x0b\x0f\n\r\n\x05\x04+\x02\t\x03\x12\x04\xac\x04\
    \x12\x14\n\x0c\n\x04\x04+\x02\n\x12\x04\xad\x04\x04\x17\n\r\n\x05\x04+\
    \x02\n\x05\x12\x04\xad\x04\x04\n\n\r\n\x05\x04+\x02\n\x01\x12\x04\xad\
    \x04\x0b\x11\n\r\n\x05\x04+\x02\n\x03\x12\x04\xad\x04\x14\x16\n\x0c\n\
    \x04\x04+\x02\x0b\x12\x04\xae\x04\x04\x1e\n\r\n\x05\x04+\x02\x0b\x04\x12\
    \x04\xae\x04\x04\x0c\n\r\n\x05\x04+\x02\x0b\x05\x12\x04\xae\x04\r\x13\n\
    \r\n\x05\x04+\x02\x0b\x01\x12\x04\xae\x04\x14\x18\n\r\n\x05\x04+\x02\x0b\
    \x03\x12\x04\xae\x04\x1b\x1d\n\x0c\n\x04\x04+\x02\x0c\x12\x04\xaf\x04\
    \x040\n\r\n\x05\x04+\x02\x0c\x04\x12\x04\xaf\x04\x04\x0c\n\r\n\x05\x04+\
    \x02\x0c\x06\x12\x04\xaf\x04\r\x19\n\r\n\x05\x04+\x02\x0c\x01\x12\x04\
    \xaf\x04\x1a*\n\r\n\x05\x04+\x02\x0c\x03\x12\x04\xaf\x04-/\n\x0c\n\x04\
    \x04+\x02\r\x12\x04\xb0\x04\x040\n\r\n\x05\x04+\x02\r\x04\x12\x04\xb0\
    \x04\x04\x0c\n\r\n\x05\x04+\x02\r\x06\x12\x04\xb0\x04\r\x19\n\r\n\x05\
    \x04+\x02\r\x01\x12\x04\xb0\x04\x1a*\n\r\n\x05\x04+\x02\r\x03\x12\x04\
    \xb0\x04-/\n\x0c\n\x04\x04+\x02\x0e\x12\x04\xb2\x04\x04,\n\r\n\x05\x04+\
    \x02\x0e\x04\x12\x04\xb2\x04\x04\x0c\n\r\n\x05\x04+\x02\x0e\x06\x12\x04\
    \xb2\x04\r\x16\n\r\n\x05\x04+\x02\x0e\x01\x12\x04\xb2\x04\x17&\n\r\n\x05\
    \x04+\x02\x0e\x03\x12\x04\xb2\x04)+\n\x0c\n\x04\x04+\x02\x0f\x12\x04\xb4\
    \x04\x04\x1a\n\r\n\x05\x04+\x02\x0f\x05\x12\x04\xb4\x04\x04\n\n\r\n\x05\
    \x04+\x02\x0f\x01\x12\x04\xb4\x04\x0b\x14\n\r\n\x05\x04+\x02\x0f\x03\x12\
    \x04\xb4\x04\x17\x19\n\x0c\n\x04\x04+\x02\x10\x12\x04\xb5\x04\x04\x19\n\
    \r\n\x05\x04+\x02\x10\x05\x12\x04\xb5\x04\x04\t\n\r\n\x05\x04+\x02\x10\
    \x01\x12\x04\xb5\x04\n\x13\n\r\n\x05\x04+\x02\x10\x03\x12\x04\xb5\x04\
    \x16\x18\n\x0c\n\x02\x04,\x12\x06\xb8\x04\0\xbe\x04\x01\n\x0b\n\x03\x04,\
    \x01\x12\x04\xb8\x04\x08\x11\n\x0c\n\x04\x04,\x02\0\x12\x04\xba\x04\x04\
    \x19\n\r\n\x05\x04,\x02\0\x05\x12\x04\xba\x04\x04\n\n\r\n\x05\x04,\x02\0\
    \x01\x12\x04\xba\x04\x0b\x14\n\r\n\x05\x04,\x02\0\x03\x12\x04\xba\x04\
    \x17\x18\n\x0c\n\x04\x04,\x02\x01\x12\x04\xbb\x04\x04\x1a\n\r\n\x05\x04,\
    \x02\x01\x05\x12\x04\xbb\x04\x04\t\n\r\n\x05\x04,\x02\x01\x01\x12\x04\
    \xbb\x04\n\x15\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xbb\x04\x18\x19\n\x0c\
    \n\x04\x04,\x02\x02\x12\x04\xbc\x04\x04\x14\n\r\n\x05\x04,\x02\x02\x05\
    \x12\x04\xbc\x04\x04\n\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xbc\x04\x0b\
    \x0f\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xbc\x04\x12\x13\n\x0c\n\x04\x04,\
    \x02\x03\x12\x04\xbd\x04\x04\x1c\n\r\n\x05\x04,\x02\x03\x06\x12\x04\xbd\
    \x04\x04\r\n\r\n\x05\x04,\x02\x03\x01\x12\x04\xbd\x04\x0e\x17\n\r\n\x05\
    \x04,\x02\x03\x03\x12\x04\xbd\x04\x1a\x1b\n\x95\x01\n\x02\x05\n\x12\x06\
    \xc3\x04\0\xd4\x04\x01\x1a\x86\x01//////////////////////////////////////\
    ////////////////////////\n/\x20Tasks\n//////////////////////////////////\
    ////////////////////////////\n\n\x0b\n\x03\x05\n\x01\x12\x04\xc3\x04\x05\
    \x0f\n\x0c\n\x04\x05\n\x02\0\x12\x04\xc5\x04\x04\x18\n\r\n\x05\x05\n\x02\
    \0\x01\x12\x04\xc5\x04\x04\x13\n\r\n\x05\x05\n\x02\0\x02\x12\x04\xc5\x04\
    \x16\x17\n\x0c\n\x04\x05\n\x02\x01\x12\x04\xc6\x04\x04$\n\r\n\x05\x05\n\
    \x02\x01\x01\x12\x04\xc6\x04\x04\x1f\n\r\n\x05\x05\n\x02\x01\x02\x12\x04\
    \xc6\x04\"#\n\x0c\n\x04\x05\n\x02\x02\x12\x04\xc7\x04\x04#\n\r\n\x05\x05\
    \n\x02\x02\x01\x12\x04\xc7\x04\x04\x1e\n\r\n\x05\x05\n\x02\x02\x02\x12\
    \x04\xc7\x04!\"\n\x0c\n\x04\x05\n\x02\x03\x12\x04\xc8\x04\x04&\n\r\n\x05\
    \x05\n\x02\x03\x01\x12\x04\xc8\x04\x04!\n\r\n\x05\x05\n\x02\x03\x02\x12\
    \x04\xc8\x04$%\n\x0c\n\x04\x05\n\x02\x04\x12\x04\xc9\x04\x04*\n\r\n\x05\
    \x05\n\x02\x04\x01\x12\x04\xc9\x04\x04%\n\r\n\x05\x05\n\x02\x04\x02\x12\
    \x04\xc9\x04()\n\x0c\n\x04\x05\n\x02\x05\x12\x04\xca\x04\x04)\n\r\n\x05\
    \x05\n\x02\x05\x01\x12\x04\xca\x04\x04$\n\r\n\x05\x05\n\x02\x05\x02\x12\
    \x04\xca\x04'(\n\x0c\n\x04\x05\n\x02\x06\x12\x04\xcb\x04\x04&\n\r\n\x05\
    \x05\n\x02\x06\x01\x12\x04\xcb\x04\x04!\n\r\n\x05\x05\n\x02\x06\x02\x12\
    \x04\xcb\x04$%\n\x0c\n\x04\x05\n\x02\x07\x12\x04\xcc\x04\x04+\n\r\n\x05\
    \x05\n\x02\x07\x01\x12\x04\xcc\x04\x04&\n\r\n\x05\x05\n\x02\x07\x02\x12\
    \x04\xcc\x04)*\n\x0c\n\x04\x05\n\x02\x08\x12\x04\xcd\x04\x04)\n\r\n\x05\
    \x05\n\x02\x08\x01\x12\x04\xcd\x04\x04$\n\r\n\x05\x05\n\x02\x08\x02\x12\
    \x04\xcd\x04'(\n\x0c\n\x04\x05\n\x02\t\x12\x04\xce\x04\x04(\n\r\n\x05\
    \x05\n\x02\t\x01\x12\x04\xce\x04\x04#\n\r\n\x05\x05\n\x02\t\x02\x12\x04\
    \xce\x04&'\n\x0c\n\x04\x05\n\x02\n\x12\x04\xcf\x04\x04+\n\r\n\x05\x05\n\
    \x02\n\x01\x12\x04\xcf\x04\x04%\n\r\n\x05\x05\n\x02\n\x02\x12\x04\xcf\
    \x04(*\n\x0c\n\x04\x05\n\x02\x0b\x12\x04\xd0\x04\x04(\n\r\n\x05\x05\n\
    \x02\x0b\x01\x12\x04\xd0\x04\x04\"\n\r\n\x05\x05\n\x02\x0b\x02\x12\x04\
    \xd0\x04%'\n\x0c\n\x04\x05\n\x02\x0c\x12\x04\xd1\x04\x04#\n\r\n\x05\x05\
    \n\x02\x0c\x01\x12\x04\xd1\x04\x04\x1d\n\r\n\x05\x05\n\x02\x0c\x02\x12\
    \x04\xd1\x04\x20\"\n\x1b\n\x04\x05\n\x02\r\x12\x04\xd3\x04\x048\x1a\rspe\
    cial\x20task\n\n\r\n\x05\x05\n\x02\r\x01\x12\x04\xd3\x04\x041\n\r\n\x05\
    \x05\n\x02\r\x02\x12\x04\xd3\x0447\n\x0c\n\x02\x05\x0b\x12\x06\xd6\x04\0\
    \xdb\x04\x01\n\x0b\n\x03\x05\x0b\x01\x12\x04\xd6\x04\x05\x10\n\x0c\n\x04\
    \x05\x0b\x02\0\x12\x04\xd8\x04\x04\x1c\n\r\n\x05\x05\x0b\x02\0\x01\x12\
    \x04\xd8\x04\x04\x17\n\r\n\x05\x05\x0b\x02\0\x02\x12\x04\xd8\x04\x1a\x1b\
    \n\x0c\n\x04\x05\x0b\x02\x01\x12\x04\xd9\x04\x04\x1c\n\r\n\x05\x05\x0b\
    \x02\x01\x01\x12\x04\xd9\x04\x04\x17\n\r\n\x05\x05\x0b\x02\x01\x02\x12\
    \x04\xd9\x04\x1a\x1b\n\x0c\n\x04\x05\x0b\x02\x02\x12\x04\xda\x04\x04\x1c\
    \n\r\n\x05\x05\x0b\x02\x02\x01\x12\x04\xda\x04\x04\x17\n\r\n\x05\x05\x0b\
    \x02\x02\x02\x12\x04\xda\x04\x1a\x1b\n\x0c\n\x02\x05\x0c\x12\x06\xdd\x04\
    \0\xe2\x04\x01\n\x0b\n\x03\x05\x0c\x01\x12\x04\xdd\x04\x05\x18\n\x0c\n\
    \x04\x05\x0c\x02\0\x12\x04\xdf\x04\x04,\n\r\n\x05\x05\x0c\x02\0\x01\x12\
    \x04\xdf\x04\x04'\n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\xdf\x04*+\n\x0c\n\
    \x04\x05\x0c\x02\x01\x12\x04\xe0\x04\x04+\n\r\n\x05\x05\x0c\x02\x01\x01\
    \x12\x04\xe0\x04\x04&\n\r\n\x05\x05\x0c\x02\x01\x02\x12\x04\xe0\x04)*\n\
    \x0c\n\x04\x05\x0c\x02\x02\x12\x04\xe1\x04\x04'\n\r\n\x05\x05\x0c\x02\
    \x02\x01\x12\x04\xe1\x04\x04\"\n\r\n\x05\x05\x0c\x02\x02\x02\x12\x04\xe1\
    \x04%&\n\x0c\n\x02\x04-\x12\x06\xe4\x04\0\xe8\x04\x01\n\x0b\n\x03\x04-\
    \x01\x12\x04\xe4\x04\x08%\n\x0c\n\x04\x04-\x02\0\x12\x04\xe6\x04\x04\x19\
    \n\r\n\x05\x04-\x02\0\x05\x12\x04\xe6\x04\x04\n\n\r\n\x05\x04-\x02\0\x01\
    \x12\x04\xe6\x04\x0b\x14\n\r\n\x05\x04-\x02\0\x03\x12\x04\xe6\x04\x17\
    \x18\n\x0c\n\x04\x04-\x02\x01\x12\x04\xe7\x04\x04\x1a\n\r\n\x05\x04-\x02\
    \x01\x06\x12\x04\xe7\x04\x04\r\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xe7\
    \x04\x0e\x15\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xe7\x04\x18\x19\n\x0c\n\
    \x02\x04.\x12\x06\xea\x04\0\xf0\x04\x01\n\x0b\n\x03\x04.\x01\x12\x04\xea\
    \x04\x08'\n\x0c\n\x04\x04.\x02\0\x12\x04\xec\x04\x04\x19\n\r\n\x05\x04.\
    \x02\0\x05\x12\x04\xec\x04\x04\n\n\r\n\x05\x04.\x02\0\x01\x12\x04\xec\
    \x04\x0b\x14\n\r\n\x05\x04.\x02\0\x03\x12\x04\xec\x04\x17\x18\n\x0c\n\
    \x04\x04.\x02\x01\x12\x04\xed\x04\x04\x16\n\r\n\x05\x04.\x02\x01\x05\x12\
    \x04\xed\x04\x04\n\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xed\x04\x0b\x11\n\
    \r\n\x05\x04.\x02\x01\x03\x12\x04\xed\x04\x14\x15\n\x0c\n\x04\x04.\x02\
    \x02\x12\x04\xee\x04\x04\x20\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xee\x04\
    \x04\x0c\n\r\n\x05\x04.\x02\x02\x06\x12\x04\xee\x04\r\x14\n\r\n\x05\x04.\
    \x02\x02\x01\x12\x04\xee\x04\x15\x1b\n\r\n\x05\x04.\x02\x02\x03\x12\x04\
    \xee\x04\x1e\x1f\n\x0c\n\x04\x04.\x02\x03\x12\x04\xef\x04\x04\x1b\n\r\n\
    \x05\x04.\x02\x03\x05\x12\x04\xef\x04\x04\t\n\r\n\x05\x04.\x02\x03\x01\
    \x12\x04\xef\x04\n\x16\n\r\n\x05\x04.\x02\x03\x03\x12\x04\xef\x04\x19\
    \x1a\n\x0c\n\x02\x04/\x12\x06\xf2\x04\0\xfb\x04\x01\n\x0b\n\x03\x04/\x01\
    \x12\x04\xf2\x04\x08%\n\x0c\n\x04\x04/\x02\0\x12\x04\xf4\x04\x04\x17\n\r\
    \n\x05\x04/\x02\0\x05\x12\x04\xf4\x04\x04\n\n\r\n\x05\x04/\x02\0\x01\x12\
    \x04\xf4\x04\x0b\x12\n\r\n\x05\x04/\x02\0\x03\x12\x04\xf4\x04\x15\x16\n\
    \x0c\n\x04\x04/\x02\x01\x12\x04\xf5\x04\x04\x16\n\r\n\x05\x04/\x02\x01\
    \x05\x12\x04\xf5\x04\x04\n\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xf5\x04\
    \x0b\x11\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xf5\x04\x14\x15\n\x0c\n\x04\
    \x04/\x02\x02\x12\x04\xf6\x04\x04\"\n\r\n\x05\x04/\x02\x02\x04\x12\x04\
    \xf6\x04\x04\x0c\n\r\n\x05\x04/\x02\x02\x06\x12\x04\xf6\x04\r\x16\n\r\n\
    \x05\x04/\x02\x02\x01\x12\x04\xf6\x04\x17\x1d\n\r\n\x05\x04/\x02\x02\x03\
    \x12\x04\xf6\x04\x20!\n\x0c\n\x04\x04/\x02\x03\x12\x04\xf7\x04\x04\x1b\n\
    \r\n\x05\x04/\x02\x03\x05\x12\x04\xf7\x04\x04\t\n\r\n\x05\x04/\x02\x03\
    \x01\x12\x04\xf7\x04\n\x16\n\r\n\x05\x04/\x02\x03\x03\x12\x04\xf7\x04\
    \x19\x1a\n\x0c\n\x04\x04/\x02\x04\x12\x04\xf8\x04\x04\x19\n\r\n\x05\x04/\
    \x02\x04\x05\x12\x04\xf8\x04\x04\t\n\r\n\x05\x04/\x02\x04\x01\x12\x04\
    \xf8\x04\n\x14\n\r\n\x05\x04/\x02\x04\x03\x12\x04\xf8\x04\x17\x18\n\x0c\
    \n\x04\x04/\x02\x05\x12\x04\xf9\x04\x04\x19\n\r\n\x05\x04/\x02\x05\x05\
    \x12\x04\xf9\x04\x04\n\n\r\n\x05\x04/\x02\x05\x01\x12\x04\xf9\x04\x0b\
    \x14\n\r\n\x05\x04/\x02\x05\x03\x12\x04\xf9\x04\x17\x18\n\x0c\n\x04\x04/\
    \x02\x06\x12\x04\xfa\x04\x04\x17\n\r\n\x05\x04/\x02\x06\x05\x12\x04\xfa\
    \x04\x04\n\n\r\n\x05\x04/\x02\x06\x01\x12\x04\xfa\x04\x0b\x12\n\r\n\x05\
    \x04/\x02\x06\x03\x12\x04\xfa\x04\x15\x16\n\x0c\n\x02\x040\x12\x06\xfd\
    \x04\0\x86\x05\x01\n\x0b\n\x03\x040\x01\x12\x04\xfd\x04\x08'\n\x0c\n\x04\
    \x040\x02\0\x12\x04\xff\x04\x04\x17\n\r\n\x05\x040\x02\0\x05\x12\x04\xff\
    \x04\x04\n\n\r\n\x05\x040\x02\0\x01\x12\x04\xff\x04\x0b\x12\n\r\n\x05\
    \x040\x02\0\x03\x12\x04\xff\x04\x15\x16\n\x0c\n\x04\x040\x02\x01\x12\x04\
    \x80\x05\x04\x16\n\r\n\x05\x040\x02\x01\x05\x12\x04\x80\x05\x04\n\n\r\n\
    \x05\x040\x02\x01\x01\x12\x04\x80\x05\x0b\x11\n\r\n\x05\x040\x02\x01\x03\
    \x12\x04\x80\x05\x14\x15\n\x0c\n\x04\x040\x02\x02\x12\x04\x81\x05\x04$\n\
    \r\n\x05\x040\x02\x02\x04\x12\x04\x81\x05\x04\x0c\n\r\n\x05\x040\x02\x02\
    \x06\x12\x04\x81\x05\r\x16\n\r\n\x05\x040\x02\x02\x01\x12\x04\x81\x05\
    \x17\x1f\n\r\n\x05\x040\x02\x02\x03\x12\x04\x81\x05\"#\n\x0c\n\x04\x040\
    \x02\x03\x12\x04\x82\x05\x04\x1b\n\r\n\x05\x040\x02\x03\x05\x12\x04\x82\
    \x05\x04\t\n\r\n\x05\x040\x02\x03\x01\x12\x04\x82\x05\n\x16\n\r\n\x05\
    \x040\x02\x03\x03\x12\x04\x82\x05\x19\x1a\n\x0c\n\x04\x040\x02\x04\x12\
    \x04\x83\x05\x04\x19\n\r\n\x05\x040\x02\x04\x05\x12\x04\x83\x05\x04\t\n\
    \r\n\x05\x040\x02\x04\x01\x12\x04\x83\x05\n\x14\n\r\n\x05\x040\x02\x04\
    \x03\x12\x04\x83\x05\x17\x18\n\x0c\n\x04\x040\x02\x05\x12\x04\x84\x05\
    \x04\x19\n\r\n\x05\x040\x02\x05\x05\x12\x04\x84\x05\x04\n\n\r\n\x05\x040\
    \x02\x05\x01\x12\x04\x84\x05\x0b\x14\n\r\n\x05\x040\x02\x05\x03\x12\x04\
    \x84\x05\x17\x18\n\x0c\n\x04\x040\x02\x06\x12\x04\x85\x05\x04\x17\n\r\n\
    \x05\x040\x02\x06\x05\x12\x04\x85\x05\x04\n\n\r\n\x05\x040\x02\x06\x01\
    \x12\x04\x85\x05\x0b\x12\n\r\n\x05\x040\x02\x06\x03\x12\x04\x85\x05\x15\
    \x16\n\x0c\n\x02\x041\x12\x06\x88\x05\0\x8f\x05\x01\n\x0b\n\x03\x041\x01\
    \x12\x04\x88\x05\x08*\n\x0c\n\x04\x041\x02\0\x12\x04\x8a\x05\x04\x19\n\r\
    \n\x05\x041\x02\0\x05\x12\x04\x8a\x05\x04\n\n\r\n\x05\x041\x02\0\x01\x12\
    \x04\x8a\x05\x0b\x14\n\r\n\x05\x041\x02\0\x03\x12\x04\x8a\x05\x17\x18\n\
    \x0c\n\x04\x041\x02\x01\x12\x04\x8b\x05\x04\x16\n\r\n\x05\x041\x02\x01\
    \x05\x12\x04\x8b\x05\x04\n\n\r\n\x05\x041\x02\x01\x01\x12\x04\x8b\x05\
    \x0b\x11\n\r\n\x05\x041\x02\x01\x03\x12\x04\x8b\x05\x14\x15\n\x0c\n\x04\
    \x041\x02\x02\x12\x04\x8c\x05\x04%\n\r\n\x05\x041\x02\x02\x04\x12\x04\
    \x8c\x05\x04\x0c\n\r\n\x05\x041\x02\x02\x06\x12\x04\x8c\x05\r\x16\n\r\n\
    \x05\x041\x02\x02\x01\x12\x04\x8c\x05\x17\x20\n\r\n\x05\x041\x02\x02\x03\
    \x12\x04\x8c\x05#$\n\x0c\n\x04\x041\x02\x03\x12\x04\x8d\x05\x04\x1b\n\r\
    \n\x05\x041\x02\x03\x05\x12\x04\x8d\x05\x04\t\n\r\n\x05\x041\x02\x03\x01\
    \x12\x04\x8d\x05\n\x16\n\r\n\x05\x041\x02\x03\x03\x12\x04\x8d\x05\x19\
    \x1a\n\x0c\n\x04\x041\x02\x04\x12\x04\x8e\x05\x04\x1e\n\r\n\x05\x041\x02\
    \x04\x05\x12\x04\x8e\x05\x04\x08\n\r\n\x05\x041\x02\x04\x01\x12\x04\x8e\
    \x05\t\x19\n\r\n\x05\x041\x02\x04\x03\x12\x04\x8e\x05\x1c\x1d\n\x0c\n\
    \x02\x042\x12\x06\x91\x05\0\x97\x05\x01\n\x0b\n\x03\x042\x01\x12\x04\x91\
    \x05\x08,\n\x0c\n\x04\x042\x02\0\x12\x04\x93\x05\x04\x19\n\r\n\x05\x042\
    \x02\0\x05\x12\x04\x93\x05\x04\n\n\r\n\x05\x042\x02\0\x01\x12\x04\x93\
    \x05\x0b\x14\n\r\n\x05\x042\x02\0\x03\x12\x04\x93\x05\x17\x18\n\x0c\n\
    \x04\x042\x02\x01\x12\x04\x94\x05\x04\x16\n\r\n\x05\x042\x02\x01\x05\x12\
    \x04\x94\x05\x04\n\n\r\n\x05\x042\x02\x01\x01\x12\x04\x94\x05\x0b\x11\n\
    \r\n\x05\x042\x02\x01\x03\x12\x04\x94\x05\x14\x15\n\x0c\n\x04\x042\x02\
    \x02\x12\x04\x95\x05\x04\x20\n\r\n\x05\x042\x02\x02\x04\x12\x04\x95\x05\
    \x04\x0c\n\r\n\x05\x042\x02\x02\x06\x12\x04\x95\x05\r\x14\n\r\n\x05\x042\
    \x02\x02\x01\x12\x04\x95\x05\x15\x1b\n\r\n\x05\x042\x02\x02\x03\x12\x04\
    \x95\x05\x1e\x1f\n\x0c\n\x04\x042\x02\x03\x12\x04\x96\x05\x04\x1b\n\r\n\
    \x05\x042\x02\x03\x05\x12\x04\x96\x05\x04\t\n\r\n\x05\x042\x02\x03\x01\
    \x12\x04\x96\x05\n\x16\n\r\n\x05\x042\x02\x03\x03\x12\x04\x96\x05\x19\
    \x1a\n\x0c\n\x02\x043\x12\x06\x99\x05\0\xa0\x05\x01\n\x0b\n\x03\x043\x01\
    \x12\x04\x99\x05\x08+\n\x0c\n\x04\x043\x02\0\x12\x04\x9b\x05\x04\x19\n\r\
    \n\x05\x043\x02\0\x05\x12\x04\x9b\x05\x04\n\n\r\n\x05\x043\x02\0\x01\x12\
    \x04\x9b\x05\x0b\x14\n\r\n\x05\x043\x02\0\x03\x12\x04\x9b\x05\x17\x18\n\
    \x0c\n\x04\x043\x02\x01\x12\x04\x9c\x05\x04\x16\n\r\n\x05\x043\x02\x01\
    \x05\x12\x04\x9c\x05\x04\n\n\r\n\x05\x043\x02\x01\x01\x12\x04\x9c\x05\
    \x0b\x11\n\r\n\x05\x043\x02\x01\x03\x12\x04\x9c\x05\x14\x15\n\x0c\n\x04\
    \x043\x02\x02\x12\x04\x9d\x05\x04&\n\r\n\x05\x043\x02\x02\x04\x12\x04\
    \x9d\x05\x04\x0c\n\r\n\x05\x043\x02\x02\x06\x12\x04\x9d\x05\r\x16\n\r\n\
    \x05\x043\x02\x02\x01\x12\x04\x9d\x05\x17!\n\r\n\x05\x043\x02\x02\x03\
    \x12\x04\x9d\x05$%\n\x0c\n\x04\x043\x02\x03\x12\x04\x9e\x05\x04\x1b\n\r\
    \n\x05\x043\x02\x03\x05\x12\x04\x9e\x05\x04\t\n\r\n\x05\x043\x02\x03\x01\
    \x12\x04\x9e\x05\n\x16\n\r\n\x05\x043\x02\x03\x03\x12\x04\x9e\x05\x19\
    \x1a\n\x0c\n\x04\x043\x02\x04\x12\x04\x9f\x05\x04\x1e\n\r\n\x05\x043\x02\
    \x04\x05\x12\x04\x9f\x05\x04\x08\n\r\n\x05\x043\x02\x04\x01\x12\x04\x9f\
    \x05\t\x19\n\r\n\x05\x043\x02\x04\x03\x12\x04\x9f\x05\x1c\x1d\n\x0c\n\
    \x02\x044\x12\x06\xa2\x05\0\xae\x05\x01\n\x0b\n\x03\x044\x01\x12\x04\xa2\
    \x05\x08*\n\x0e\n\x04\x044\x03\0\x12\x06\xa4\x05\x04\xa8\x05\x05\n\r\n\
    \x05\x044\x03\0\x01\x12\x04\xa4\x05\x0c\x18\n\x0e\n\x06\x044\x03\0\x02\0\
    \x12\x04\xa6\x05\x08\x1e\n\x0f\n\x07\x044\x03\0\x02\0\x06\x12\x04\xa6\
    \x05\x08\x11\n\x0f\n\x07\x044\x03\0\x02\0\x01\x12\x04\xa6\x05\x12\x19\n\
    \x0f\n\x07\x044\x03\0\x02\0\x03\x12\x04\xa6\x05\x1c\x1d\n\x0e\n\x06\x044\
    \x03\0\x02\x01\x12\x04\xa7\x05\x08\x1c\n\x0f\n\x07\x044\x03\0\x02\x01\
    \x05\x12\x04\xa7\x05\x08\r\n\x0f\n\x07\x044\x03\0\x02\x01\x01\x12\x04\
    \xa7\x05\x0e\x17\n\x0f\n\x07\x044\x03\0\x02\x01\x03\x12\x04\xa7\x05\x1a\
    \x1b\n\x0c\n\x04\x044\x02\0\x12\x04\xaa\x05\x04\x19\n\r\n\x05\x044\x02\0\
    \x05\x12\x04\xaa\x05\x04\n\n\r\n\x05\x044\x02\0\x01\x12\x04\xaa\x05\x0b\
    \x14\n\r\n\x05\x044\x02\0\x03\x12\x04\xaa\x05\x17\x18\n\x0c\n\x04\x044\
    \x02\x01\x12\x04\xab\x05\x04\x16\n\r\n\x05\x044\x02\x01\x05\x12\x04\xab\
    \x05\x04\n\n\r\n\x05\x044\x02\x01\x01\x12\x04\xab\x05\x0b\x11\n\r\n\x05\
    \x044\x02\x01\x03\x12\x04\xab\x05\x14\x15\n\x0c\n\x04\x044\x02\x02\x12\
    \x04\xac\x05\x04(\n\r\n\x05\x044\x02\x02\x04\x12\x04\xac\x05\x04\x0c\n\r\
    \n\x05\x044\x02\x02\x06\x12\x04\xac\x05\r\x19\n\r\n\x05\x044\x02\x02\x01\
    \x12\x04\xac\x05\x1a#\n\r\n\x05\x044\x02\x02\x03\x12\x04\xac\x05&'\n\x0c\
    \n\x04\x044\x02\x03\x12\x04\xad\x05\x04\x1b\n\r\n\x05\x044\x02\x03\x05\
    \x12\x04\xad\x05\x04\t\n\r\n\x05\x044\x02\x03\x01\x12\x04\xad\x05\n\x16\
    \n\r\n\x05\x044\x02\x03\x03\x12\x04\xad\x05\x19\x1a\n\x0c\n\x02\x045\x12\
    \x06\xb0\x05\0\xb5\x05\x01\n\x0b\n\x03\x045\x01\x12\x04\xb0\x05\x08)\n\
    \x0c\n\x04\x045\x02\0\x12\x04\xb2\x05\x04\x1f\n\r\n\x05\x045\x02\0\x05\
    \x12\x04\xb2\x05\x04\n\n\r\n\x05\x045\x02\0\x01\x12\x04\xb2\x05\x0b\x1a\
    \n\r\n\x05\x045\x02\0\x03\x12\x04\xb2\x05\x1d\x1e\n\x0c\n\x04\x045\x02\
    \x01\x12\x04\xb3\x05\x04\x1f\n\r\n\x05\x045\x02\x01\x05\x12\x04\xb3\x05\
    \x04\n\n\r\n\x05\x045\x02\x01\x01\x12\x04\xb3\x05\x0b\x1a\n\r\n\x05\x045\
    \x02\x01\x03\x12\x04\xb3\x05\x1d\x1e\n\x0c\n\x04\x045\x02\x02\x12\x04\
    \xb4\x05\x04\x20\n\r\n\x05\x045\x02\x02\x06\x12\x04\xb4\x05\x04\x12\n\r\
    \n\x05\x045\x02\x02\x01\x12\x04\xb4\x05\x13\x1b\n\r\n\x05\x045\x02\x02\
    \x03\x12\x04\xb4\x05\x1e\x1f\n\x0c\n\x02\x05\r\x12\x06\xb7\x05\0\xbd\x05\
    \x01\n\x0b\n\x03\x05\r\x01\x12\x04\xb7\x05\x05\x13\n\x0c\n\x04\x05\r\x02\
    \0\x12\x04\xb9\x05\x04\x1c\n\r\n\x05\x05\r\x02\0\x01\x12\x04\xb9\x05\x04\
    \x17\n\r\n\x05\x05\r\x02\0\x02\x12\x04\xb9\x05\x1a\x1b\n\x0c\n\x04\x05\r\
    \x02\x01\x12\x04\xba\x05\x04\x1c\n\r\n\x05\x05\r\x02\x01\x01\x12\x04\xba\
    \x05\x04\x17\n\r\n\x05\x05\r\x02\x01\x02\x12\x04\xba\x05\x1a\x1b\n\x0c\n\
    \x04\x05\r\x02\x02\x12\x04\xbb\x05\x04\x1f\n\r\n\x05\x05\r\x02\x02\x01\
    \x12\x04\xbb\x05\x04\x1a\n\r\n\x05\x05\r\x02\x02\x02\x12\x04\xbb\x05\x1d\
    \x1e\n\x0c\n\x04\x05\r\x02\x03\x12\x04\xbc\x05\x04\x1e\n\r\n\x05\x05\r\
    \x02\x03\x01\x12\x04\xbc\x05\x04\x19\n\r\n\x05\x05\r\x02\x03\x02\x12\x04\
    \xbc\x05\x1c\x1d\n\x0c\n\x02\x046\x12\x06\xbf\x05\0\xcc\x05\x01\n\x0b\n\
    \x03\x046\x01\x12\x04\xbf\x05\x08+\n\x0e\n\x04\x046\x03\0\x12\x06\xc1\
    \x05\x04\xc7\x05\x05\n\r\n\x05\x046\x03\0\x01\x12\x04\xc1\x05\x0c\x14\n\
    \x0e\n\x06\x046\x03\0\x02\0\x12\x04\xc3\x05\x08\x20\n\x0f\n\x07\x046\x03\
    \0\x02\0\x06\x12\x04\xc3\x05\x08\x16\n\x0f\n\x07\x046\x03\0\x02\0\x01\
    \x12\x04\xc3\x05\x17\x1b\n\x0f\n\x07\x046\x03\0\x02\0\x03\x12\x04\xc3\
    \x05\x1e\x1f\n\x0e\n\x06\x046\x03\0\x02\x01\x12\x04\xc4\x05\x08$\n\x0f\n\
    \x07\x046\x03\0\x02\x01\x06\x12\x04\xc4\x05\x08\x11\n\x0f\n\x07\x046\x03\
    \0\x02\x01\x01\x12\x04\xc4\x05\x12\x1f\n\x0f\n\x07\x046\x03\0\x02\x01\
    \x03\x12\x04\xc4\x05\"#\n\x0e\n\x06\x046\x03\0\x02\x02\x12\x04\xc5\x05\
    \x08\x1a\n\x0f\n\x07\x046\x03\0\x02\x02\x06\x12\x04\xc5\x05\x08\x0f\n\
    \x0f\n\x07\x046\x03\0\x02\x02\x01\x12\x04\xc5\x05\x10\x15\n\x0f\n\x07\
    \x046\x03\0\x02\x02\x03\x12\x04\xc5\x05\x18\x19\n\x0e\n\x06\x046\x03\0\
    \x02\x03\x12\x04\xc6\x05\x08\x1c\n\x0f\n\x07\x046\x03\0\x02\x03\x05\x12\
    \x04\xc6\x05\x08\r\n\x0f\n\x07\x046\x03\0\x02\x03\x01\x12\x04\xc6\x05\
    \x0e\x17\n\x0f\n\x07\x046\x03\0\x02\x03\x03\x12\x04\xc6\x05\x1a\x1b\n\
    \x0c\n\x04\x046\x02\0\x12\x04\xc9\x05\x04\x19\n\r\n\x05\x046\x02\0\x05\
    \x12\x04\xc9\x05\x04\n\n\r\n\x05\x046\x02\0\x01\x12\x04\xc9\x05\x0b\x14\
    \n\r\n\x05\x046\x02\0\x03\x12\x04\xc9\x05\x17\x18\n\x0c\n\x04\x046\x02\
    \x01\x12\x04\xca\x05\x04\x1d\n\r\n\x05\x046\x02\x01\x05\x12\x04\xca\x05\
    \x04\t\n\r\n\x05\x046\x02\x01\x01\x12\x04\xca\x05\n\x18\n\r\n\x05\x046\
    \x02\x01\x03\x12\x04\xca\x05\x1b\x1c\n\x0c\n\x04\x046\x02\x02\x12\x04\
    \xcb\x05\x04%\n\r\n\x05\x046\x02\x02\x04\x12\x04\xcb\x05\x04\x0c\n\r\n\
    \x05\x046\x02\x02\x06\x12\x04\xcb\x05\r\x15\n\r\n\x05\x046\x02\x02\x01\
    \x12\x04\xcb\x05\x16\x20\n\r\n\x05\x046\x02\x02\x03\x12\x04\xcb\x05#$\n\
    \x0c\n\x02\x047\x12\x06\xce\x05\0\xd8\x05\x01\n\x0b\n\x03\x047\x01\x12\
    \x04\xce\x05\x08(\n\x0e\n\x04\x047\x03\0\x12\x06\xd0\x05\x04\xd4\x05\x05\
    \n\r\n\x05\x047\x03\0\x01\x12\x04\xd0\x05\x0c\x18\n\x0e\n\x06\x047\x03\0\
    \x02\0\x12\x04\xd2\x05\x08\x1a\n\x0f\n\x07\x047\x03\0\x02\0\x06\x12\x04\
    \xd2\x05\x08\x0f\n\x0f\n\x07\x047\x03\0\x02\0\x01\x12\x04\xd2\x05\x10\
    \x15\n\x0f\n\x07\x047\x03\0\x02\0\x03\x12\x04\xd2\x05\x18\x19\n\x0e\n\
    \x06\x047\x03\0\x02\x01\x12\x04\xd3\x05\x08'\n\x0f\n\x07\x047\x03\0\x02\
    \x01\x04\x12\x04\xd3\x05\x08\x10\n\x0f\n\x07\x047\x03\0\x02\x01\x06\x12\
    \x04\xd3\x05\x11\x1a\n\x0f\n\x07\x047\x03\0\x02\x01\x01\x12\x04\xd3\x05\
    \x1b\"\n\x0f\n\x07\x047\x03\0\x02\x01\x03\x12\x04\xd3\x05%&\n\x0c\n\x04\
    \x047\x02\0\x12\x04\xd6\x05\x04\x19\n\r\n\x05\x047\x02\0\x05\x12\x04\xd6\
    \x05\x04\n\n\r\n\x05\x047\x02\0\x01\x12\x04\xd6\x05\x0b\x14\n\r\n\x05\
    \x047\x02\0\x03\x12\x04\xd6\x05\x17\x18\n\x0c\n\x04\x047\x02\x01\x12\x04\
    \xd7\x05\x04&\n\r\n\x05\x047\x02\x01\x04\x12\x04\xd7\x05\x04\x0c\n\r\n\
    \x05\x047\x02\x01\x06\x12\x04\xd7\x05\r\x19\n\r\n\x05\x047\x02\x01\x01\
    \x12\x04\xd7\x05\x1a!\n\r\n\x05\x047\x02\x01\x03\x12\x04\xd7\x05$%\n\x0c\
    \n\x02\x048\x12\x06\xda\x05\0\xdd\x05\x01\n\x0b\n\x03\x048\x01\x12\x04\
    \xda\x05\x08#\n\x0c\n\x04\x048\x02\0\x12\x04\xdc\x05\x04\x16\n\r\n\x05\
    \x048\x02\0\x06\x12\x04\xdc\x05\x04\x0b\n\r\n\x05\x048\x02\0\x01\x12\x04\
    \xdc\x05\x0c\x11\n\r\n\x05\x048\x02\0\x03\x12\x04\xdc\x05\x14\x15\n\x0c\
    \n\x02\x049\x12\x06\xdf\x05\0\xf6\x05\x01\n\x0b\n\x03\x049\x01\x12\x04\
    \xdf\x05\x08\x0e\n\x0c\n\x04\x049\x02\0\x12\x04\xe1\x05\x04\x1c\n\r\n\
    \x05\x049\x02\0\x06\x12\x04\xe1\x05\x04\x0e\n\r\n\x05\x049\x02\0\x01\x12\
    \x04\xe1\x05\x0f\x17\n\r\n\x05\x049\x02\0\x03\x12\x04\xe1\x05\x1a\x1b\n\
    \x0c\n\x04\x049\x02\x01\x12\x04\xe2\x05\x04\x16\n\r\n\x05\x049\x02\x01\
    \x05\x12\x04\xe2\x05\x04\n\n\r\n\x05\x049\x02\x01\x01\x12\x04\xe2\x05\
    \x0b\x11\n\r\n\x05\x049\x02\x01\x03\x12\x04\xe2\x05\x14\x15\n\x0c\n\x04\
    \x049\x02\x02\x12\x04\xe3\x05\x04\x1e\n\r\n\x05\x049\x02\x02\x06\x12\x04\
    \xe3\x05\x04\x0f\n\r\n\x05\x049\x02\x02\x01\x12\x04\xe3\x05\x10\x19\n\r\
    \n\x05\x049\x02\x02\x03\x12\x04\xe3\x05\x1c\x1d\n\x0c\n\x04\x049\x02\x03\
    \x12\x04\xe4\x05\x04*\n\r\n\x05\x049\x02\x03\x06\x12\x04\xe4\x05\x04\x17\
    \n\r\n\x05\x049\x02\x03\x01\x12\x04\xe4\x05\x18%\n\r\n\x05\x049\x02\x03\
    \x03\x12\x04\xe4\x05()\n\x0e\n\x04\x049\x08\0\x12\x06\xe5\x05\x04\xf3\
    \x05\x05\n\r\n\x05\x049\x08\0\x01\x12\x04\xe5\x05\n\x15\n\x0c\n\x04\x049\
    \x02\x04\x12\x04\xe7\x05\x08B\n\r\n\x05\x049\x02\x04\x06\x12\x04\xe7\x05\
    \x08%\n\r\n\x05\x049\x02\x04\x01\x12\x04\xe7\x05&=\n\r\n\x05\x049\x02\
    \x04\x03\x12\x04\xe7\x05@A\n\x0c\n\x04\x049\x02\x05\x12\x04\xe8\x05\x08B\
    \n\r\n\x05\x049\x02\x05\x06\x12\x04\xe8\x05\x08%\n\r\n\x05\x049\x02\x05\
    \x01\x12\x04\xe8\x05&=\n\r\n\x05\x049\x02\x05\x03\x12\x04\xe8\x05@A\n\
    \x0c\n\x04\x049\x02\x06\x12\x04\xe9\x05\x08F\n\r\n\x05\x049\x02\x06\x06\
    \x12\x04\xe9\x05\x08'\n\r\n\x05\x049\x02\x06\x01\x12\x04\xe9\x05(A\n\r\n\
    \x05\x049\x02\x06\x03\x12\x04\xe9\x05DE\n\x0c\n\x04\x049\x02\x07\x12\x04\
    \xea\x05\x08G\n\r\n\x05\x049\x02\x07\x06\x12\x04\xea\x05\x08+\n\r\n\x05\
    \x049\x02\x07\x01\x12\x04\xea\x05,B\n\r\n\x05\x049\x02\x07\x03\x12\x04\
    \xea\x05EF\n\x0c\n\x04\x049\x02\x08\x12\x04\xeb\x05\x08E\n\r\n\x05\x049\
    \x02\x08\x06\x12\x04\xeb\x05\x08*\n\r\n\x05\x049\x02\x08\x01\x12\x04\xeb\
    \x05+@\n\r\n\x05\x049\x02\x08\x03\x12\x04\xeb\x05CD\n\x0c\n\x04\x049\x02\
    \t\x12\x04\xec\x05\x08G\n\r\n\x05\x049\x02\t\x06\x12\x04\xec\x05\x08'\n\
    \r\n\x05\x049\x02\t\x01\x12\x04\xec\x05(A\n\r\n\x05\x049\x02\t\x03\x12\
    \x04\xec\x05DF\n\x0c\n\x04\x049\x02\n\x12\x04\xed\x05\x08J\n\r\n\x05\x04\
    9\x02\n\x06\x12\x04\xed\x05\x08,\n\r\n\x05\x049\x02\n\x01\x12\x04\xed\
    \x05-D\n\r\n\x05\x049\x02\n\x03\x12\x04\xed\x05GI\n\x0c\n\x04\x049\x02\
    \x0b\x12\x04\xee\x05\x08F\n\r\n\x05\x049\x02\x0b\x06\x12\x04\xee\x05\x08\
    *\n\r\n\x05\x049\x02\x0b\x01\x12\x04\xee\x05+@\n\r\n\x05\x049\x02\x0b\
    \x03\x12\x04\xee\x05CE\n\x0c\n\x04\x049\x02\x0c\x12\x04\xef\x05\x08K\n\r\
    \n\x05\x049\x02\x0c\x06\x12\x04\xef\x05\x08)\n\r\n\x05\x049\x02\x0c\x01\
    \x12\x04\xef\x05*E\n\r\n\x05\x049\x02\x0c\x03\x12\x04\xef\x05HJ\n\x0c\n\
    \x04\x049\x02\r\x12\x04\xf0\x05\x08O\n\r\n\x05\x049\x02\r\x06\x12\x04\
    \xf0\x05\x08+\n\r\n\x05\x049\x02\r\x01\x12\x04\xf0\x05,I\n\r\n\x05\x049\
    \x02\r\x03\x12\x04\xf0\x05LN\n\x0c\n\x04\x049\x02\x0e\x12\x04\xf1\x05\
    \x08I\n\r\n\x05\x049\x02\x0e\x06\x12\x04\xf1\x05\x08(\n\r\n\x05\x049\x02\
    \x0e\x01\x12\x04\xf1\x05)C\n\r\n\x05\x049\x02\x0e\x03\x12\x04\xf1\x05FH\
    \n\x0c\n\x04\x049\x02\x0f\x12\x04\xf2\x05\x08?\n\r\n\x05\x049\x02\x0f\
    \x06\x12\x04\xf2\x05\x08#\n\r\n\x05\x049\x02\x0f\x01\x12\x04\xf2\x05$9\n\
    \r\n\x05\x049\x02\x0f\x03\x12\x04\xf2\x05<>\n\x0c\n\x04\x049\x02\x10\x12\
    \x04\xf4\x05\x04\"\n\r\n\x05\x049\x02\x10\x05\x12\x04\xf4\x05\x04\n\n\r\
    \n\x05\x049\x02\x10\x01\x12\x04\xf4\x05\x0b\x1c\n\r\n\x05\x049\x02\x10\
    \x03\x12\x04\xf4\x05\x1f!\n\x0c\n\x04\x049\x02\x11\x12\x04\xf5\x05\x04\
    \x1f\n\r\n\x05\x049\x02\x11\x05\x12\x04\xf5\x05\x04\n\n\r\n\x05\x049\x02\
    \x11\x01\x12\x04\xf5\x05\x0b\x19\n\r\n\x05\x049\x02\x11\x03\x12\x04\xf5\
    \x05\x1c\x1e\n\x0c\n\x02\x04:\x12\x06\xf8\x05\0\x80\x06\x01\n\x0b\n\x03\
    \x04:\x01\x12\x04\xf8\x05\x08\x1a\n\x0e\n\x04\x04:\x03\0\x12\x06\xfa\x05\
    \x04\xfe\x05\x05\n\r\n\x05\x04:\x03\0\x01\x12\x04\xfa\x05\x0c\x17\n\x0e\
    \n\x06\x04:\x03\0\x02\0\x12\x04\xfc\x05\x08\x20\n\x0f\n\x07\x04:\x03\0\
    \x02\0\x06\x12\x04\xfc\x05\x08\x12\n\x0f\n\x07\x04:\x03\0\x02\0\x01\x12\
    \x04\xfc\x05\x13\x1b\n\x0f\n\x07\x04:\x03\0\x02\0\x03\x12\x04\xfc\x05\
    \x1e\x1f\n\x0e\n\x06\x04:\x03\0\x02\x01\x12\x04\xfd\x05\x08\x1c\n\x0f\n\
    \x07\x04:\x03\0\x02\x01\x05\x12\x04\xfd\x05\x08\x0c\n\x0f\n\x07\x04:\x03\
    \0\x02\x01\x01\x12\x04\xfd\x05\r\x17\n\x0f\n\x07\x04:\x03\0\x02\x01\x03\
    \x12\x04\xfd\x05\x1a\x1b\n\x0c\n\x04\x04:\x02\0\x12\x04\xff\x05\x04%\n\r\
    \n\x05\x04:\x02\0\x04\x12\x04\xff\x05\x04\x0c\n\r\n\x05\x04:\x02\0\x06\
    \x12\x04\xff\x05\r\x18\n\r\n\x05\x04:\x02\0\x01\x12\x04\xff\x05\x19\x20\
    \n\r\n\x05\x04:\x02\0\x03\x12\x04\xff\x05#$\n\x0c\n\x02\x05\x0e\x12\x06\
    \x82\x06\0\x87\x06\x01\n\x0b\n\x03\x05\x0e\x01\x12\x04\x82\x06\x05\x16\n\
    \x0c\n\x04\x05\x0e\x02\0\x12\x04\x84\x06\x04\x1d\n\r\n\x05\x05\x0e\x02\0\
    \x01\x12\x04\x84\x06\x04\x18\n\r\n\x05\x05\x0e\x02\0\x02\x12\x04\x84\x06\
    \x1b\x1c\n\x0c\n\x04\x05\x0e\x02\x01\x12\x04\x85\x06\x04%\n\r\n\x05\x05\
    \x0e\x02\x01\x01\x12\x04\x85\x06\x04\x20\n\r\n\x05\x05\x0e\x02\x01\x02\
    \x12\x04\x85\x06#$\n\x0c\n\x04\x05\x0e\x02\x02\x12\x04\x86\x06\x04\x20\n\
    \r\n\x05\x05\x0e\x02\x02\x01\x12\x04\x86\x06\x04\x1b\n\r\n\x05\x05\x0e\
    \x02\x02\x02\x12\x04\x86\x06\x1e\x1f\n\x0c\n\x02\x04;\x12\x06\x89\x06\0\
    \x91\x06\x01\n\x0b\n\x03\x04;\x01\x12\x04\x89\x06\x08\x18\n\x0e\n\x04\
    \x04;\x03\0\x12\x06\x8b\x06\x04\x8f\x06\x05\n\r\n\x05\x04;\x03\0\x01\x12\
    \x04\x8b\x06\x0c\x17\n\x0e\n\x06\x04;\x03\0\x02\0\x12\x04\x8d\x06\x08\
    \x20\n\x0f\n\x07\x04;\x03\0\x02\0\x06\x12\x04\x8d\x06\x08\x12\n\x0f\n\
    \x07\x04;\x03\0\x02\0\x01\x12\x04\x8d\x06\x13\x1b\n\x0f\n\x07\x04;\x03\0\
    \x02\0\x03\x12\x04\x8d\x06\x1e\x1f\n\x0e\n\x06\x04;\x03\0\x02\x01\x12\
    \x04\x8e\x06\x08*\n\x0f\n\x07\x04;\x03\0\x02\x01\x06\x12\x04\x8e\x06\x08\
    \x19\n\x0f\n\x07\x04;\x03\0\x02\x01\x01\x12\x04\x8e\x06\x1a%\n\x0f\n\x07\
    \x04;\x03\0\x02\x01\x03\x12\x04\x8e\x06()\n\x0c\n\x04\x04;\x02\0\x12\x04\
    \x90\x06\x04%\n\r\n\x05\x04;\x02\0\x04\x12\x04\x90\x06\x04\x0c\n\r\n\x05\
    \x04;\x02\0\x06\x12\x04\x90\x06\r\x18\n\r\n\x05\x04;\x02\0\x01\x12\x04\
    \x90\x06\x19\x20\n\r\n\x05\x04;\x02\0\x03\x12\x04\x90\x06#$\n\x0c\n\x02\
    \x04<\x12\x06\x93\x06\0\x96\x06\x01\n\x0b\n\x03\x04<\x01\x12\x04\x93\x06\
    \x08\x18\n\x0c\n\x04\x04<\x02\0\x12\x04\x95\x06\x04&\n\r\n\x05\x04<\x02\
    \0\x04\x12\x04\x95\x06\x04\x0c\n\r\n\x05\x04<\x02\0\x06\x12\x04\x95\x06\
    \r\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\x95\x06\x18!\n\r\n\x05\x04<\x02\
    \0\x03\x12\x04\x95\x06$%\n\x0c\n\x02\x05\x0f\x12\x06\x98\x06\0\xa4\x06\
    \x01\n\x0b\n\x03\x05\x0f\x01\x12\x04\x98\x06\x05\x17\n\x0c\n\x04\x05\x0f\
    \x02\0\x12\x04\x9a\x06\x04\x20\n\r\n\x05\x05\x0f\x02\0\x01\x12\x04\x9a\
    \x06\x04\x1b\n\r\n\x05\x05\x0f\x02\0\x02\x12\x04\x9a\x06\x1e\x1f\n\x0c\n\
    \x04\x05\x0f\x02\x01\x12\x04\x9b\x06\x04)\n\r\n\x05\x05\x0f\x02\x01\x01\
    \x12\x04\x9b\x06\x04$\n\r\n\x05\x05\x0f\x02\x01\x02\x12\x04\x9b\x06'(\n\
    \x0c\n\x04\x05\x0f\x02\x02\x12\x04\x9c\x06\x04)\n\r\n\x05\x05\x0f\x02\
    \x02\x01\x12\x04\x9c\x06\x04$\n\r\n\x05\x05\x0f\x02\x02\x02\x12\x04\x9c\
    \x06'(\n\x0c\n\x04\x05\x0f\x02\x03\x12\x04\x9d\x06\x04(\n\r\n\x05\x05\
    \x0f\x02\x03\x01\x12\x04\x9d\x06\x04#\n\r\n\x05\x05\x0f\x02\x03\x02\x12\
    \x04\x9d\x06&'\n\x0c\n\x04\x05\x0f\x02\x04\x12\x04\x9e\x06\x04(\n\r\n\
    \x05\x05\x0f\x02\x04\x01\x12\x04\x9e\x06\x04#\n\r\n\x05\x05\x0f\x02\x04\
    \x02\x12\x04\x9e\x06&'\n\x0c\n\x04\x05\x0f\x02\x05\x12\x04\x9f\x06\x04%\
    \n\r\n\x05\x05\x0f\x02\x05\x01\x12\x04\x9f\x06\x04\x20\n\r\n\x05\x05\x0f\
    \x02\x05\x02\x12\x04\x9f\x06#$\n\x0c\n\x04\x05\x0f\x02\x06\x12\x04\xa0\
    \x06\x04%\n\r\n\x05\x05\x0f\x02\x06\x01\x12\x04\xa0\x06\x04\x20\n\r\n\
    \x05\x05\x0f\x02\x06\x02\x12\x04\xa0\x06#$\n\x0c\n\x04\x05\x0f\x02\x07\
    \x12\x04\xa1\x06\x04(\n\r\n\x05\x05\x0f\x02\x07\x01\x12\x04\xa1\x06\x04#\
    \n\r\n\x05\x05\x0f\x02\x07\x02\x12\x04\xa1\x06&'\n\x0c\n\x04\x05\x0f\x02\
    \x08\x12\x04\xa2\x06\x04&\n\r\n\x05\x05\x0f\x02\x08\x01\x12\x04\xa2\x06\
    \x04!\n\r\n\x05\x05\x0f\x02\x08\x02\x12\x04\xa2\x06$%\n\x0c\n\x04\x05\
    \x0f\x02\t\x12\x04\xa3\x06\x04(\n\r\n\x05\x05\x0f\x02\t\x01\x12\x04\xa3\
    \x06\x04#\n\r\n\x05\x05\x0f\x02\t\x02\x12\x04\xa3\x06&'\n\x0c\n\x02\x04=\
    \x12\x06\xa6\x06\0\xa9\x06\x01\n\x0b\n\x03\x04=\x01\x12\x04\xa6\x06\x08\
    \"\n\x0c\n\x02\x04>\x12\x06\xab\x06\0\xb5\x06\x01\n\x0b\n\x03\x04>\x01\
    \x12\x04\xab\x06\x08\x20\n\x0e\n\x04\x04>\x03\0\x12\x06\xad\x06\x04\xb2\
    \x06\x05\n\r\n\x05\x04>\x03\0\x01\x12\x04\xad\x06\x0c\x18\n\x0e\n\x06\
    \x04>\x03\0\x02\0\x12\x04\xaf\x06\x08$\n\x0f\n\x07\x04>\x03\0\x02\0\x06\
    \x12\x04\xaf\x06\x08\x1a\n\x0f\n\x07\x04>\x03\0\x02\0\x01\x12\x04\xaf\
    \x06\x1b\x1f\n\x0f\n\x07\x04>\x03\0\x02\0\x03\x12\x04\xaf\x06\"#\n\x0e\n\
    \x06\x04>\x03\0\x02\x01\x12\x04\xb0\x06\x08\x1d\n\x0f\n\x07\x04>\x03\0\
    \x02\x01\x05\x12\x04\xb0\x06\x08\r\n\x0f\n\x07\x04>\x03\0\x02\x01\x01\
    \x12\x04\xb0\x06\x0e\x18\n\x0f\n\x07\x04>\x03\0\x02\x01\x03\x12\x04\xb0\
    \x06\x1b\x1c\n\x0e\n\x06\x04>\x03\0\x02\x02\x12\x04\xb1\x06\x08\x20\n\
    \x0f\n\x07\x04>\x03\0\x02\x02\x05\x12\x04\xb1\x06\x08\r\n\x0f\n\x07\x04>\
    \x03\0\x02\x02\x01\x12\x04\xb1\x06\x0e\x1b\n\x0f\n\x07\x04>\x03\0\x02\
    \x02\x03\x12\x04\xb1\x06\x1e\x1f\n\x0c\n\x04\x04>\x02\0\x12\x04\xb3\x06\
    \x04)\n\r\n\x05\x04>\x02\0\x04\x12\x04\xb3\x06\x04\x0c\n\r\n\x05\x04>\
    \x02\0\x06\x12\x04\xb3\x06\r\x19\n\r\n\x05\x04>\x02\0\x01\x12\x04\xb3\
    \x06\x1a$\n\r\n\x05\x04>\x02\0\x03\x12\x04\xb3\x06'(\n\x16\n\x04\x04>\
    \x02\x01\x12\x04\xb4\x06\x04\x1b\"\x08max\x20100\n\n\r\n\x05\x04>\x02\
    \x01\x05\x12\x04\xb4\x06\x04\t\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xb4\
    \x06\n\x16\n\r\n\x05\x04>\x02\x01\x03\x12\x04\xb4\x06\x19\x1a\n\x9e\x01\
    \n\x02\x05\x10\x12\x06\xba\x06\0\xd6\x06\x01\x1a\x8f\x01////////////////\
    //////////////////////////////////////////////\n/\x20App\x20Fetch\x20Dat\
    a\n//////////////////////////////////////////////////////////////\n\n\
    \x0b\n\x03\x05\x10\x01\x12\x04\xba\x06\x05\x14\n\x0c\n\x04\x05\x10\x02\0\
    \x12\x04\xbc\x06\x04\x1d\n\r\n\x05\x05\x10\x02\0\x01\x12\x04\xbc\x06\x04\
    \x18\n\r\n\x05\x05\x10\x02\0\x02\x12\x04\xbc\x06\x1b\x1c\n\x0c\n\x04\x05\
    \x10\x02\x01\x12\x04\xbd\x06\x04#\n\r\n\x05\x05\x10\x02\x01\x01\x12\x04\
    \xbd\x06\x04\x1e\n\r\n\x05\x05\x10\x02\x01\x02\x12\x04\xbd\x06!\"\n\x0c\
    \n\x04\x05\x10\x02\x02\x12\x04\xbe\x06\x04(\n\r\n\x05\x05\x10\x02\x02\
    \x01\x12\x04\xbe\x06\x04#\n\r\n\x05\x05\x10\x02\x02\x02\x12\x04\xbe\x06&\
    '\n\x0c\n\x04\x05\x10\x02\x03\x12\x04\xbf\x06\x04+\n\r\n\x05\x05\x10\x02\
    \x03\x01\x12\x04\xbf\x06\x04&\n\r\n\x05\x05\x10\x02\x03\x02\x12\x04\xbf\
    \x06)*\n\x0c\n\x04\x05\x10\x02\x04\x12\x04\xc0\x06\x04+\n\r\n\x05\x05\
    \x10\x02\x04\x01\x12\x04\xc0\x06\x04&\n\r\n\x05\x05\x10\x02\x04\x02\x12\
    \x04\xc0\x06)*\n\x0c\n\x04\x05\x10\x02\x05\x12\x04\xc1\x06\x04&\n\r\n\
    \x05\x05\x10\x02\x05\x01\x12\x04\xc1\x06\x04!\n\r\n\x05\x05\x10\x02\x05\
    \x02\x12\x04\xc1\x06$%\n\x0c\n\x04\x05\x10\x02\x06\x12\x04\xc2\x06\x04$\
    \n\r\n\x05\x05\x10\x02\x06\x01\x12\x04\xc2\x06\x04\x1f\n\r\n\x05\x05\x10\
    \x02\x06\x02\x12\x04\xc2\x06\"#\n\x0c\n\x04\x05\x10\x02\x07\x12\x04\xc3\
    \x06\x04$\n\r\n\x05\x05\x10\x02\x07\x01\x12\x04\xc3\x06\x04\x1f\n\r\n\
    \x05\x05\x10\x02\x07\x02\x12\x04\xc3\x06\"#\n\x0c\n\x04\x05\x10\x02\x08\
    \x12\x04\xc4\x06\x04'\n\r\n\x05\x05\x10\x02\x08\x01\x12\x04\xc4\x06\x04\
    \"\n\r\n\x05\x05\x10\x02\x08\x02\x12\x04\xc4\x06%&\n\x0c\n\x04\x05\x10\
    \x02\t\x12\x04\xc5\x06\x04(\n\r\n\x05\x05\x10\x02\t\x01\x12\x04\xc5\x06\
    \x04#\n\r\n\x05\x05\x10\x02\t\x02\x12\x04\xc5\x06&'\n\x0c\n\x04\x05\x10\
    \x02\n\x12\x04\xc6\x06\x04)\n\r\n\x05\x05\x10\x02\n\x01\x12\x04\xc6\x06\
    \x04#\n\r\n\x05\x05\x10\x02\n\x02\x12\x04\xc6\x06&(\n\x0c\n\x04\x05\x10\
    \x02\x0b\x12\x04\xc7\x06\x04,\n\r\n\x05\x05\x10\x02\x0b\x01\x12\x04\xc7\
    \x06\x04&\n\r\n\x05\x05\x10\x02\x0b\x02\x12\x04\xc7\x06)+\n\x0c\n\x04\
    \x05\x10\x02\x0c\x12\x04\xc8\x06\x04,\n\r\n\x05\x05\x10\x02\x0c\x01\x12\
    \x04\xc8\x06\x04&\n\r\n\x05\x05\x10\x02\x0c\x02\x12\x04\xc8\x06)+\n\x0c\
    \n\x04\x05\x10\x02\r\x12\x04\xc9\x06\x04,\n\r\n\x05\x05\x10\x02\r\x01\
    \x12\x04\xc9\x06\x04&\n\r\n\x05\x05\x10\x02\r\x02\x12\x04\xc9\x06)+\n\
    \x0c\n\x04\x05\x10\x02\x0e\x12\x04\xca\x06\x04/\n\r\n\x05\x05\x10\x02\
    \x0e\x01\x12\x04\xca\x06\x04)\n\r\n\x05\x05\x10\x02\x0e\x02\x12\x04\xca\
    \x06,.\n\x0c\n\x04\x05\x10\x02\x0f\x12\x04\xcb\x06\x04%\n\r\n\x05\x05\
    \x10\x02\x0f\x01\x12\x04\xcb\x06\x04\x1f\n\r\n\x05\x05\x10\x02\x0f\x02\
    \x12\x04\xcb\x06\"$\n\x0c\n\x04\x05\x10\x02\x10\x12\x04\xcc\x06\x043\n\r\
    \n\x05\x05\x10\x02\x10\x01\x12\x04\xcc\x06\x04-\n\r\n\x05\x05\x10\x02\
    \x10\x02\x12\x04\xcc\x0602\n\x0c\n\x04\x05\x10\x02\x11\x12\x04\xcd\x06\
    \x04(\n\r\n\x05\x05\x10\x02\x11\x01\x12\x04\xcd\x06\x04\"\n\r\n\x05\x05\
    \x10\x02\x11\x02\x12\x04\xcd\x06%'\n\x0c\n\x04\x05\x10\x02\x12\x12\x04\
    \xce\x06\x04'\n\r\n\x05\x05\x10\x02\x12\x01\x12\x04\xce\x06\x04!\n\r\n\
    \x05\x05\x10\x02\x12\x02\x12\x04\xce\x06$&\n\x0c\n\x04\x05\x10\x02\x13\
    \x12\x04\xcf\x06\x04*\n\r\n\x05\x05\x10\x02\x13\x01\x12\x04\xcf\x06\x04$\
    \n\r\n\x05\x05\x10\x02\x13\x02\x12\x04\xcf\x06')\n\x0c\n\x04\x05\x10\x02\
    \x14\x12\x04\xd0\x06\x04+\n\r\n\x05\x05\x10\x02\x14\x01\x12\x04\xd0\x06\
    \x04%\n\r\n\x05\x05\x10\x02\x14\x02\x12\x04\xd0\x06(*\n\x0c\n\x04\x05\
    \x10\x02\x15\x12\x04\xd1\x06\x048\n\r\n\x05\x05\x10\x02\x15\x01\x12\x04\
    \xd1\x06\x042\n\r\n\x05\x05\x10\x02\x15\x02\x12\x04\xd1\x0657\n\x0c\n\
    \x04\x05\x10\x02\x16\x12\x04\xd2\x06\x04.\n\r\n\x05\x05\x10\x02\x16\x01\
    \x12\x04\xd2\x06\x04(\n\r\n\x05\x05\x10\x02\x16\x02\x12\x04\xd2\x06+-\n\
    \x0c\n\x04\x05\x10\x02\x17\x12\x04\xd3\x06\x04&\n\r\n\x05\x05\x10\x02\
    \x17\x01\x12\x04\xd3\x06\x04\x20\n\r\n\x05\x05\x10\x02\x17\x02\x12\x04\
    \xd3\x06#%\n\x0c\n\x04\x05\x10\x02\x18\x12\x04\xd4\x06\x04(\n\r\n\x05\
    \x05\x10\x02\x18\x01\x12\x04\xd4\x06\x04\"\n\r\n\x05\x05\x10\x02\x18\x02\
    \x12\x04\xd4\x06%'\n\x0c\n\x04\x05\x10\x02\x19\x12\x04\xd5\x06\x04(\n\r\
    \n\x05\x05\x10\x02\x19\x01\x12\x04\xd5\x06\x04\"\n\r\n\x05\x05\x10\x02\
    \x19\x02\x12\x04\xd5\x06%'\n\x0c\n\x02\x04?\x12\x06\xd8\x06\0\xdc\x06\
    \x01\n\x0b\n\x03\x04?\x01\x12\x04\xd8\x06\x08\x1f\n\x0c\n\x04\x04?\x02\0\
    \x12\x04\xda\x06\x04\x19\n\r\n\x05\x04?\x02\0\x05\x12\x04\xda\x06\x04\n\
    \n\r\n\x05\x04?\x02\0\x01\x12\x04\xda\x06\x0b\x14\n\r\n\x05\x04?\x02\0\
    \x03\x12\x04\xda\x06\x17\x18\n\x0c\n\x04\x04?\x02\x01\x12\x04\xdb\x06\
    \x04!\n\r\n\x05\x04?\x02\x01\x06\x12\x04\xdb\x06\x04\x13\n\r\n\x05\x04?\
    \x02\x01\x01\x12\x04\xdb\x06\x14\x1c\n\r\n\x05\x04?\x02\x01\x03\x12\x04\
    \xdb\x06\x1f\x20\n\x0c\n\x02\x04@\x12\x06\xde\x06\0\xe3\x06\x01\n\x0b\n\
    \x03\x04@\x01\x12\x04\xde\x06\x08\x1d\n\x0c\n\x04\x04@\x02\0\x12\x04\xe0\
    \x06\x04\x14\n\r\n\x05\x04@\x02\0\x05\x12\x04\xe0\x06\x04\t\n\r\n\x05\
    \x04@\x02\0\x01\x12\x04\xe0\x06\n\x0f\n\r\n\x05\x04@\x02\0\x03\x12\x04\
    \xe0\x06\x12\x13\n\x19\n\x04\x04@\x02\x01\x12\x04\xe1\x06\x04&\"\x0bdepr\
    ecated\n\n\r\n\x05\x04@\x02\x01\x05\x12\x04\xe1\x06\x04\t\n\r\n\x05\x04@\
    \x02\x01\x01\x12\x04\xe1\x06\n\x0f\n\r\n\x05\x04@\x02\x01\x03\x12\x04\
    \xe1\x06\x12\x13\n\r\n\x05\x04@\x02\x01\x08\x12\x04\xe1\x06\x14%\n\x0e\n\
    \x06\x04@\x02\x01\x08\x03\x12\x04\xe1\x06\x15$\n\x0c\n\x04\x04@\x02\x02\
    \x12\x04\xe2\x06\x04#\n\r\n\x05\x04@\x02\x02\x05\x12\x04\xe2\x06\x04\x08\
    \n\r\n\x05\x04@\x02\x02\x01\x12\x04\xe2\x06\t\x1e\n\r\n\x05\x04@\x02\x02\
    \x03\x12\x04\xe2\x06!\"\n\x0c\n\x02\x05\x11\x12\x06\xe5\x06\0\xec\x06\
    \x01\n\x0b\n\x03\x05\x11\x01\x12\x04\xe5\x06\x05\x13\n\x0c\n\x04\x05\x11\
    \x02\0\x12\x04\xe7\x06\x04\x1c\n\r\n\x05\x05\x11\x02\0\x01\x12\x04\xe7\
    \x06\x04\x17\n\r\n\x05\x05\x11\x02\0\x02\x12\x04\xe7\x06\x1a\x1b\n\x0c\n\
    \x04\x05\x11\x02\x01\x12\x04\xe8\x06\x04\x1e\n\r\n\x05\x05\x11\x02\x01\
    \x01\x12\x04\xe8\x06\x04\x19\n\r\n\x05\x05\x11\x02\x01\x02\x12\x04\xe8\
    \x06\x1c\x1d\n\x0c\n\x04\x05\x11\x02\x02\x12\x04\xe9\x06\x04\x1d\n\r\n\
    \x05\x05\x11\x02\x02\x01\x12\x04\xe9\x06\x04\x18\n\r\n\x05\x05\x11\x02\
    \x02\x02\x12\x04\xe9\x06\x1b\x1c\n\x0c\n\x04\x05\x11\x02\x03\x12\x04\xea\
    \x06\x04!\n\r\n\x05\x05\x11\x02\x03\x01\x12\x04\xea\x06\x04\x1c\n\r\n\
    \x05\x05\x11\x02\x03\x02\x12\x04\xea\x06\x1f\x20\n\x0c\n\x04\x05\x11\x02\
    \x04\x12\x04\xeb\x06\x04\"\n\r\n\x05\x05\x11\x02\x04\x01\x12\x04\xeb\x06\
    \x04\x1d\n\r\n\x05\x05\x11\x02\x04\x02\x12\x04\xeb\x06\x20!\n\x0c\n\x02\
    \x05\x12\x12\x06\xee\x06\0\xf3\x06\x01\n\x0b\n\x03\x05\x12\x01\x12\x04\
    \xee\x06\x05\x1a\n\x0c\n\x04\x05\x12\x02\0\x12\x04\xf0\x06\x04#\n\r\n\
    \x05\x05\x12\x02\0\x01\x12\x04\xf0\x06\x04\x1e\n\r\n\x05\x05\x12\x02\0\
    \x02\x12\x04\xf0\x06!\"\n\x0c\n\x04\x05\x12\x02\x01\x12\x04\xf1\x06\x04#\
    \n\r\n\x05\x05\x12\x02\x01\x01\x12\x04\xf1\x06\x04\x1e\n\r\n\x05\x05\x12\
    \x02\x01\x02\x12\x04\xf1\x06!\"\n\x0c\n\x04\x05\x12\x02\x02\x12\x04\xf2\
    \x06\x04&\n\r\n\x05\x05\x12\x02\x02\x01\x12\x04\xf2\x06\x04!\n\r\n\x05\
    \x05\x12\x02\x02\x02\x12\x04\xf2\x06$%\n\x0c\n\x02\x04A\x12\x06\xf5\x06\
    \0\x89\x07\x01\n\x0b\n\x03\x04A\x01\x12\x04\xf5\x06\x08\x1c\n\x0e\n\x04\
    \x04A\x03\0\x12\x06\xf7\x06\x04\xfb\x06\x05\n\r\n\x05\x04A\x03\0\x01\x12\
    \x04\xf7\x06\x0c\x1d\n\x0e\n\x06\x04A\x03\0\x02\0\x12\x04\xf9\x06\x08\
    \x1a\n\x0f\n\x07\x04A\x03\0\x02\0\x06\x12\x04\xf9\x06\x08\x0f\n\x0f\n\
    \x07\x04A\x03\0\x02\0\x01\x12\x04\xf9\x06\x10\x15\n\x0f\n\x07\x04A\x03\0\
    \x02\0\x03\x12\x04\xf9\x06\x18\x19\n\x0e\n\x06\x04A\x03\0\x02\x01\x12\
    \x04\xfa\x06\x08+\n\x0f\n\x07\x04A\x03\0\x02\x01\x06\x12\x04\xfa\x06\x08\
    \x1d\n\x0f\n\x07\x04A\x03\0\x02\x01\x01\x12\x04\xfa\x06\x1e&\n\x0f\n\x07\
    \x04A\x03\0\x02\x01\x03\x12\x04\xfa\x06)*\n\x0c\n\x04\x04A\x02\0\x12\x04\
    \xfd\x06\x04\x20\n\r\n\x05\x04A\x02\0\x06\x12\x04\xfd\x06\x04\r\n\r\n\
    \x05\x04A\x02\0\x01\x12\x04\xfd\x06\x0e\x1b\n\r\n\x05\x04A\x02\0\x03\x12\
    \x04\xfd\x06\x1e\x1f\n\x0c\n\x04\x04A\x02\x01\x12\x04\xfe\x06\x04(\n\r\n\
    \x05\x04A\x02\x01\x06\x12\x04\xfe\x06\x04\x12\n\r\n\x05\x04A\x02\x01\x01\
    \x12\x04\xfe\x06\x13#\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xfe\x06&'\n\x0c\
    \n\x04\x04A\x02\x02\x12\x04\xff\x06\x04(\n\r\n\x05\x04A\x02\x02\x06\x12\
    \x04\xff\x06\x04\x12\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xff\x06\x13#\n\r\
    \n\x05\x04A\x02\x02\x03\x12\x04\xff\x06&'\nM\n\x04\x04A\x02\x03\x12\x04\
    \x80\x07\x04\x18\"?\x20targetAccount\x20like/comment\x20me\x20||\x20I\
    \x20like/comment\x20targetAccount\n\n\r\n\x05\x04A\x02\x03\x05\x12\x04\
    \x80\x07\x04\t\n\r\n\x05\x04A\x02\x03\x01\x12\x04\x80\x07\n\x13\n\r\n\
    \x05\x04A\x02\x03\x03\x12\x04\x80\x07\x16\x17\n\x0c\n\x04\x04A\x02\x04\
    \x12\x04\x81\x07\x04\x1b\n\r\n\x05\x04A\x02\x04\x05\x12\x04\x81\x07\x04\
    \t\n\r\n\x05\x04A\x02\x04\x01\x12\x04\x81\x07\n\x16\n\r\n\x05\x04A\x02\
    \x04\x03\x12\x04\x81\x07\x19\x1a\n\x0c\n\x04\x04A\x02\x05\x12\x04\x82\
    \x07\x04.\n\r\n\x05\x04A\x02\x05\x05\x12\x04\x82\x07\x04\t\n\r\n\x05\x04\
    A\x02\x05\x01\x12\x04\x82\x07\n\x17\n\r\n\x05\x04A\x02\x05\x03\x12\x04\
    \x82\x07\x1a\x1b\n\r\n\x05\x04A\x02\x05\x08\x12\x04\x82\x07\x1c-\n\x0e\n\
    \x06\x04A\x02\x05\x08\x03\x12\x04\x82\x07\x1d,\n\x0c\n\x04\x04A\x02\x06\
    \x12\x04\x83\x07\x04!\n\r\n\x05\x04A\x02\x06\x05\x12\x04\x83\x07\x04\t\n\
    \r\n\x05\x04A\x02\x06\x01\x12\x04\x83\x07\n\x1c\n\r\n\x05\x04A\x02\x06\
    \x03\x12\x04\x83\x07\x1f\x20\n5\n\x04\x04A\x02\x07\x12\x04\x84\x07\x04\
    \x16\"'for\x20unlike\x20/\x20uncomment\x20/\x20story\x20viewers\n\n\r\n\
    \x05\x04A\x02\x07\x06\x12\x04\x84\x07\x04\x0b\n\r\n\x05\x04A\x02\x07\x01\
    \x12\x04\x84\x07\x0c\x11\n\r\n\x05\x04A\x02\x07\x03\x12\x04\x84\x07\x14\
    \x15\n\x0c\n\x04\x04A\x02\x08\x12\x04\x85\x07\x041\n\r\n\x05\x04A\x02\
    \x08\x04\x12\x04\x85\x07\x04\x0c\n\r\n\x05\x04A\x02\x08\x06\x12\x04\x85\
    \x07\r\x1e\n\r\n\x05\x04A\x02\x08\x01\x12\x04\x85\x07\x1f,\n\r\n\x05\x04\
    A\x02\x08\x03\x12\x04\x85\x07/0\n\x0c\n\x04\x04A\x02\t\x12\x04\x86\x07\
    \x04$\n\r\n\x05\x04A\x02\t\x05\x12\x04\x86\x07\x04\x08\n\r\n\x05\x04A\
    \x02\t\x01\x12\x04\x86\x07\t\x1e\n\r\n\x05\x04A\x02\t\x03\x12\x04\x86\
    \x07!#\n\x1c\n\x04\x04A\x02\n\x12\x04\x87\x07\x04\x18\"\x0efor\x20uncomm\
    ent\n\n\r\n\x05\x04A\x02\n\x05\x12\x04\x87\x07\x04\n\n\r\n\x05\x04A\x02\
    \n\x01\x12\x04\x87\x07\x0b\x12\n\r\n\x05\x04A\x02\n\x03\x12\x04\x87\x07\
    \x15\x17\n!\n\x04\x04A\x02\x0b\x12\x04\x88\x07\x04\x15\"\x13for\x20who\
    \x20admires\x20me\n\n\r\n\x05\x04A\x02\x0b\x05\x12\x04\x88\x07\x04\t\n\r\
    \n\x05\x04A\x02\x0b\x01\x12\x04\x88\x07\n\x0f\n\r\n\x05\x04A\x02\x0b\x03\
    \x12\x04\x88\x07\x12\x14\n\x0c\n\x02\x05\x13\x12\x06\x8b\x07\0\xac\x07\
    \x01\n\x0b\n\x03\x05\x13\x01\x12\x04\x8b\x07\x05\x1a\n\x0c\n\x04\x05\x13\
    \x02\0\x12\x04\x8d\x07\x04#\n\r\n\x05\x05\x13\x02\0\x01\x12\x04\x8d\x07\
    \x04\x1e\n\r\n\x05\x05\x13\x02\0\x02\x12\x04\x8d\x07!\"\n\x0c\n\x04\x05\
    \x13\x02\x01\x12\x04\x8e\x07\x04(\n\r\n\x05\x05\x13\x02\x01\x01\x12\x04\
    \x8e\x07\x04#\n\r\n\x05\x05\x13\x02\x01\x02\x12\x04\x8e\x07&'\n\x0c\n\
    \x04\x05\x13\x02\x02\x12\x04\x8f\x07\x04+\n\r\n\x05\x05\x13\x02\x02\x01\
    \x12\x04\x8f\x07\x04&\n\r\n\x05\x05\x13\x02\x02\x02\x12\x04\x8f\x07)*\n\
    \x0c\n\x04\x05\x13\x02\x03\x12\x04\x90\x07\x04,\n\r\n\x05\x05\x13\x02\
    \x03\x01\x12\x04\x90\x07\x04'\n\r\n\x05\x05\x13\x02\x03\x02\x12\x04\x90\
    \x07*+\n\x0c\n\x04\x05\x13\x02\x04\x12\x04\x91\x07\x04.\n\r\n\x05\x05\
    \x13\x02\x04\x01\x12\x04\x91\x07\x04)\n\r\n\x05\x05\x13\x02\x04\x02\x12\
    \x04\x91\x07,-\n\x0c\n\x04\x05\x13\x02\x05\x12\x04\x92\x07\x04*\n\r\n\
    \x05\x05\x13\x02\x05\x01\x12\x04\x92\x07\x04%\n\r\n\x05\x05\x13\x02\x05\
    \x02\x12\x04\x92\x07()\n\x0c\n\x04\x05\x13\x02\x06\x12\x04\x93\x07\x04,\
    \n\r\n\x05\x05\x13\x02\x06\x01\x12\x04\x93\x07\x04'\n\r\n\x05\x05\x13\
    \x02\x06\x02\x12\x04\x93\x07*+\n\x0c\n\x04\x05\x13\x02\x07\x12\x04\x94\
    \x07\x04/\n\r\n\x05\x05\x13\x02\x07\x01\x12\x04\x94\x07\x04*\n\r\n\x05\
    \x05\x13\x02\x07\x02\x12\x04\x94\x07-.\n\x0c\n\x04\x05\x13\x02\x08\x12\
    \x04\x95\x07\x04)\n\r\n\x05\x05\x13\x02\x08\x01\x12\x04\x95\x07\x04$\n\r\
    \n\x05\x05\x13\x02\x08\x02\x12\x04\x95\x07'(\n\x0c\n\x04\x05\x13\x02\t\
    \x12\x04\x96\x07\x040\n\r\n\x05\x05\x13\x02\t\x01\x12\x04\x96\x07\x04+\n\
    \r\n\x05\x05\x13\x02\t\x02\x12\x04\x96\x07./\n\x0c\n\x04\x05\x13\x02\n\
    \x12\x04\x97\x07\x042\n\r\n\x05\x05\x13\x02\n\x01\x12\x04\x97\x07\x04,\n\
    \r\n\x05\x05\x13\x02\n\x02\x12\x04\x97\x07/1\n\x0c\n\x04\x05\x13\x02\x0b\
    \x12\x04\x98\x07\x042\n\r\n\x05\x05\x13\x02\x0b\x01\x12\x04\x98\x07\x04,\
    \n\r\n\x05\x05\x13\x02\x0b\x02\x12\x04\x98\x07/1\n\x0c\n\x04\x05\x13\x02\
    \x0c\x12\x04\x99\x07\x04.\n\r\n\x05\x05\x13\x02\x0c\x01\x12\x04\x99\x07\
    \x04(\n\r\n\x05\x05\x13\x02\x0c\x02\x12\x04\x99\x07+-\n\x0c\n\x04\x05\
    \x13\x02\r\x12\x04\x9a\x07\x044\n\r\n\x05\x05\x13\x02\r\x01\x12\x04\x9a\
    \x07\x04.\n\r\n\x05\x05\x13\x02\r\x02\x12\x04\x9a\x0713\n\x0c\n\x04\x05\
    \x13\x02\x0e\x12\x04\x9b\x07\x04/\n\r\n\x05\x05\x13\x02\x0e\x01\x12\x04\
    \x9b\x07\x04)\n\r\n\x05\x05\x13\x02\x0e\x02\x12\x04\x9b\x07,.\n\x0c\n\
    \x04\x05\x13\x02\x0f\x12\x04\x9c\x07\x04-\n\r\n\x05\x05\x13\x02\x0f\x01\
    \x12\x04\x9c\x07\x04'\n\r\n\x05\x05\x13\x02\x0f\x02\x12\x04\x9c\x07*,\n\
    \x0c\n\x04\x05\x13\x02\x10\x12\x04\x9d\x07\x04.\n\r\n\x05\x05\x13\x02\
    \x10\x01\x12\x04\x9d\x07\x04(\n\r\n\x05\x05\x13\x02\x10\x02\x12\x04\x9d\
    \x07+-\n\x0c\n\x04\x05\x13\x02\x11\x12\x04\x9e\x07\x04.\n\r\n\x05\x05\
    \x13\x02\x11\x01\x12\x04\x9e\x07\x04(\n\r\n\x05\x05\x13\x02\x11\x02\x12\
    \x04\x9e\x07+-\n\x0c\n\x04\x05\x13\x02\x12\x12\x04\x9f\x07\x041\n\r\n\
    \x05\x05\x13\x02\x12\x01\x12\x04\x9f\x07\x04+\n\r\n\x05\x05\x13\x02\x12\
    \x02\x12\x04\x9f\x07.0\n\x0c\n\x04\x05\x13\x02\x13\x12\x04\xa0\x07\x04/\
    \n\r\n\x05\x05\x13\x02\x13\x01\x12\x04\xa0\x07\x04)\n\r\n\x05\x05\x13\
    \x02\x13\x02\x12\x04\xa0\x07,.\n\x0c\n\x04\x05\x13\x02\x14\x12\x04\xa1\
    \x07\x04&\n\r\n\x05\x05\x13\x02\x14\x01\x12\x04\xa1\x07\x04\x20\n\r\n\
    \x05\x05\x13\x02\x14\x02\x12\x04\xa1\x07#%\n\x0c\n\x04\x05\x13\x02\x15\
    \x12\x04\xa2\x07\x04)\n\r\n\x05\x05\x13\x02\x15\x01\x12\x04\xa2\x07\x04#\
    \n\r\n\x05\x05\x13\x02\x15\x02\x12\x04\xa2\x07&(\n\x0c\n\x04\x05\x13\x02\
    \x16\x12\x04\xa3\x07\x04,\n\r\n\x05\x05\x13\x02\x16\x01\x12\x04\xa3\x07\
    \x04&\n\r\n\x05\x05\x13\x02\x16\x02\x12\x04\xa3\x07)+\n\x0c\n\x04\x05\
    \x13\x02\x17\x12\x04\xa4\x07\x04,\n\r\n\x05\x05\x13\x02\x17\x01\x12\x04\
    \xa4\x07\x04&\n\r\n\x05\x05\x13\x02\x17\x02\x12\x04\xa4\x07)+\n\x0c\n\
    \x04\x05\x13\x02\x18\x12\x04\xa5\x07\x04>\n\r\n\x05\x05\x13\x02\x18\x01\
    \x12\x04\xa5\x07\x048\n\r\n\x05\x05\x13\x02\x18\x02\x12\x04\xa5\x07;=\n\
    \x0c\n\x04\x05\x13\x02\x19\x12\x04\xa6\x07\x04/\n\r\n\x05\x05\x13\x02\
    \x19\x01\x12\x04\xa6\x07\x04)\n\r\n\x05\x05\x13\x02\x19\x02\x12\x04\xa6\
    \x07,.\n\x0c\n\x04\x05\x13\x02\x1a\x12\x04\xa7\x07\x040\n\r\n\x05\x05\
    \x13\x02\x1a\x01\x12\x04\xa7\x07\x04*\n\r\n\x05\x05\x13\x02\x1a\x02\x12\
    \x04\xa7\x07-/\n+\n\x04\x05\x13\x02\x1b\x12\x04\xa8\x07\x046\"\x1d\x20Eq\
    ual\x20as\x20LostFollowers\x20(15)\n\n\r\n\x05\x05\x13\x02\x1b\x01\x12\
    \x04\xa8\x07\x040\n\r\n\x05\x05\x13\x02\x1b\x02\x12\x04\xa8\x0735\n\x0c\
    \n\x04\x05\x13\x02\x1c\x12\x04\xa9\x07\x048\n\r\n\x05\x05\x13\x02\x1c\
    \x01\x12\x04\xa9\x07\x042\n\r\n\x05\x05\x13\x02\x1c\x02\x12\x04\xa9\x075\
    7\n\x0c\n\x04\x05\x13\x02\x1d\x12\x04\xaa\x07\x047\n\r\n\x05\x05\x13\x02\
    \x1d\x01\x12\x04\xaa\x07\x041\n\r\n\x05\x05\x13\x02\x1d\x02\x12\x04\xaa\
    \x0746\n\x0c\n\x04\x05\x13\x02\x1e\x12\x04\xab\x07\x04.\n\r\n\x05\x05\
    \x13\x02\x1e\x01\x12\x04\xab\x07\x04(\n\r\n\x05\x05\x13\x02\x1e\x02\x12\
    \x04\xab\x07+-\n\x0c\n\x02\x04B\x12\x06\xae\x07\0\xb6\x07\x01\n\x0b\n\
    \x03\x04B\x01\x12\x04\xae\x07\x08%\n\x0c\n\x04\x04B\x02\0\x12\x04\xb0\
    \x07\x04\x19\n\r\n\x05\x04B\x02\0\x05\x12\x04\xb0\x07\x04\n\n\r\n\x05\
    \x04B\x02\0\x01\x12\x04\xb0\x07\x0b\x14\n\r\n\x05\x04B\x02\0\x03\x12\x04\
    \xb0\x07\x17\x18\n\x0c\n\x04\x04B\x02\x01\x12\x04\xb1\x07\x04'\n\r\n\x05\
    \x04B\x02\x01\x06\x12\x04\xb1\x07\x04\x19\n\r\n\x05\x04B\x02\x01\x01\x12\
    \x04\xb1\x07\x1a\"\n\r\n\x05\x04B\x02\x01\x03\x12\x04\xb1\x07%&\n\x0c\n\
    \x04\x04B\x02\x02\x12\x04\xb2\x07\x04\x20\n\r\n\x05\x04B\x02\x02\x06\x12\
    \x04\xb2\x07\x04\x10\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xb2\x07\x11\x1b\
    \n\r\n\x05\x04B\x02\x02\x03\x12\x04\xb2\x07\x1e\x1f\n#\n\x04\x04B\x02\
    \x03\x12\x04\xb3\x07\x04\x18\"\x15Only\x20for\x20Gained/Lost\n\n\r\n\x05\
    \x04B\x02\x03\x05\x12\x04\xb3\x07\x04\t\n\r\n\x05\x04B\x02\x03\x01\x12\
    \x04\xb3\x07\n\x13\n\r\n\x05\x04B\x02\x03\x03\x12\x04\xb3\x07\x16\x17\n#\
    \n\x04\x04B\x02\x04\x12\x04\xb4\x07\x04\x16\"\x15Only\x20for\x20Gained/L\
    ost\n\n\r\n\x05\x04B\x02\x04\x05\x12\x04\xb4\x07\x04\t\n\r\n\x05\x04B\
    \x02\x04\x01\x12\x04\xb4\x07\n\x11\n\r\n\x05\x04B\x02\x04\x03\x12\x04\
    \xb4\x07\x14\x15\n\x0c\n\x04\x04B\x02\x05\x12\x04\xb5\x07\x04\x1d\n\r\n\
    \x05\x04B\x02\x05\x05\x12\x04\xb5\x07\x04\x08\n\r\n\x05\x04B\x02\x05\x01\
    \x12\x04\xb5\x07\t\x18\n\r\n\x05\x04B\x02\x05\x03\x12\x04\xb5\x07\x1b\
    \x1c\n\x0c\n\x02\x04C\x12\x06\xb8\x07\0\xc0\x07\x01\n\x0b\n\x03\x04C\x01\
    \x12\x04\xb8\x07\x08#\n\x0c\n\x04\x04C\x02\0\x12\x04\xba\x07\x04\x20\n\r\
    \n\x05\x04C\x02\0\x06\x12\x04\xba\x07\x04\x10\n\r\n\x05\x04C\x02\0\x01\
    \x12\x04\xba\x07\x11\x1b\n\r\n\x05\x04C\x02\0\x03\x12\x04\xba\x07\x1e\
    \x1f\n\x0c\n\x04\x04C\x02\x01\x12\x04\xbb\x07\x04/\n\r\n\x05\x04C\x02\
    \x01\x04\x12\x04\xbb\x07\x04\x0c\n\r\n\x05\x04C\x02\x01\x06\x12\x04\xbb\
    \x07\r!\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xbb\x07\"*\n\r\n\x05\x04C\x02\
    \x01\x03\x12\x04\xbb\x07-.\n\x0c\n\x04\x04C\x02\x02\x12\x04\xbc\x07\x04#\
    \n\r\n\x05\x04C\x02\x02\x05\x12\x04\xbc\x07\x04\x08\n\r\n\x05\x04C\x02\
    \x02\x01\x12\x04\xbc\x07\t\x1e\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xbc\
    \x07!\"\n3\n\x04\x04C\x02\x03\x12\x04\xbd\x07\x04\x1d\"%\x20Gained\x20an\
    d\x20lost\x20followers\x20uses\x20this\n\n\r\n\x05\x04C\x02\x03\x05\x12\
    \x04\xbd\x07\x04\t\n\r\n\x05\x04C\x02\x03\x01\x12\x04\xbd\x07\n\x18\n\r\
    \n\x05\x04C\x02\x03\x03\x12\x04\xbd\x07\x1b\x1c\n\x1f\n\x04\x04C\x02\x04\
    \x12\x04\xbe\x07\x04\x17\"\x11for\x20WhoAdmiresMe\n\n\r\n\x05\x04C\x02\
    \x04\x05\x12\x04\xbe\x07\x04\t\n\r\n\x05\x04C\x02\x04\x01\x12\x04\xbe\
    \x07\n\x12\n\r\n\x05\x04C\x02\x04\x03\x12\x04\xbe\x07\x15\x16\n\x0c\n\
    \x04\x04C\x02\x05\x12\x04\xbf\x07\x04\x15\n\r\n\x05\x04C\x02\x05\x05\x12\
    \x04\xbf\x07\x04\x08\n\r\n\x05\x04C\x02\x05\x01\x12\x04\xbf\x07\t\x10\n\
    \r\n\x05\x04C\x02\x05\x03\x12\x04\xbf\x07\x13\x14\n\x0c\n\x02\x05\x14\
    \x12\x06\xc2\x07\0\xc7\x07\x01\n\x0b\n\x03\x05\x14\x01\x12\x04\xc2\x07\
    \x05\x18\n\x0c\n\x04\x05\x14\x02\0\x12\x04\xc4\x07\x04\x19\n\r\n\x05\x05\
    \x14\x02\0\x01\x12\x04\xc4\x07\x04\x14\n\r\n\x05\x05\x14\x02\0\x02\x12\
    \x04\xc4\x07\x17\x18\n\x0c\n\x04\x05\x14\x02\x01\x12\x04\xc5\x07\x04\x1a\
    \n\r\n\x05\x05\x14\x02\x01\x01\x12\x04\xc5\x07\x04\x15\n\r\n\x05\x05\x14\
    \x02\x01\x02\x12\x04\xc5\x07\x18\x19\n\x0c\n\x04\x05\x14\x02\x02\x12\x04\
    \xc6\x07\x04\x1d\n\r\n\x05\x05\x14\x02\x02\x01\x12\x04\xc6\x07\x04\x18\n\
    \r\n\x05\x05\x14\x02\x02\x02\x12\x04\xc6\x07\x1b\x1c\n\x0c\n\x02\x04D\
    \x12\x06\xc9\x07\0\xd2\x07\x01\n\x0b\n\x03\x04D\x01\x12\x04\xc9\x07\x08(\
    \n\x0c\n\x04\x04D\x02\0\x12\x04\xcb\x07\x04\x19\n\r\n\x05\x04D\x02\0\x05\
    \x12\x04\xcb\x07\x04\n\n\r\n\x05\x04D\x02\0\x01\x12\x04\xcb\x07\x0b\x14\
    \n\r\n\x05\x04D\x02\0\x03\x12\x04\xcb\x07\x17\x18\n\x0c\n\x04\x04D\x02\
    \x01\x12\x04\xcc\x07\x04\x1e\n\r\n\x05\x04D\x02\x01\x06\x12\x04\xcc\x07\
    \x04\x0f\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xcc\x07\x10\x19\n\r\n\x05\
    \x04D\x02\x01\x03\x12\x04\xcc\x07\x1c\x1d\n5\n\x04\x04D\x02\x02\x12\x04\
    \xcd\x07\x04\x19\"'ignored\x20if\x20startTime/endTime\x20available\n\n\r\
    \n\x05\x04D\x02\x02\x05\x12\x04\xcd\x07\x04\t\n\r\n\x05\x04D\x02\x02\x01\
    \x12\x04\xcd\x07\n\x14\n\r\n\x05\x04D\x02\x02\x03\x12\x04\xcd\x07\x17\
    \x18\n\x0c\n\x04\x04D\x02\x03\x12\x04\xce\x07\x04\x20\n\r\n\x05\x04D\x02\
    \x03\x06\x12\x04\xce\x07\x04\x10\n\r\n\x05\x04D\x02\x03\x01\x12\x04\xce\
    \x07\x11\x1b\n\r\n\x05\x04D\x02\x03\x03\x12\x04\xce\x07\x1e\x1f\n\x0c\n\
    \x04\x04D\x02\x04\x12\x04\xcf\x07\x04)\n\r\n\x05\x04D\x02\x04\x06\x12\
    \x04\xcf\x07\x04\x17\n\r\n\x05\x04D\x02\x04\x01\x12\x04\xcf\x07\x18$\n\r\
    \n\x05\x04D\x02\x04\x03\x12\x04\xcf\x07'(\n\x0c\n\x04\x04D\x02\x05\x12\
    \x04\xd0\x07\x04\x18\n\r\n\x05\x04D\x02\x05\x05\x12\x04\xd0\x07\x04\t\n\
    \r\n\x05\x04D\x02\x05\x01\x12\x04\xd0\x07\n\x13\n\r\n\x05\x04D\x02\x05\
    \x03\x12\x04\xd0\x07\x16\x17\n\x0c\n\x04\x04D\x02\x06\x12\x04\xd1\x07\
    \x04\x16\n\r\n\x05\x04D\x02\x06\x05\x12\x04\xd1\x07\x04\t\n\r\n\x05\x04D\
    \x02\x06\x01\x12\x04\xd1\x07\n\x11\n\r\n\x05\x04D\x02\x06\x03\x12\x04\
    \xd1\x07\x14\x15\n\x0c\n\x02\x04E\x12\x06\xd4\x07\0\xd9\x07\x01\n\x0b\n\
    \x03\x04E\x01\x12\x04\xd4\x07\x08&\n\x0c\n\x04\x04E\x02\0\x12\x04\xd6\
    \x07\x04\x20\n\r\n\x05\x04E\x02\0\x06\x12\x04\xd6\x07\x04\x10\n\r\n\x05\
    \x04E\x02\0\x01\x12\x04\xd6\x07\x11\x1b\n\r\n\x05\x04E\x02\0\x03\x12\x04\
    \xd6\x07\x1e\x1f\n\x0c\n\x04\x04E\x02\x01\x12\x04\xd7\x07\x04\x20\n\r\n\
    \x05\x04E\x02\x01\x04\x12\x04\xd7\x07\x04\x0c\n\r\n\x05\x04E\x02\x01\x06\
    \x12\x04\xd7\x07\r\x14\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xd7\x07\x15\
    \x1b\n\r\n\x05\x04E\x02\x01\x03\x12\x04\xd7\x07\x1e\x1f\n\x0c\n\x04\x04E\
    \x02\x02\x12\x04\xd8\x07\x04#\n\r\n\x05\x04E\x02\x02\x05\x12\x04\xd8\x07\
    \x04\x08\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xd8\x07\t\x1e\n\r\n\x05\x04E\
    \x02\x02\x03\x12\x04\xd8\x07!\"\n\x0c\n\x02\x04F\x12\x06\xdb\x07\0\xe1\
    \x07\x01\n\x0b\n\x03\x04F\x01\x12\x04\xdb\x07\x08#\n\x0c\n\x04\x04F\x02\
    \0\x12\x04\xdd\x07\x04\x19\n\r\n\x05\x04F\x02\0\x05\x12\x04\xdd\x07\x04\
    \n\n\r\n\x05\x04F\x02\0\x01\x12\x04\xdd\x07\x0b\x14\n\r\n\x05\x04F\x02\0\
    \x03\x12\x04\xdd\x07\x17\x18\n\x0c\n\x04\x04F\x02\x01\x12\x04\xde\x07\
    \x04\x1f\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xde\x07\x04\n\n\r\n\x05\x04F\
    \x02\x01\x01\x12\x04\xde\x07\x0b\x1a\n\r\n\x05\x04F\x02\x01\x03\x12\x04\
    \xde\x07\x1d\x1e\n\x0c\n\x04\x04F\x02\x02\x12\x04\xdf\x07\x04)\n\r\n\x05\
    \x04F\x02\x02\x06\x12\x04\xdf\x07\x04\x17\n\r\n\x05\x04F\x02\x02\x01\x12\
    \x04\xdf\x07\x18$\n\r\n\x05\x04F\x02\x02\x03\x12\x04\xdf\x07'(\n\x0c\n\
    \x04\x04F\x02\x03\x12\x04\xe0\x07\x04\x20\n\r\n\x05\x04F\x02\x03\x06\x12\
    \x04\xe0\x07\x04\x10\n\r\n\x05\x04F\x02\x03\x01\x12\x04\xe0\x07\x11\x1b\
    \n\r\n\x05\x04F\x02\x03\x03\x12\x04\xe0\x07\x1e\x1f\n\x0c\n\x02\x04G\x12\
    \x06\xe3\x07\0\xed\x07\x01\n\x0b\n\x03\x04G\x01\x12\x04\xe3\x07\x08!\n\
    \x0e\n\x04\x04G\x03\0\x12\x06\xe5\x07\x04\xe9\x07\x05\n\r\n\x05\x04G\x03\
    \0\x01\x12\x04\xe5\x07\x0c\x18\n\x0e\n\x06\x04G\x03\0\x02\0\x12\x04\xe7\
    \x07\x08\x1a\n\x0f\n\x07\x04G\x03\0\x02\0\x06\x12\x04\xe7\x07\x08\x0f\n\
    \x0f\n\x07\x04G\x03\0\x02\0\x01\x12\x04\xe7\x07\x10\x15\n\x0f\n\x07\x04G\
    \x03\0\x02\0\x03\x12\x04\xe7\x07\x18\x19\n\x0e\n\x06\x04G\x03\0\x02\x01\
    \x12\x04\xe8\x07\x08-\n\x0f\n\x07\x04G\x03\0\x02\x01\x06\x12\x04\xe8\x07\
    \x08\x1b\n\x0f\n\x07\x04G\x03\0\x02\x01\x01\x12\x04\xe8\x07\x1c(\n\x0f\n\
    \x07\x04G\x03\0\x02\x01\x03\x12\x04\xe8\x07+,\n\x0c\n\x04\x04G\x02\0\x12\
    \x04\xea\x07\x04\x20\n\r\n\x05\x04G\x02\0\x06\x12\x04\xea\x07\x04\x10\n\
    \r\n\x05\x04G\x02\0\x01\x12\x04\xea\x07\x11\x1b\n\r\n\x05\x04G\x02\0\x03\
    \x12\x04\xea\x07\x1e\x1f\n\x0c\n\x04\x04G\x02\x01\x12\x04\xeb\x07\x04%\n\
    \r\n\x05\x04G\x02\x01\x04\x12\x04\xeb\x07\x04\x0c\n\r\n\x05\x04G\x02\x01\
    \x06\x12\x04\xeb\x07\r\x19\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xeb\x07\
    \x1a\x20\n\r\n\x05\x04G\x02\x01\x03\x12\x04\xeb\x07#$\n\x0c\n\x04\x04G\
    \x02\x02\x12\x04\xec\x07\x04#\n\r\n\x05\x04G\x02\x02\x05\x12\x04\xec\x07\
    \x04\x08\n\r\n\x05\x04G\x02\x02\x01\x12\x04\xec\x07\t\x1e\n\r\n\x05\x04G\
    \x02\x02\x03\x12\x04\xec\x07!\"\n\x0c\n\x02\x04H\x12\x06\xef\x07\0\xf3\
    \x07\x01\n\x0b\n\x03\x04H\x01\x12\x04\xef\x07\x08#\n\x0c\n\x04\x04H\x02\
    \0\x12\x04\xf1\x07\x04\x19\n\r\n\x05\x04H\x02\0\x05\x12\x04\xf1\x07\x04\
    \n\n\r\n\x05\x04H\x02\0\x01\x12\x04\xf1\x07\x0b\x14\n\r\n\x05\x04H\x02\0\
    \x03\x12\x04\xf1\x07\x17\x18\n\x0c\n\x04\x04H\x02\x01\x12\x04\xf2\x07\
    \x04\x1f\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xf2\x07\x04\n\n\r\n\x05\x04H\
    \x02\x01\x01\x12\x04\xf2\x07\x0b\x1a\n\r\n\x05\x04H\x02\x01\x03\x12\x04\
    \xf2\x07\x1d\x1e\n\x0c\n\x02\x04I\x12\x06\xf5\x07\0\xfa\x07\x01\n\x0b\n\
    \x03\x04I\x01\x12\x04\xf5\x07\x08!\n\x0c\n\x04\x04I\x02\0\x12\x04\xf7\
    \x07\x04)\n\r\n\x05\x04I\x02\0\x05\x12\x04\xf7\x07\x04\t\n\r\n\x05\x04I\
    \x02\0\x01\x12\x04\xf7\x07\n$\n\r\n\x05\x04I\x02\0\x03\x12\x04\xf7\x07'(\
    \n\x0c\n\x04\x04I\x02\x01\x12\x04\xf8\x07\x04,\n\r\n\x05\x04I\x02\x01\
    \x05\x12\x04\xf8\x07\x04\t\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xf8\x07\n'\
    \n\r\n\x05\x04I\x02\x01\x03\x12\x04\xf8\x07*+\n\x16\n\x04\x04I\x02\x02\
    \x12\x04\xf9\x07\x04Q\"\x08up\x20to\x209\n\n\r\n\x05\x04I\x02\x02\x04\
    \x12\x04\xf9\x07\x04\x0c\n\r\n\x05\x04I\x02\x02\x06\x12\x04\xf9\x07\r\
    \x14\n\r\n\x05\x04I\x02\x02\x01\x12\x04\xf9\x07\x158\n\r\n\x05\x04I\x02\
    \x02\x03\x12\x04\xf9\x07;<\n\r\n\x05\x04I\x02\x02\x08\x12\x04\xf9\x07=P\
    \n\x0e\n\x06\x04I\x02\x02\x08\x03\x12\x04\xf9\x07>O\n\x0c\n\x02\x05\x15\
    \x12\x06\xfc\x07\0\x83\x08\x01\n\x0b\n\x03\x05\x15\x01\x12\x04\xfc\x07\
    \x05\x1c\n\x0c\n\x04\x05\x15\x02\0\x12\x04\xfe\x07\x04)\n\r\n\x05\x05\
    \x15\x02\0\x01\x12\x04\xfe\x07\x04$\n\r\n\x05\x05\x15\x02\0\x02\x12\x04\
    \xfe\x07'(\n\x0c\n\x04\x05\x15\x02\x01\x12\x04\xff\x07\x04*\n\r\n\x05\
    \x05\x15\x02\x01\x01\x12\x04\xff\x07\x04%\n\r\n\x05\x05\x15\x02\x01\x02\
    \x12\x04\xff\x07()\n\x0c\n\x04\x05\x15\x02\x02\x12\x04\x80\x08\x04&\n\r\
    \n\x05\x05\x15\x02\x02\x01\x12\x04\x80\x08\x04!\n\r\n\x05\x05\x15\x02\
    \x02\x02\x12\x04\x80\x08$%\n\x0c\n\x04\x05\x15\x02\x03\x12\x04\x81\x08\
    \x04+\n\r\n\x05\x05\x15\x02\x03\x01\x12\x04\x81\x08\x04&\n\r\n\x05\x05\
    \x15\x02\x03\x02\x12\x04\x81\x08)*\n\x0c\n\x04\x05\x15\x02\x04\x12\x04\
    \x82\x08\x04.\n\r\n\x05\x05\x15\x02\x04\x01\x12\x04\x82\x08\x04)\n\r\n\
    \x05\x05\x15\x02\x04\x02\x12\x04\x82\x08,-\n\x0c\n\x02\x04J\x12\x06\x85\
    \x08\0\x8b\x08\x01\n\x0b\n\x03\x04J\x01\x12\x04\x85\x08\x08\"\n\x0c\n\
    \x04\x04J\x02\0\x12\x04\x87\x08\x04\x19\n\r\n\x05\x04J\x02\0\x05\x12\x04\
    \x87\x08\x04\n\n\r\n\x05\x04J\x02\0\x01\x12\x04\x87\x08\x0b\x14\n\r\n\
    \x05\x04J\x02\0\x03\x12\x04\x87\x08\x17\x18\n\x0c\n\x04\x04J\x02\x01\x12\
    \x04\x88\x08\x04%\n\r\n\x05\x04J\x02\x01\x06\x12\x04\x88\x08\x04\x1b\n\r\
    \n\x05\x04J\x02\x01\x01\x12\x04\x88\x08\x1c\x20\n\r\n\x05\x04J\x02\x01\
    \x03\x12\x04\x88\x08#$\n\x0c\n\x04\x04J\x02\x02\x12\x04\x89\x08\x04\x18\
    \n\r\n\x05\x04J\x02\x02\x05\x12\x04\x89\x08\x04\t\n\r\n\x05\x04J\x02\x02\
    \x01\x12\x04\x89\x08\n\x13\n\r\n\x05\x04J\x02\x02\x03\x12\x04\x89\x08\
    \x16\x17\n\x0c\n\x04\x04J\x02\x03\x12\x04\x8a\x08\x04\x16\n\r\n\x05\x04J\
    \x02\x03\x05\x12\x04\x8a\x08\x04\t\n\r\n\x05\x04J\x02\x03\x01\x12\x04\
    \x8a\x08\n\x11\n\r\n\x05\x04J\x02\x03\x03\x12\x04\x8a\x08\x14\x15\n\x0c\
    \n\x02\x04K\x12\x06\x8d\x08\0\x95\x08\x01\n\x0b\n\x03\x04K\x01\x12\x04\
    \x8d\x08\x08\x20\n\x0e\n\x04\x04K\x03\0\x12\x06\x8f\x08\x04\x93\x08\x05\
    \n\r\n\x05\x04K\x03\0\x01\x12\x04\x8f\x08\x0c\x15\n\x0e\n\x06\x04K\x03\0\
    \x02\0\x12\x04\x91\x08\x08\x18\n\x0f\n\x07\x04K\x03\0\x02\0\x05\x12\x04\
    \x91\x08\x08\r\n\x0f\n\x07\x04K\x03\0\x02\0\x01\x12\x04\x91\x08\x0e\x13\
    \n\x0f\n\x07\x04K\x03\0\x02\0\x03\x12\x04\x91\x08\x16\x17\n\x0e\n\x06\
    \x04K\x03\0\x02\x01\x12\x04\x92\x08\x08\x17\n\x0f\n\x07\x04K\x03\0\x02\
    \x01\x05\x12\x04\x92\x08\x08\r\n\x0f\n\x07\x04K\x03\0\x02\x01\x01\x12\
    \x04\x92\x08\x0e\x12\n\x0f\n\x07\x04K\x03\0\x02\x01\x03\x12\x04\x92\x08\
    \x15\x16\n\x0c\n\x04\x04K\x02\0\x12\x04\x94\x08\x04\"\n\r\n\x05\x04K\x02\
    \0\x04\x12\x04\x94\x08\x04\x0c\n\r\n\x05\x04K\x02\0\x06\x12\x04\x94\x08\
    \r\x16\n\r\n\x05\x04K\x02\0\x01\x12\x04\x94\x08\x17\x1d\n\r\n\x05\x04K\
    \x02\0\x03\x12\x04\x94\x08\x20!\n\x0c\n\x02\x04L\x12\x06\x97\x08\0\x9b\
    \x08\x01\n\x0b\n\x03\x04L\x01\x12\x04\x97\x08\x08&\n\x0c\n\x04\x04L\x02\
    \0\x12\x04\x99\x08\x04\x19\n\r\n\x05\x04L\x02\0\x05\x12\x04\x99\x08\x04\
    \n\n\r\n\x05\x04L\x02\0\x01\x12\x04\x99\x08\x0b\x14\n\r\n\x05\x04L\x02\0\
    \x03\x12\x04\x99\x08\x17\x18\n\x0c\n\x04\x04L\x02\x01\x12\x04\x9a\x08\
    \x04)\n\r\n\x05\x04L\x02\x01\x04\x12\x04\x9a\x08\x04\x0c\n\r\n\x05\x04L\
    \x02\x01\x05\x12\x04\x9a\x08\r\x13\n\r\n\x05\x04L\x02\x01\x01\x12\x04\
    \x9a\x08\x14$\n\r\n\x05\x04L\x02\x01\x03\x12\x04\x9a\x08'(\n\x0c\n\x02\
    \x04M\x12\x06\x9d\x08\0\xa6\x08\x01\n\x0b\n\x03\x04M\x01\x12\x04\x9d\x08\
    \x08$\n\x0e\n\x04\x04M\x03\0\x12\x06\x9f\x08\x04\xa4\x08\x05\n\r\n\x05\
    \x04M\x03\0\x01\x12\x04\x9f\x08\x0c\x18\n\x0e\n\x06\x04M\x03\0\x02\0\x12\
    \x04\xa1\x08\x08,\n\x0f\n\x07\x04M\x03\0\x02\0\x06\x12\x04\xa1\x08\x08\
    \x16\n\x0f\n\x07\x04M\x03\0\x02\0\x01\x12\x04\xa1\x08\x17'\n\x0f\n\x07\
    \x04M\x03\0\x02\0\x03\x12\x04\xa1\x08*+\n\x0e\n\x06\x04M\x03\0\x02\x01\
    \x12\x04\xa2\x08\x08,\n\x0f\n\x07\x04M\x03\0\x02\x01\x06\x12\x04\xa2\x08\
    \x08\x16\n\x0f\n\x07\x04M\x03\0\x02\x01\x01\x12\x04\xa2\x08\x17'\n\x0f\n\
    \x07\x04M\x03\0\x02\x01\x03\x12\x04\xa2\x08*+\n\x0e\n\x06\x04M\x03\0\x02\
    \x02\x12\x04\xa3\x08\x08'\n\x0f\n\x07\x04M\x03\0\x02\x02\x05\x12\x04\xa3\
    \x08\x08\x0c\n\x0f\n\x07\x04M\x03\0\x02\x02\x01\x12\x04\xa3\x08\r\"\n\
    \x0f\n\x07\x04M\x03\0\x02\x02\x03\x12\x04\xa3\x08%&\n\x0c\n\x04\x04M\x02\
    \0\x12\x04\xa5\x08\x04.\n\r\n\x05\x04M\x02\0\x06\x12\x04\xa5\x08\x04\x1d\
    \n\r\n\x05\x04M\x02\0\x01\x12\x04\xa5\x08\x1e)\n\r\n\x05\x04M\x02\0\x03\
    \x12\x04\xa5\x08,-\n\x0c\n\x02\x04N\x12\x06\xa8\x08\0\xac\x08\x01\n\x0b\
    \n\x03\x04N\x01\x12\x04\xa8\x08\x08\x1e\n\x0c\n\x04\x04N\x02\0\x12\x04\
    \xaa\x08\x08(\n\r\n\x05\x04N\x02\0\x06\x12\x04\xaa\x08\x08\x1c\n\r\n\x05\
    \x04N\x02\0\x01\x12\x04\xaa\x08\x1d#\n\r\n\x05\x04N\x02\0\x03\x12\x04\
    \xaa\x08&'\n\x0c\n\x04\x04N\x02\x01\x12\x04\xab\x08\x04\x18\n\r\n\x05\
    \x04N\x02\x01\x05\x12\x04\xab\x08\x04\t\n\r\n\x05\x04N\x02\x01\x01\x12\
    \x04\xab\x08\n\x13\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xab\x08\x16\x17\n\
    \x0c\n\x02\x04O\x12\x06\xae\x08\0\xb4\x08\x01\n\x0b\n\x03\x04O\x01\x12\
    \x04\xae\x08\x08$\n\x0c\n\x04\x04O\x02\0\x12\x04\xb0\x08\x04\x19\n\r\n\
    \x05\x04O\x02\0\x05\x12\x04\xb0\x08\x04\n\n\r\n\x05\x04O\x02\0\x01\x12\
    \x04\xb0\x08\x0b\x14\n\r\n\x05\x04O\x02\0\x03\x12\x04\xb0\x08\x17\x18\n\
    \x0c\n\x04\x04O\x02\x01\x12\x04\xb1\x08\x04\x18\n\r\n\x05\x04O\x02\x01\
    \x05\x12\x04\xb1\x08\x04\t\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xb1\x08\n\
    \x13\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xb1\x08\x16\x17\n\x0c\n\x04\x04O\
    \x02\x02\x12\x04\xb2\x08\x04\x16\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xb2\
    \x08\x04\t\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xb2\x08\n\x11\n\r\n\x05\
    \x04O\x02\x02\x03\x12\x04\xb2\x08\x14\x15\n\x0c\n\x04\x04O\x02\x03\x12\
    \x04\xb3\x08\x04\x1d\n\r\n\x05\x04O\x02\x03\x05\x12\x04\xb3\x08\x04\x08\
    \n\r\n\x05\x04O\x02\x03\x01\x12\x04\xb3\x08\t\x18\n\r\n\x05\x04O\x02\x03\
    \x03\x12\x04\xb3\x08\x1b\x1c\n\x0c\n\x02\x04P\x12\x06\xb6\x08\0\xbf\x08\
    \x01\n\x0b\n\x03\x04P\x01\x12\x04\xb6\x08\x08\"\n\x0e\n\x04\x04P\x03\0\
    \x12\x06\xb8\x08\x04\xbc\x08\x05\n\r\n\x05\x04P\x03\0\x01\x12\x04\xb8\
    \x08\x0c\x16\n\x0e\n\x06\x04P\x03\0\x02\0\x12\x04\xba\x08\x08\x1f\n\x0f\
    \n\x07\x04P\x03\0\x02\0\x05\x12\x04\xba\x08\x08\r\n\x0f\n\x07\x04P\x03\0\
    \x02\0\x01\x12\x04\xba\x08\x0e\x1a\n\x0f\n\x07\x04P\x03\0\x02\0\x03\x12\
    \x04\xba\x08\x1d\x1e\n\x0e\n\x06\x04P\x03\0\x02\x01\x12\x04\xbb\x08\x085\
    \n\x0f\n\x07\x04P\x03\0\x02\x01\x04\x12\x04\xbb\x08\x08\x10\n\x0f\n\x07\
    \x04P\x03\0\x02\x01\x06\x12\x04\xbb\x08\x11'\n\x0f\n\x07\x04P\x03\0\x02\
    \x01\x01\x12\x04\xbb\x08(0\n\x0f\n\x07\x04P\x03\0\x02\x01\x03\x12\x04\
    \xbb\x0834\n\x0c\n\x04\x04P\x02\0\x12\x04\xbe\x08\x04&\n\r\n\x05\x04P\
    \x02\0\x04\x12\x04\xbe\x08\x04\x0c\n\r\n\x05\x04P\x02\0\x06\x12\x04\xbe\
    \x08\r\x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\xbe\x08\x18!\n\r\n\x05\x04P\
    \x02\0\x03\x12\x04\xbe\x08$%\n\x1c\n\x02\x04Q\x12\x06\xc2\x08\0\xc6\x08\
    \x01\x1a\x0eNotifications\n\n\x0b\n\x03\x04Q\x01\x12\x04\xc2\x08\x08\x1e\
    \n\x0c\n\x04\x04Q\x02\0\x12\x04\xc4\x08\x04\x15\n\r\n\x05\x04Q\x02\0\x05\
    \x12\x04\xc4\x08\x04\n\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xc4\x08\x0b\x10\
    \n\r\n\x05\x04Q\x02\0\x03\x12\x04\xc4\x08\x13\x14\n\x0c\n\x04\x04Q\x02\
    \x01\x12\x04\xc5\x08\x04\x17\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\xc5\x08\
    \x04\n\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\xc5\x08\x0b\x12\n\r\n\x05\x04Q\
    \x02\x01\x03\x12\x04\xc5\x08\x15\x16\n\x0c\n\x02\x05\x16\x12\x06\xc8\x08\
    \0\xd2\x08\x01\n\x0b\n\x03\x05\x16\x01\x12\x04\xc8\x08\x05\x11\n\x0c\n\
    \x04\x05\x16\x02\0\x12\x04\xca\x08\x04\x1a\n\r\n\x05\x05\x16\x02\0\x01\
    \x12\x04\xca\x08\x04\x15\n\r\n\x05\x05\x16\x02\0\x02\x12\x04\xca\x08\x18\
    \x19\n\x0c\n\x04\x05\x16\x02\x01\x12\x04\xcb\x08\x04!\n\r\n\x05\x05\x16\
    \x02\x01\x01\x12\x04\xcb\x08\x04\x1c\n\r\n\x05\x05\x16\x02\x01\x02\x12\
    \x04\xcb\x08\x1f\x20\n\x0c\n\x04\x05\x16\x02\x02\x12\x04\xcc\x08\x04\x1e\
    \n\r\n\x05\x05\x16\x02\x02\x01\x12\x04\xcc\x08\x04\x19\n\r\n\x05\x05\x16\
    \x02\x02\x02\x12\x04\xcc\x08\x1c\x1d\n\x0c\n\x04\x05\x16\x02\x03\x12\x04\
    \xcd\x08\x04\x1e\n\r\n\x05\x05\x16\x02\x03\x01\x12\x04\xcd\x08\x04\x19\n\
    \r\n\x05\x05\x16\x02\x03\x02\x12\x04\xcd\x08\x1c\x1d\n\x0c\n\x04\x05\x16\
    \x02\x04\x12\x04\xce\x08\x04\x1c\n\r\n\x05\x05\x16\x02\x04\x01\x12\x04\
    \xce\x08\x04\x17\n\r\n\x05\x05\x16\x02\x04\x02\x12\x04\xce\x08\x1a\x1b\n\
    \x0c\n\x04\x05\x16\x02\x05\x12\x04\xcf\x08\x04\x1f\n\r\n\x05\x05\x16\x02\
    \x05\x01\x12\x04\xcf\x08\x04\x1a\n\r\n\x05\x05\x16\x02\x05\x02\x12\x04\
    \xcf\x08\x1d\x1e\n\x0c\n\x04\x05\x16\x02\x06\x12\x04\xd0\x08\x04\x1d\n\r\
    \n\x05\x05\x16\x02\x06\x01\x12\x04\xd0\x08\x04\x18\n\r\n\x05\x05\x16\x02\
    \x06\x02\x12\x04\xd0\x08\x1b\x1c\n\x0c\n\x04\x05\x16\x02\x07\x12\x04\xd1\
    \x08\x04!\n\r\n\x05\x05\x16\x02\x07\x01\x12\x04\xd1\x08\x04\x1c\n\r\n\
    \x05\x05\x16\x02\x07\x02\x12\x04\xd1\x08\x1f\x20\n\x0c\n\x02\x04R\x12\
    \x06\xd4\x08\0\xdb\x08\x01\n\x0b\n\x03\x04R\x01\x12\x04\xd4\x08\x08\x20\
    \n\x0c\n\x04\x04R\x02\0\x12\x04\xd6\x08\x04\x20\n\r\n\x05\x04R\x02\0\x06\
    \x12\x04\xd6\x08\x04\x10\n\r\n\x05\x04R\x02\0\x01\x12\x04\xd6\x08\x11\
    \x1b\n\r\n\x05\x04R\x02\0\x03\x12\x04\xd6\x08\x1e\x1f\n\x0c\n\x04\x04R\
    \x02\x01\x12\x04\xd7\x08\x04\x1a\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xd7\
    \x08\x04\t\n\r\n\x05\x04R\x02\x01\x01\x12\x04\xd7\x08\n\x15\n\r\n\x05\
    \x04R\x02\x01\x03\x12\x04\xd7\x08\x18\x19\n\x0c\n\x04\x04R\x02\x02\x12\
    \x04\xd8\x08\x04\x1b\n\r\n\x05\x04R\x02\x02\x05\x12\x04\xd8\x08\x04\x08\
    \n\r\n\x05\x04R\x02\x02\x01\x12\x04\xd8\x08\t\x16\n\r\n\x05\x04R\x02\x02\
    \x03\x12\x04\xd8\x08\x19\x1a\n\x0c\n\x04\x04R\x02\x03\x12\x04\xd9\x08\
    \x04\x18\n\r\n\x05\x04R\x02\x03\x05\x12\x04\xd9\x08\x04\t\n\r\n\x05\x04R\
    \x02\x03\x01\x12\x04\xd9\x08\n\x13\n\r\n\x05\x04R\x02\x03\x03\x12\x04\
    \xd9\x08\x16\x17\n\x0c\n\x04\x04R\x02\x04\x12\x04\xda\x08\x04\x19\n\r\n\
    \x05\x04R\x02\x04\x05\x12\x04\xda\x08\x04\n\n\r\n\x05\x04R\x02\x04\x01\
    \x12\x04\xda\x08\x0b\x14\n\r\n\x05\x04R\x02\x04\x03\x12\x04\xda\x08\x17\
    \x18\n\x1b\n\x02\x04S\x12\x06\xde\x08\0\xe1\x08\x01\x1a\rSubscription\n\
    \n\x0b\n\x03\x04S\x01\x12\x04\xde\x08\x08%\n\x0c\n\x02\x04T\x12\x06\xe3\
    \x08\0\xe6\x08\x01\n\x0b\n\x03\x04T\x01\x12\x04\xe3\x08\x08#\n\x0c\n\x04\
    \x04T\x02\0\x12\x04\xe5\x08\x04\x14\n\r\n\x05\x04T\x02\0\x05\x12\x04\xe5\
    \x08\x04\x08\n\r\n\x05\x04T\x02\0\x01\x12\x04\xe5\x08\t\x0f\n\r\n\x05\
    \x04T\x02\0\x03\x12\x04\xe5\x08\x12\x13\n\x0c\n\x02\x04U\x12\x06\xe8\x08\
    \0\xeb\x08\x01\n\x0b\n\x03\x04U\x01\x12\x04\xe8\x08\x08\x1a\nC\n\x04\x04\
    U\x02\0\x12\x04\xea\x08\x04-\"5if\x20not\x20filled,\x20server\x20must\
    \x20return\x20all\x20possible\x20types\n\n\r\n\x05\x04U\x02\0\x04\x12\
    \x04\xea\x08\x04\x0c\n\r\n\x05\x04U\x02\0\x06\x12\x04\xea\x08\r\"\n\r\n\
    \x05\x04U\x02\0\x01\x12\x04\xea\x08#(\n\r\n\x05\x04U\x02\0\x03\x12\x04\
    \xea\x08+,\n\x0c\n\x02\x04V\x12\x06\xed\x08\0\xf5\x08\x01\n\x0b\n\x03\
    \x04V\x01\x12\x04\xed\x08\x08\x18\n\x0e\n\x04\x04V\x03\0\x12\x06\xef\x08\
    \x04\xf3\x08\x05\n\r\n\x05\x04V\x03\0\x01\x12\x04\xef\x08\x0c\x17\n\x0e\
    \n\x06\x04V\x03\0\x02\0\x12\x04\xf1\x08\x08'\n\x0f\n\x07\x04V\x03\0\x02\
    \0\x06\x12\x04\xf1\x08\x08\x1d\n\x0f\n\x07\x04V\x03\0\x02\0\x01\x12\x04\
    \xf1\x08\x1e\"\n\x0f\n\x07\x04V\x03\0\x02\0\x03\x12\x04\xf1\x08%&\n\x0e\
    \n\x06\x04V\x03\0\x02\x01\x12\x04\xf2\x08\x08\x1b\n\x0f\n\x07\x04V\x03\0\
    \x02\x01\x05\x12\x04\xf2\x08\x08\x0c\n\x0f\n\x07\x04V\x03\0\x02\x01\x01\
    \x12\x04\xf2\x08\r\x16\n\x0f\n\x07\x04V\x03\0\x02\x01\x03\x12\x04\xf2\
    \x08\x19\x1a\n\x0c\n\x04\x04V\x02\0\x12\x04\xf4\x08\x04&\n\r\n\x05\x04V\
    \x02\0\x04\x12\x04\xf4\x08\x04\x0c\n\r\n\x05\x04V\x02\0\x06\x12\x04\xf4\
    \x08\r\x18\n\r\n\x05\x04V\x02\0\x01\x12\x04\xf4\x08\x19!\n\r\n\x05\x04V\
    \x02\0\x03\x12\x04\xf4\x08$%\n\x0c\n\x02\x04W\x12\x06\xf7\x08\0\xfe\x08\
    \x01\n\x0b\n\x03\x04W\x01\x12\x04\xf7\x08\x08\x1b\n\x0c\n\x04\x04W\x02\0\
    \x12\x04\xf9\x08\x04/\n\r\n\x05\x04W\x02\0\x04\x12\x04\xf9\x08\x04\x0c\n\
    \r\n\x05\x04W\x02\0\x06\x12\x04\xf9\x08\r\x1c\n\r\n\x05\x04W\x02\0\x01\
    \x12\x04\xf9\x08\x1d*\n\r\n\x05\x04W\x02\0\x03\x12\x04\xf9\x08-.\n\x0c\n\
    \x04\x04W\x02\x01\x12\x04\xfa\x08\x044\n\r\n\x05\x04W\x02\x01\x04\x12\
    \x04\xfa\x08\x04\x0c\n\r\n\x05\x04W\x02\x01\x06\x12\x04\xfa\x08\r\"\n\r\
    \n\x05\x04W\x02\x01\x01\x12\x04\xfa\x08#/\n\r\n\x05\x04W\x02\x01\x03\x12\
    \x04\xfa\x0823\n\x0c\n\x04\x04W\x02\x02\x12\x04\xfb\x08\x04\x14\n\r\n\
    \x05\x04W\x02\x02\x05\x12\x04\xfb\x08\x04\x08\n\r\n\x05\x04W\x02\x02\x01\
    \x12\x04\xfb\x08\t\x0f\n\r\n\x05\x04W\x02\x02\x03\x12\x04\xfb\x08\x12\
    \x13\n\x0c\n\x04\x04W\x02\x03\x12\x04\xfc\x08\x04:\n\r\n\x05\x04W\x02\
    \x03\x04\x12\x04\xfc\x08\x04\x0c\n\r\n\x05\x04W\x02\x03\x06\x12\x04\xfc\
    \x08\r\x1c\n\r\n\x05\x04W\x02\x03\x01\x12\x04\xfc\x08\x1d5\n\r\n\x05\x04\
    W\x02\x03\x03\x12\x04\xfc\x0889\n\x0c\n\x04\x04W\x02\x04\x12\x04\xfd\x08\
    \x04?\n\r\n\x05\x04W\x02\x04\x04\x12\x04\xfd\x08\x04\x0c\n\r\n\x05\x04W\
    \x02\x04\x06\x12\x04\xfd\x08\r\"\n\r\n\x05\x04W\x02\x04\x01\x12\x04\xfd\
    \x08#:\n\r\n\x05\x04W\x02\x04\x03\x12\x04\xfd\x08=>\n\x0c\n\x02\x04X\x12\
    \x06\x80\t\0\x84\t\x01\n\x0b\n\x03\x04X\x01\x12\x04\x80\t\x08\x19\n\x0c\
    \n\x04\x04X\x02\0\x12\x04\x82\t\x04\x1d\n\r\n\x05\x04X\x02\0\x05\x12\x04\
    \x82\t\x04\x08\n\r\n\x05\x04X\x02\0\x01\x12\x04\x82\t\t\x18\n\r\n\x05\
    \x04X\x02\0\x03\x12\x04\x82\t\x1b\x1c\n,\n\x04\x04X\x02\x01\x12\x04\x83\
    \t\x04\x1b\"\x1emax\x20100,\x20-1\x20for\x20unpredictable\n\n\r\n\x05\
    \x04X\x02\x01\x05\x12\x04\x83\t\x04\t\n\r\n\x05\x04X\x02\x01\x01\x12\x04\
    \x83\t\n\x16\n\r\n\x05\x04X\x02\x01\x03\x12\x04\x83\t\x19\x1a\n\x0c\n\
    \x02\x04Y\x12\x06\x86\t\0\x89\t\x01\n\x0b\n\x03\x04Y\x01\x12\x04\x86\t\
    \x08#\n\x0c\n\x04\x04Y\x02\0\x12\x04\x88\t\x04+\n\r\n\x05\x04Y\x02\0\x04\
    \x12\x04\x88\t\x04\x0c\n\r\n\x05\x04Y\x02\0\x06\x12\x04\x88\t\r\x1c\n\r\
    \n\x05\x04Y\x02\0\x01\x12\x04\x88\t\x1d&\n\r\n\x05\x04Y\x02\0\x03\x12\
    \x04\x88\t)*\nT\n\x02\x04Z\x12\x06\x8c\t\0\x8f\t\x01\x1aF\x20Send\x20onl\
    y\x20*unfinished*\x20batch\x20tasks\x20to\x20client\x20and\x20pause\x20i\
    t\x20on\x20server.\n\n\x0b\n\x03\x04Z\x01\x12\x04\x8c\t\x089\n\x0c\n\x02\
    \x04[\x12\x06\x91\t\0\x95\t\x01\n\x0b\n\x03\x04[\x01\x12\x04\x91\t\x087\
    \n\x0c\n\x04\x04[\x02\0\x12\x04\x93\t\x04:\n\r\n\x05\x04[\x02\0\x04\x12\
    \x04\x93\t\x04\x0c\n\r\n\x05\x04[\x02\0\x05\x12\x04\x93\t\r\x12\n\r\n\
    \x05\x04[\x02\0\x01\x12\x04\x93\t\x135\n\r\n\x05\x04[\x02\0\x03\x12\x04\
    \x93\t89\n\x0c\n\x04\x04[\x02\x01\x12\x04\x94\t\x04<\n\r\n\x05\x04[\x02\
    \x01\x04\x12\x04\x94\t\x04\x0c\n\r\n\x05\x04[\x02\x01\x05\x12\x04\x94\t\
    \r\x12\n\r\n\x05\x04[\x02\x01\x01\x12\x04\x94\t\x137\n\r\n\x05\x04[\x02\
    \x01\x03\x12\x04\x94\t:;\n\x0c\n\x02\x05\x17\x12\x06\x97\t\0\x9c\t\x01\n\
    \x0b\n\x03\x05\x17\x01\x12\x04\x97\t\x05\x14\n\x0c\n\x04\x05\x17\x02\0\
    \x12\x04\x99\t\x04\x1d\n\r\n\x05\x05\x17\x02\0\x01\x12\x04\x99\t\x04\x18\
    \n\r\n\x05\x05\x17\x02\0\x02\x12\x04\x99\t\x1b\x1c\n\x0c\n\x04\x05\x17\
    \x02\x01\x12\x04\x9a\t\x04\x1f\n\r\n\x05\x05\x17\x02\x01\x01\x12\x04\x9a\
    \t\x04\x1a\n\r\n\x05\x05\x17\x02\x01\x02\x12\x04\x9a\t\x1d\x1e\n\x0c\n\
    \x04\x05\x17\x02\x02\x12\x04\x9b\t\x04!\n\r\n\x05\x05\x17\x02\x02\x01\
    \x12\x04\x9b\t\x04\x1c\n\r\n\x05\x05\x17\x02\x02\x02\x12\x04\x9b\t\x1f\
    \x20\n\x0c\n\x02\x05\x18\x12\x06\x9e\t\0\xa4\t\x01\n\x0b\n\x03\x05\x18\
    \x01\x12\x04\x9e\t\x05\x16\n\x0c\n\x04\x05\x18\x02\0\x12\x04\xa0\t\x04\"\
    \n\r\n\x05\x05\x18\x02\0\x01\x12\x04\xa0\t\x04\x1d\n\r\n\x05\x05\x18\x02\
    \0\x02\x12\x04\xa0\t\x20!\n\x0c\n\x04\x05\x18\x02\x01\x12\x04\xa1\t\x04#\
    \n\r\n\x05\x05\x18\x02\x01\x01\x12\x04\xa1\t\x04\x1e\n\r\n\x05\x05\x18\
    \x02\x01\x02\x12\x04\xa1\t!\"\n\x0c\n\x04\x05\x18\x02\x02\x12\x04\xa2\t\
    \x04+\n\r\n\x05\x05\x18\x02\x02\x01\x12\x04\xa2\t\x04&\n\r\n\x05\x05\x18\
    \x02\x02\x02\x12\x04\xa2\t)*\n\x0c\n\x04\x05\x18\x02\x03\x12\x04\xa3\t\
    \x04%\n\r\n\x05\x05\x18\x02\x03\x01\x12\x04\xa3\t\x04\x20\n\r\n\x05\x05\
    \x18\x02\x03\x02\x12\x04\xa3\t#$\n\x0c\n\x02\x04\\\x12\x06\xa6\t\0\xa9\t\
    \x01\n\x0b\n\x03\x04\\\x01\x12\x04\xa6\t\x08\x1f\n\x1e\n\x04\x04\\\x02\0\
    \x12\x04\xa8\t\x04\x1f\"\x10empty\x20means\x20all\n\n\r\n\x05\x04\\\x02\
    \0\x04\x12\x04\xa8\t\x04\x0c\n\r\n\x05\x04\\\x02\0\x05\x12\x04\xa8\t\r\
    \x12\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xa8\t\x13\x1a\n\r\n\x05\x04\\\x02\
    \0\x03\x12\x04\xa8\t\x1d\x1e\n\x0c\n\x02\x04]\x12\x06\xab\t\0\xb5\t\x01\
    \n\x0b\n\x03\x04]\x01\x12\x04\xab\t\x08\x1a\n\x0c\n\x04\x04]\x02\0\x12\
    \x04\xad\t\x04\x15\n\r\n\x05\x04]\x02\0\x05\x12\x04\xad\t\x04\t\n\r\n\
    \x05\x04]\x02\0\x01\x12\x04\xad\t\n\x10\n\r\n\x05\x04]\x02\0\x03\x12\x04\
    \xad\t\x13\x14\n\x0c\n\x04\x04]\x02\x01\x12\x04\xae\t\x04!\n\r\n\x05\x04\
    ]\x02\x01\x06\x12\x04\xae\t\x04\x13\n\r\n\x05\x04]\x02\x01\x01\x12\x04\
    \xae\t\x14\x1c\n\r\n\x05\x04]\x02\x01\x03\x12\x04\xae\t\x1f\x20\n\x0c\n\
    \x04\x04]\x02\x02\x12\x04\xaf\t\x04%\n\r\n\x05\x04]\x02\x02\x06\x12\x04\
    \xaf\t\x04\x15\n\r\n\x05\x04]\x02\x02\x01\x12\x04\xaf\t\x16\x20\n\r\n\
    \x05\x04]\x02\x02\x03\x12\x04\xaf\t#$\n\x0c\n\x04\x04]\x02\x03\x12\x04\
    \xb0\t\x04\x1f\n\r\n\x05\x04]\x02\x03\x05\x12\x04\xb0\t\x04\t\n\r\n\x05\
    \x04]\x02\x03\x01\x12\x04\xb0\t\n\x1a\n\r\n\x05\x04]\x02\x03\x03\x12\x04\
    \xb0\t\x1d\x1e\n\x0c\n\x04\x04]\x02\x04\x12\x04\xb1\t\x04\"\n\r\n\x05\
    \x04]\x02\x04\x05\x12\x04\xb1\t\x04\t\n\r\n\x05\x04]\x02\x04\x01\x12\x04\
    \xb1\t\n\x1d\n\r\n\x05\x04]\x02\x04\x03\x12\x04\xb1\t\x20!\n\x0c\n\x04\
    \x04]\x02\x05\x12\x04\xb2\t\x04\x18\n\r\n\x05\x04]\x02\x05\x05\x12\x04\
    \xb2\t\x04\t\n\r\n\x05\x04]\x02\x05\x01\x12\x04\xb2\t\n\x13\n\r\n\x05\
    \x04]\x02\x05\x03\x12\x04\xb2\t\x16\x17\n\x0c\n\x04\x04]\x02\x06\x12\x04\
    \xb3\t\x04\x16\n\r\n\x05\x04]\x02\x06\x05\x12\x04\xb3\t\x04\t\n\r\n\x05\
    \x04]\x02\x06\x01\x12\x04\xb3\t\n\x11\n\r\n\x05\x04]\x02\x06\x03\x12\x04\
    \xb3\t\x14\x15\n\x0c\n\x04\x04]\x02\x07\x12\x04\xb4\t\x04%\n\r\n\x05\x04\
    ]\x02\x07\x06\x12\x04\xb4\t\x04\r\n\r\n\x05\x04]\x02\x07\x01\x12\x04\xb4\
    \t\x0e\x20\n\r\n\x05\x04]\x02\x07\x03\x12\x04\xb4\t#$\n\x0c\n\x02\x04^\
    \x12\x06\xb7\t\0\xba\t\x01\n\x0b\n\x03\x04^\x01\x12\x04\xb7\t\x08\x1d\n\
    \x0c\n\x04\x04^\x02\0\x12\x04\xb9\t\x04,\n\r\n\x05\x04^\x02\0\x04\x12\
    \x04\xb9\t\x04\x0c\n\r\n\x05\x04^\x02\0\x06\x12\x04\xb9\t\r\x1f\n\r\n\
    \x05\x04^\x02\0\x01\x12\x04\xb9\t\x20'\n\r\n\x05\x04^\x02\0\x03\x12\x04\
    \xb9\t*+\n\x0c\n\x02\x05\x19\x12\x06\xbc\t\0\xc2\t\x01\n\x0b\n\x03\x05\
    \x19\x01\x12\x04\xbc\t\x05\x1a\n\x0c\n\x04\x05\x19\x02\0\x12\x04\xbe\t\
    \x04#\n\r\n\x05\x05\x19\x02\0\x01\x12\x04\xbe\t\x04\x1e\n\r\n\x05\x05\
    \x19\x02\0\x02\x12\x04\xbe\t!\"\n\x0c\n\x04\x05\x19\x02\x01\x12\x04\xbf\
    \t\x04\"\n\r\n\x05\x05\x19\x02\x01\x01\x12\x04\xbf\t\x04\x1d\n\r\n\x05\
    \x05\x19\x02\x01\x02\x12\x04\xbf\t\x20!\n\x0c\n\x04\x05\x19\x02\x02\x12\
    \x04\xc0\t\x04\"\n\r\n\x05\x05\x19\x02\x02\x01\x12\x04\xc0\t\x04\x1d\n\r\
    \n\x05\x05\x19\x02\x02\x02\x12\x04\xc0\t\x20!\n\x0c\n\x04\x05\x19\x02\
    \x03\x12\x04\xc1\t\x04%\n\r\n\x05\x05\x19\x02\x03\x01\x12\x04\xc1\t\x04\
    \x20\n\r\n\x05\x05\x19\x02\x03\x02\x12\x04\xc1\t#$\n\x0c\n\x02\x04_\x12\
    \x06\xc4\t\0\xca\t\x01\n\x0b\n\x03\x04_\x01\x12\x04\xc4\t\x08\x20\n\x0c\
    \n\x04\x04_\x02\0\x12\x04\xc6\t\x04#\n\r\n\x05\x04_\x02\0\x06\x12\x04\
    \xc6\t\x04\x19\n\r\n\x05\x04_\x02\0\x01\x12\x04\xc6\t\x1a\x1e\n\r\n\x05\
    \x04_\x02\0\x03\x12\x04\xc6\t!\"\n\x0c\n\x04\x04_\x02\x01\x12\x04\xc7\t\
    \x04!\n\r\n\x05\x04_\x02\x01\x06\x12\x04\xc7\t\x04\x13\n\r\n\x05\x04_\
    \x02\x01\x01\x12\x04\xc7\t\x14\x1c\n\r\n\x05\x04_\x02\x01\x03\x12\x04\
    \xc7\t\x1f\x20\n\x1f\n\x04\x04_\x02\x02\x12\x04\xc8\t\x04\x15\"\x110\x20\
    means\x20new\x20task\n\n\r\n\x05\x04_\x02\x02\x05\x12\x04\xc8\t\x04\t\n\
    \r\n\x05\x04_\x02\x02\x01\x12\x04\xc8\t\n\x10\n\r\n\x05\x04_\x02\x02\x03\
    \x12\x04\xc8\t\x13\x14\n\x0c\n\x04\x04_\x02\x03\x12\x04\xc9\t\x04!\n\r\n\
    \x05\x04_\x02\x03\x04\x12\x04\xc9\t\x04\x0c\n\r\n\x05\x04_\x02\x03\x05\
    \x12\x04\xc9\t\r\x12\n\r\n\x05\x04_\x02\x03\x01\x12\x04\xc9\t\x13\x1c\n\
    \r\n\x05\x04_\x02\x03\x03\x12\x04\xc9\t\x1f\x20\n\x0c\n\x02\x04`\x12\x06\
    \xcc\t\0\xcf\t\x01\n\x0b\n\x03\x04`\x01\x12\x04\xcc\t\x08\x1e\n\x0c\n\
    \x04\x04`\x02\0\x12\x04\xce\t\x04\x15\n\r\n\x05\x04`\x02\0\x05\x12\x04\
    \xce\t\x04\t\n\r\n\x05\x04`\x02\0\x01\x12\x04\xce\t\n\x10\n\r\n\x05\x04`\
    \x02\0\x03\x12\x04\xce\t\x13\x14\n\x0c\n\x02\x04a\x12\x06\xd1\t\0\xd4\t\
    \x01\n\x0b\n\x03\x04a\x01\x12\x04\xd1\t\x08-\n\x0c\n\x04\x04a\x02\0\x12\
    \x04\xd3\t\x04+\n\r\n\x05\x04a\x02\0\x04\x12\x04\xd3\t\x04\x0c\n\r\n\x05\
    \x04a\x02\0\x06\x12\x04\xd3\t\r\x1c\n\r\n\x05\x04a\x02\0\x01\x12\x04\xd3\
    \t\x1d&\n\r\n\x05\x04a\x02\0\x03\x12\x04\xd3\t)*\n\x0c\n\x02\x04b\x12\
    \x06\xd6\t\0\xde\t\x01\n\x0b\n\x03\x04b\x01\x12\x04\xd6\t\x08+\n\x0e\n\
    \x04\x04b\x03\0\x12\x06\xd8\t\x04\xdc\t\x05\n\r\n\x05\x04b\x03\0\x01\x12\
    \x04\xd8\t\x0c#\n\x0e\n\x06\x04b\x03\0\x02\0\x12\x04\xda\t\x08%\n\x0f\n\
    \x07\x04b\x03\0\x02\0\x06\x12\x04\xda\t\x08\x17\n\x0f\n\x07\x04b\x03\0\
    \x02\0\x01\x12\x04\xda\t\x18\x20\n\x0f\n\x07\x04b\x03\0\x02\0\x03\x12\
    \x04\xda\t#$\n\x0e\n\x06\x04b\x03\0\x02\x01\x12\x04\xdb\t\x08,\n\x0f\n\
    \x07\x04b\x03\0\x02\x01\x04\x12\x04\xdb\t\x08\x10\n\x0f\n\x07\x04b\x03\0\
    \x02\x01\x05\x12\x04\xdb\t\x11\x16\n\x0f\n\x07\x04b\x03\0\x02\x01\x01\
    \x12\x04\xdb\t\x17'\n\x0f\n\x07\x04b\x03\0\x02\x01\x03\x12\x04\xdb\t*+\n\
    \x0c\n\x04\x04b\x02\0\x12\x04\xdd\t\x041\n\r\n\x05\x04b\x02\0\x04\x12\
    \x04\xdd\t\x04\x0c\n\r\n\x05\x04b\x02\0\x06\x12\x04\xdd\t\r$\n\r\n\x05\
    \x04b\x02\0\x01\x12\x04\xdd\t%,\n\r\n\x05\x04b\x02\0\x03\x12\x04\xdd\t/0\
    \n\x0c\n\x02\x05\x1a\x12\x06\xe0\t\0\xe5\t\x01\n\x0b\n\x03\x05\x1a\x01\
    \x12\x04\xe0\t\x05*\n\x0c\n\x04\x05\x1a\x02\0\x12\x04\xe2\t\x043\n\r\n\
    \x05\x05\x1a\x02\0\x01\x12\x04\xe2\t\x04.\n\r\n\x05\x05\x1a\x02\0\x02\
    \x12\x04\xe2\t12\n\x0c\n\x04\x05\x1a\x02\x01\x12\x04\xe3\t\x042\n\r\n\
    \x05\x05\x1a\x02\x01\x01\x12\x04\xe3\t\x04-\n\r\n\x05\x05\x1a\x02\x01\
    \x02\x12\x04\xe3\t01\n\x0c\n\x04\x05\x1a\x02\x02\x12\x04\xe4\t\x042\n\r\
    \n\x05\x05\x1a\x02\x02\x01\x12\x04\xe4\t\x04-\n\r\n\x05\x05\x1a\x02\x02\
    \x02\x12\x04\xe4\t01\n\x0c\n\x02\x04c\x12\x06\xe7\t\0\xee\t\x01\n\x0b\n\
    \x03\x04c\x01\x12\x04\xe7\t\x08)\n\x0c\n\x04\x04c\x02\0\x12\x04\xe9\t\
    \x048\n\r\n\x05\x04c\x02\0\x06\x12\x04\xe9\t\x04)\n\r\n\x05\x04c\x02\0\
    \x01\x12\x04\xe9\t*3\n\r\n\x05\x04c\x02\0\x03\x12\x04\xe9\t67\n\x0c\n\
    \x04\x04c\x02\x01\x12\x04\xea\t\x04!\n\r\n\x05\x04c\x02\x01\x06\x12\x04\
    \xea\t\x04\x13\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xea\t\x14\x1c\n\r\n\
    \x05\x04c\x02\x01\x03\x12\x04\xea\t\x1f\x20\n\x0c\n\x04\x04c\x02\x02\x12\
    \x04\xeb\t\x04\x15\n\r\n\x05\x04c\x02\x02\x05\x12\x04\xeb\t\x04\t\n\r\n\
    \x05\x04c\x02\x02\x01\x12\x04\xeb\t\n\x10\n\r\n\x05\x04c\x02\x02\x03\x12\
    \x04\xeb\t\x13\x14\n\x0c\n\x04\x04c\x02\x03\x12\x04\xec\t\x04\x19\n\r\n\
    \x05\x04c\x02\x03\x05\x12\x04\xec\t\x04\n\n\r\n\x05\x04c\x02\x03\x01\x12\
    \x04\xec\t\x0b\x14\n\r\n\x05\x04c\x02\x03\x03\x12\x04\xec\t\x17\x18\n\
    \x0c\n\x04\x04c\x02\x04\x12\x04\xed\t\x04!\n\r\n\x05\x04c\x02\x04\x04\
    \x12\x04\xed\t\x04\x0c\n\r\n\x05\x04c\x02\x04\x05\x12\x04\xed\t\r\x12\n\
    \r\n\x05\x04c\x02\x04\x01\x12\x04\xed\t\x13\x1c\n\r\n\x05\x04c\x02\x04\
    \x03\x12\x04\xed\t\x1f\x20\n\x0c\n\x02\x04d\x12\x06\xf0\t\0\xf8\t\x01\n\
    \x0b\n\x03\x04d\x01\x12\x04\xf0\t\x08+\n\x0c\n\x04\x04d\x02\0\x12\x04\
    \xf2\t\x04\x19\n\r\n\x05\x04d\x02\0\x05\x12\x04\xf2\t\x04\n\n\r\n\x05\
    \x04d\x02\0\x01\x12\x04\xf2\t\x0b\x14\n\r\n\x05\x04d\x02\0\x03\x12\x04\
    \xf2\t\x17\x18\n\x0c\n\x04\x04d\x02\x01\x12\x04\xf3\t\x04\x15\n\r\n\x05\
    \x04d\x02\x01\x05\x12\x04\xf3\t\x04\t\n\r\n\x05\x04d\x02\x01\x01\x12\x04\
    \xf3\t\n\x10\n\r\n\x05\x04d\x02\x01\x03\x12\x04\xf3\t\x13\x14\n\x0c\n\
    \x04\x04d\x02\x02\x12\x04\xf4\t\x04!\n\r\n\x05\x04d\x02\x02\x06\x12\x04\
    \xf4\t\x04\x13\n\r\n\x05\x04d\x02\x02\x01\x12\x04\xf4\t\x14\x1c\n\r\n\
    \x05\x04d\x02\x02\x03\x12\x04\xf4\t\x1f\x20\nH\n\x04\x04d\x02\x03\x12\
    \x04\xf5\t\x04%\":PBBatchTaskStatus_Finished\x20/\x20PBBatchTaskStatus_M\
    axReached\n\n\r\n\x05\x04d\x02\x03\x06\x12\x04\xf5\t\x04\x15\n\r\n\x05\
    \x04d\x02\x03\x01\x12\x04\xf5\t\x16\x20\n\r\n\x05\x04d\x02\x03\x03\x12\
    \x04\xf5\t#$\n\x0c\n\x04\x04d\x02\x04\x12\x04\xf6\t\x04\x1f\n\r\n\x05\
    \x04d\x02\x04\x05\x12\x04\xf6\t\x04\t\n\r\n\x05\x04d\x02\x04\x01\x12\x04\
    \xf6\t\n\x1a\n\r\n\x05\x04d\x02\x04\x03\x12\x04\xf6\t\x1d\x1e\n\x0c\n\
    \x04\x04d\x02\x05\x12\x04\xf7\t\x04\"\n\r\n\x05\x04d\x02\x05\x05\x12\x04\
    \xf7\t\x04\t\n\r\n\x05\x04d\x02\x05\x01\x12\x04\xf7\t\n\x1d\n\r\n\x05\
    \x04d\x02\x05\x03\x12\x04\xf7\t\x20!\n\x0c\n\x02\x04e\x12\x06\xfa\t\0\
    \x82\n\x01\n\x0b\n\x03\x04e\x01\x12\x04\xfa\t\x08\x1d\n\x0c\n\x04\x04e\
    \x02\0\x12\x04\xfc\t\x04\x18\n\r\n\x05\x04e\x02\0\x06\x12\x04\xfc\t\x04\
    \x0e\n\r\n\x05\x04e\x02\0\x01\x12\x04\xfc\t\x0f\x13\n\r\n\x05\x04e\x02\0\
    \x03\x12\x04\xfc\t\x16\x17\n\x0c\n\x04\x04e\x02\x01\x12\x04\xfd\t\x04!\n\
    \r\n\x05\x04e\x02\x01\x05\x12\x04\xfd\t\x04\n\n\r\n\x05\x04e\x02\x01\x01\
    \x12\x04\xfd\t\x0b\x1c\n\r\n\x05\x04e\x02\x01\x03\x12\x04\xfd\t\x1f\x20\
    \n\x0e\n\x04\x04e\x08\0\x12\x06\xfe\t\x04\x81\n\x05\n\r\n\x05\x04e\x08\0\
    \x01\x12\x04\xfe\t\n\x16\n\x0c\n\x04\x04e\x02\x02\x12\x04\x80\n\x08B\n\r\
    \n\x05\x04e\x02\x02\x06\x12\x04\x80\n\x08%\n\r\n\x05\x04e\x02\x02\x01\
    \x12\x04\x80\n&=\n\r\n\x05\x04e\x02\x02\x03\x12\x04\x80\n@A\n\x0c\n\x02\
    \x04f\x12\x06\x84\n\0\x88\n\x01\n\x0b\n\x03\x04f\x01\x12\x04\x84\n\x08$\
    \n\x0c\n\x04\x04f\x02\0\x12\x04\x86\n\x04\x19\n\r\n\x05\x04f\x02\0\x05\
    \x12\x04\x86\n\x04\n\n\r\n\x05\x04f\x02\0\x01\x12\x04\x86\n\x0b\x14\n\r\
    \n\x05\x04f\x02\0\x03\x12\x04\x86\n\x17\x18\n\x0c\n\x04\x04f\x02\x01\x12\
    \x04\x87\n\x04\x20\n\r\n\x05\x04f\x02\x01\x06\x12\x04\x87\n\x04\x10\n\r\
    \n\x05\x04f\x02\x01\x01\x12\x04\x87\n\x11\x1b\n\r\n\x05\x04f\x02\x01\x03\
    \x12\x04\x87\n\x1e\x1f\n\x0c\n\x02\x04g\x12\x06\x8a\n\0\x8f\n\x01\n\x0b\
    \n\x03\x04g\x01\x12\x04\x8a\n\x08\"\n\x0c\n\x04\x04g\x02\0\x12\x04\x8c\n\
    \x04\x20\n\r\n\x05\x04g\x02\0\x06\x12\x04\x8c\n\x04\x10\n\r\n\x05\x04g\
    \x02\0\x01\x12\x04\x8c\n\x11\x1b\n\r\n\x05\x04g\x02\0\x03\x12\x04\x8c\n\
    \x1e\x1f\n\x0c\n\x04\x04g\x02\x01\x12\x04\x8d\n\x04!\n\r\n\x05\x04g\x02\
    \x01\x04\x12\x04\x8d\n\x04\x0c\n\r\n\x05\x04g\x02\x01\x06\x12\x04\x8d\n\
    \r\x14\n\r\n\x05\x04g\x02\x01\x01\x12\x04\x8d\n\x15\x1c\n\r\n\x05\x04g\
    \x02\x01\x03\x12\x04\x8d\n\x1f\x20\n\x0c\n\x04\x04g\x02\x02\x12\x04\x8e\
    \n\x04\x15\n\r\n\x05\x04g\x02\x02\x05\x12\x04\x8e\n\x04\x08\n\r\n\x05\
    \x04g\x02\x02\x01\x12\x04\x8e\n\t\x10\n\r\n\x05\x04g\x02\x02\x03\x12\x04\
    \x8e\n\x13\x14\n\x0c\n\x02\x05\x1b\x12\x06\x91\n\0\x96\n\x01\n\x0b\n\x03\
    \x05\x1b\x01\x12\x04\x91\n\x05\x16\n\x0c\n\x04\x05\x1b\x02\0\x12\x04\x93\
    \n\x04\x1e\n\r\n\x05\x05\x1b\x02\0\x01\x12\x04\x93\n\x04\x19\n\r\n\x05\
    \x05\x1b\x02\0\x02\x12\x04\x93\n\x1c\x1d\n\x0c\n\x04\x05\x1b\x02\x01\x12\
    \x04\x94\n\x04'\n\r\n\x05\x05\x1b\x02\x01\x01\x12\x04\x94\n\x04\"\n\r\n\
    \x05\x05\x1b\x02\x01\x02\x12\x04\x94\n%&\n\x0c\n\x04\x05\x1b\x02\x02\x12\
    \x04\x95\n\x04&\n\r\n\x05\x05\x1b\x02\x02\x01\x12\x04\x95\n\x04!\n\r\n\
    \x05\x05\x1b\x02\x02\x02\x12\x04\x95\n$%\n\x0c\n\x02\x04h\x12\x06\x98\n\
    \0\x9e\n\x01\n\x0b\n\x03\x04h\x01\x12\x04\x98\n\x08\"\n\x0c\n\x04\x04h\
    \x02\0\x12\x04\x9a\n\x04\x19\n\r\n\x05\x04h\x02\0\x05\x12\x04\x9a\n\x04\
    \n\n\r\n\x05\x04h\x02\0\x01\x12\x04\x9a\n\x0b\x14\n\r\n\x05\x04h\x02\0\
    \x03\x12\x04\x9a\n\x17\x18\n\x0c\n\x04\x04h\x02\x01\x12\x04\x9b\n\x04\
    \x17\n\r\n\x05\x04h\x02\x01\x05\x12\x04\x9b\n\x04\n\n\r\n\x05\x04h\x02\
    \x01\x01\x12\x04\x9b\n\x0b\x12\n\r\n\x05\x04h\x02\x01\x03\x12\x04\x9b\n\
    \x15\x16\n\x0c\n\x04\x04h\x02\x02\x12\x04\x9c\n\x04\x1f\n\r\n\x05\x04h\
    \x02\x02\x06\x12\x04\x9c\n\x04\x15\n\r\n\x05\x04h\x02\x02\x01\x12\x04\
    \x9c\n\x16\x1a\n\r\n\x05\x04h\x02\x02\x03\x12\x04\x9c\n\x1d\x1e\n\x0c\n\
    \x04\x04h\x02\x03\x12\x04\x9d\n\x04\x20\n\r\n\x05\x04h\x02\x03\x06\x12\
    \x04\x9d\n\x04\x10\n\r\n\x05\x04h\x02\x03\x01\x12\x04\x9d\n\x11\x1b\n\r\
    \n\x05\x04h\x02\x03\x03\x12\x04\x9d\n\x1e\x1f\n\x0c\n\x02\x04i\x12\x06\
    \xa0\n\0\xa5\n\x01\n\x0b\n\x03\x04i\x01\x12\x04\xa0\n\x08\x20\n\x0c\n\
    \x04\x04i\x02\0\x12\x04\xa2\n\x04\x20\n\r\n\x05\x04i\x02\0\x06\x12\x04\
    \xa2\n\x04\x10\n\r\n\x05\x04i\x02\0\x01\x12\x04\xa2\n\x11\x1b\n\r\n\x05\
    \x04i\x02\0\x03\x12\x04\xa2\n\x1e\x1f\n\x0c\n\x04\x04i\x02\x01\x12\x04\
    \xa3\n\x04.\n\r\n\x05\x04i\x02\x01\x04\x12\x04\xa3\n\x04\x0c\n\r\n\x05\
    \x04i\x02\x01\x06\x12\x04\xa3\n\r!\n\r\n\x05\x04i\x02\x01\x01\x12\x04\
    \xa3\n\")\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xa3\n,-\n\x0c\n\x04\x04i\
    \x02\x02\x12\x04\xa4\n\x04\x15\n\r\n\x05\x04i\x02\x02\x05\x12\x04\xa4\n\
    \x04\x08\n\r\n\x05\x04i\x02\x02\x01\x12\x04\xa4\n\t\x10\n\r\n\x05\x04i\
    \x02\x02\x03\x12\x04\xa4\n\x13\x14b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
